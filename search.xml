<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue 2.0 学习之旅（一）--安装]]></title>
    <url>%2F2018%2F09%2F29%2Fvue%20%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[从今天开始学习前端框架 Vue，该系列的文章主要记录自己在 Vue 的学习过程中所了解到的一些基础知识。 兼容性Vue不支持 IE8 及以下版本。 辅助工具在使用 Vue 时推荐在浏览器上安装 Vue Devtools。它允许你在一个更友好的界面中审查和调试 Vue 应用。 Vue.js 安装教程直接下载直接下载vue.js文件，然后通过&lt;script>标签引用。&lt;script src=&quot;/地址/vue.js&quot;&gt;&lt;/script&gt; CDN 方法 BootCDN（国内） :&lt;script src=&quot;https://cdn.bootcss.com/2.5.16/vue.js&quot;&gt;&lt;/script&gt; 其它（国外）：&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https:/unpkg.com/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.16/vue.js&quot;&gt;&lt;/script&gt;改变&lt;script>标签内的数字就可以手动选择 Vue.js 的不同版本。关于 Vue.js 的版本情况你可以登录 http://www.bootcdn.cn/ 或者其他网址查看。版本说明开发版本 vue.js 包含完整的警告和调试模式（建议学习过程中使用该版本）生产版本 vue.min.js 是一个更小的构建，可以获得比开发环境下更快的速度体验。（建议在实际项目中使用该版本）下面附上一张第一次成功运行的图片：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 学习之 -- Vue 实例]]></title>
    <url>%2F2018%2F09%2F29%2Fvue%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Vue实例每个Vue应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：123var vm=new Vue(&#123; //选项&#125;) 当创建一个 Vue 实例对象之后，你可以传入一个选项对象。一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可嵌套的、可复用的组件树构成。 数据与方法当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。当这些数据改变时，视图会重新渲染。但是只有在实例被创建时 data 中存在的属性才是响应式的。也就是说如果你添加一个新的属性，随后对b的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你可以设置一些初始值。唯一的例外是使用 object.freeze(),这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $ ,以便和用户定义的属性区分开来。]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue实例</category>
      </categories>
      <tags>
        <tag>Vue实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程处理 -- Web Workers]]></title>
    <url>%2F2018%2F01%2F01%2Fwebwork%2F</url>
    <content type="text"><![CDATA[使用Javascript执行大型计算时，经常会出现假死现象。这是因为Javascript是单线程的编程语言，运算能力比较弱。HTML5新增的Web Workers API能够创建一个不影响前台处理的后台线程，并且在这个后台线程中可以创建多个子线程，以帮助Javascript实现多线程运算的能力。通过Web Workers，用户可以将耗时较长的处理交给后台线程去执行，从而解决了HTML5之前因为某个处理耗时过长而不得不提前结束的尴尬。 Web Workers 基础Web workers为网页脚本提供了一种能在后台进程中运行的方法。当创建Web Worker对象后，Web Workers就可以通过postMessage()方法向任务池发送任务请求，执行完之后再通过postMessage()返回消息给创建者指定的事件处理程序，然后通过onmessage捕获返回消息，实现前后台数据的交互。 认识Web Workers在Web应用程序中，Web Workers是一项后台处理技术。在此之前使用Javascript创建的Web程序中，因为所有的处理都是在单线程内执行，所以如果脚本需要很长时间运行的话，程序界面会长时间处于停止响应状态。甚至当等待时间超出一定的限度，浏览器会提示脚本运行时间较长需要终端正在执行的处理。为了解决这个问题，HTML5新增了一个Web Worker API。使用这个Api，用户可以很容易地创建在后台运行的线程，这个线程被称为worker，如果将可能耗费较长时间的处理交给后台去执行的话，对用户在前台页面中执行的操作就没有影响了。尽管Web Worker的功能强大，但并不是万能的，有些事情它还做不到。例如，在Web Worker中执行的脚本不能访问该页面的window对象，因此WebWorker不能直接访问Web页面和DOM API，虽然Web worker不会导致浏览器UI停止响应，但是仍会消耗CPU周期，导致系统反应速度变慢。如果开发人员创建的Web 应用程序需要执行一些后台数据处理，但又不希望这些数据处理任务影响Web页面本身的交互性，那么可以通过Web Workers生成一个worker去处理数据任务，同时添加一个时间监听器进行监听，并与之进行数据交互。 Web Workers能够为我们做什么？ 加载一个Javascript文件，进行大量的复杂计算，而不挂起主进程，并通过postMessage,onMessage进行通信 可以在Worker中通过importScripts（url）方法加载JavaScript脚本文件 可以使用setTimeout()、clearTimeout()、setInterval()、clearInterval() 可以使用XMLHttpRequest()进行异步请求 可以访问navigator的部分属性 可以使用Javascript的核心对象 Web Workers的局限性： 不能跨域加载JavaScript Worker内代码不能访问DOM 各个浏览器对Worker的实现没有完全完善，不是每个浏览器都支持所有的新特性 使用Web Workers加载数据没有JSONP和Ajax加载数据高效浏览器支持在调用Web Workers API函数之前，应该确认浏览器是否支持。如果不支持，可以提供一些备用信息，提醒用户使用最新的浏览器。12345function testWorker()&#123; if (typeof Worker !== &quot;undefined&quot;)&#123; document.getElementById(&apos;support&apos;).innerHTML=&apos;您的浏览器不支持 HTML5 Web Worker&apos;； &#125;&#125; 创建Web Workers调用Worker构造函数可以创建一个worker线程。Worker在初始化的时候会接受一个URL参数，参数URl表示要执行的脚本文件地址，其中包含了供Worker执行的代码。worker=new Worker(&#39;xxx.js&#39;)如果要获取worker进程的返回值，可以使用onmessage时间进行监听。1234var myWorker=new Worker(&apos;xxx.js&apos;);myWorker.onmessage=function(event)&#123; alert(&apos;Called back by the worker&apos;)；&#125;； 在上面的代码中，第一行代码将创建和运行worker进程，第二行设置worker的onmessage属性，绑定事件处理函数，当worker的postmessge()方法被调用时，这个被绑定的事件处理函数就会被调用。对于由多个JavaScript文件组成的应用程序来说，可以通过包含script元素的方式，在页面加载的时候同步加载JavaScript文件。由于Web Workers没有访问Document对象的权限，所以在worker中只能使用importScripts()方法导入其他JavaScript文件。importScripts（）是全局函数，该函数可以将脚本或库导入到它们的作用域中，导入的JavaScript文件只会在某一个已有的Worker中加载和执行。多个脚本的导入同样也可以使用importScripts（）函数，它们会按顺序执行。importScripts（）可以接受空的参数或多个脚本URl参数。(在后台线程中使用)123importScripts（）;importScripts（&apos;foo.js&apos;）;importScripts（&apos;foo.js&apos;,&apos;bar.js&apos;） JavaScript会加载列出的每一个脚本文件，然后运行并初始化。这些脚本中的任何全局对象都可以被worker使用。importScripts（）方法下载脚本的顺序可能不一样，但执行的顺序一定是按importScripts（）方法中列出的顺序进行，而且是同步的，在所有脚本加载完并运行结束后importScripts（）才会返回。Web Worker能够嵌套使用，以创建子Worker。用户可以创建多个子worker。子worker必须寄宿于同一个父页面下，且它的URL必须与父worker的地址同源，这样可以很好的维持它们的依赖关系。Web Workers可以使用setTimeout（）和setInterval()。如果希望Web Worker进程周期性地运行而不是不停地循环下去的话，使用这两个方法非常有用。用户可以通过Worker对象的onmessage事件获取后台线程反馈的消息。使用postMessage（）方法可以给后台线程发送消息。发送的消息是文本数据，但也可以是任何Javascript对象，需要通过JSON对象的stringify（）方法将其转换成文本数据。在线程调用的Javascript脚本文件中，所有可用的变量、函数和类的说明如下：self：self关键字用来表示本线程范围内的作用域。postMessage：向创建线程的源窗口发送消息。（myWorker.postMessage()是在源窗口向后台线程发送消息）onmessage：后台线程接受源窗口消息的事件句柄（myworker.onmessage（）是源窗口接受后台线程消息的事件句柄)importScripts（URL）：在后台线程中导入其它Javascript脚本文件。navigator对象：与window.navigator对象类似，具有appName、platform、userAgent、appVersion属性。sessionStorage/localStorage:在线程中可以使用web Storage。XMLHttpRequest:在线程中可以处理ajax请求。Web Workers：在线程中可以嵌套线程。setTimeout()/setInterval():在线程中可以实现定时处理。close：结束本线程（myworker.terminate()）eval()、isNaN()、escape()等：可以使用所有Javascript核心函数object：可以创建和使用本地对象WebSockets：可以使用Web Sockets API向服务器发送和接收消息 Web Workers通信使用后台线程不能访问页面或窗口对象，但是并不代表后台线程不能与页面进行数据交互。为了实现页面与Web Workers通信，可以调用postMessage函数传入所需数据。同时将建立一个监听器，用来监听由Web Workers 发送到页面的消息。为建立页面与worker之间的通信，首先要在页面中添加对postMessage（）函数的调用:123document.getElementById(&apos;helloButton&apos;).onclick=function()&#123; worker.postMessage(&apos;你好&apos;)；&#125; 当用户单击按钮后，相应消息会发送到worker，然后将事件监听器添加到页面中，用来监听从worker发来的消息。1234worker.addEventListener(&apos;message&apos;,messageHandler,true);function messageHandler(e)&#123; //来自worker的处理信息&#125; 编写HTML5 Web Workers Javascript文件。在该文件中，需要添加时间监听器以监听发来的消息，并且通过调用postMessage函数实现与页面之间的通信。为了完成页面与Web Workers之间的通信功能。首先，添加代码调用postMessage函数。123function messageHandler(e)&#123; postMessage(&apos;worker说：&apos;+e.data+&apos; too&apos;);&#125; 接下来，在Web Workers Javascript文件中添加事件监听器。以处理从页面发来的消息。接收到信息后马上调用messageHandler函数以保证信息能够及时返回。通过postMessage函数对象传递到Workers或者从中返回对象，这些将自动转换成JSON格式。(在workers中的对象不能包含函数和循环引用，因为JSON不支持它们)123var onmessage=function(e)&#123; postMessage(e.data);&#125;; 在Web Workers脚本中如果发生未处理的错误。会引发Web Workers对象的错误事件。特别是在调式用到Web Workers脚本时，对错误事件的监听器就显得尤为重要了。下面显示的Web Workers Javascript文件中的错误处理函数，它将错误记录在控制台上。123function errorHandler（e）&#123; console.log(e.message,e);&#125; 为了处理错误，还必须在主页上添加一个事件监听器：worker.addEventListener(&#39;error&#39;,errorHandler,true);当worker运行发生错误时，它的onerror事件就会被触发。该事件不会冒泡，并且可以取消。要取消该事件可以使用proventDefault()方法。该错误事件有三个属性：message：可读的错误信息filename：发生错误的脚本文件名称lineno：发生错误的脚本所在的行数Web Workers不能自行终止，但能够被启用它们的页面所终止，通用terminate()函数可以终止后台进程。被终止的Web Workers将不再响应任何消息或者执行任何其它的计算。终止之后，Worker不能被重新启动，但可以使用相同的URL创建一个新的worker。worker.terminate() 案例：使用Web Workers注意：由于一些浏览器不支持读取本地文件，所以为了保证测试效果，建议将测试代码放在服务器上进行测试。【示例1】本例演示了如何使用Web Worker在控制台显示一条提示信息。(1)主页文件：12345678910111213141516171819&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;//WEB页主线程var worker = new Worker(&quot;worker.js&quot;);//创建一个Worker对象并向它传递将在新线程中执行的脚本的URLworker.postMessage(&quot;hello world&quot;);//向worker发送数据worker.onmessage = function(evt) &#123;//接收worker传过来的数据函数 console.log(evt.data); //输出worker发送来的数据&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; (2)后台线程文件（worker.js）：123456onmessage = function(evt) &#123; var d = evt.data; //通过evt.data获得发送来的数据 postMessage(d); //将获取到的数据发送会主线程&#125; 通过上面的实例可以看出来，Web Workers包括两个部分： 定义主页线程 通过worker =new Worker（url）加载一个Javascript文件，创建一个worker，同时返回一个worker实例 通过worker.postMessage（data）方法向worker发送数据 通过worker.onmessage事件接受worker响应的数据 使用worker.terminate()可以终止一个worker执行 定义worker线程 通过postMessage（data）向主线程发送数据 绑定onmessage事件接受主线程发送过来的数据【示例2】本例演示如何创建Web workers，手动控制Web workers与页面进行通信的一般方法，同时设置如何处理异常，以及如何停止worker 任务处理。(1)主页文件：1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;p id=&quot;support&quot;&gt;你的浏览器不支持 HTML5 Web Workers&lt;/p&gt;&lt;button id=&quot;stopButton&quot; &gt;停止任务&lt;/button&gt;&lt;button id=&quot;helloButton&quot; &gt;发送消息&lt;/button&gt;&lt;script&gt;function stopWorker() &#123; worker.terminate(); &#125;function messageHandler(e) &#123; console.log(e.data);&#125;function errorHandler(e) &#123; console.warn(e.message, e);&#125;function loadDemo() &#123; if( typeof (Worker) !== &quot;undefined&quot;) &#123; document.getElementById(&quot;support&quot;).innerHTML = &quot;你的浏览器支持HTML5 Web Workers&quot;; worker = new Worker(&quot;worker.js&quot;); worker.addEventListener(&quot;message&quot;, messageHandler, true); worker.addEventListener(&quot;error&quot;, errorHandler, true); document.getElementById(&quot;helloButton&quot;).onclick = function() &#123; worker.postMessage(&quot;ok&quot;); &#125; document.getElementById(&quot;stopButton&quot;).onclick = stopWorker; &#125;&#125;window.addEventListener(&quot;load&quot;, loadDemo, true);&lt;/script&gt; (2)后台线程文件（worker.js）：1234function messageHandler(e) &#123; postMessage(&quot;worker says: &quot; + e.data );&#125;addEventListener(&quot;message&quot;, messageHandler, true); 【示例3】使用addEventListener方法注册后台线程的响应事件比较麻烦，我们可以把它修改为下面这种传统的写法：(1)主页文件1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;p id=&quot;support&quot;&gt;你的浏览器不支持 HTML5 Web Workers&lt;/p&gt;&lt;button id=&quot;stopButton&quot; &gt;停止任务&lt;/button&gt;&lt;button id=&quot;helloButton&quot; &gt;发送消息&lt;/button&gt;&lt;script&gt;window.onload = function() &#123; if( typeof (Worker) !== &quot;undefined&quot;) &#123; document.getElementById(&quot;support&quot;).innerHTML = &quot;你的浏览器支持HTML5 Web Workers&quot;; worker = new Worker(&quot;worker.js&quot;); worker.onmessage = function(e) &#123; console.log(e.data); &#125; worker.onerror = function(e) &#123; console.warn(e.message, e); &#125; document.getElementById(&quot;helloButton&quot;).onclick = function() &#123; worker.postMessage(&quot;ok&quot;); &#125; document.getElementById(&quot;stopButton&quot;).onclick = function() &#123; worker.terminate(); &#125;; &#125;&#125;&lt;/script&gt; (2)后台线程文件（worker.js）:123onmessage = function(e) &#123; postMessage(&quot;worker says: &quot; + e.data );&#125; 实战案例后台运算本示例设计一个文本框，允许用户在该文本框输入数字，然后点击计算按钮，在后台计算从1到给定数值的和。虽然对于从1到给定数值的求和计算只需要一个求和公式就可以了，本示例为了展示后台线程的使用方法，采取循环计算的方法。传统方法：12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;function calculate() &#123; var num = parseInt(document.getElementById(&quot;num&quot;).value, 10); var result = 0; for (var i = 0; i &lt;= num; i++) &#123; result += i; &#125; alert(&quot;合计值为&quot; + result + &quot;。&quot;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入数值:&lt;input type=&quot;text&quot; id=&quot;num&quot;&gt;&lt;button onClick=&quot;calculate()&quot;&gt;计算&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 虽然在文本框中输入较小的值时，不会有什么延迟问题。但是当用户在该文本框中输入特别巨大的数字，浏览器运行时间明显延迟。Web Workers方法：(1):主页文件123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;// 创建执行运算的线程var worker = new Worker(&quot;SumCalculate.js&quot;);//接收从线程中传出的计算结果worker.onmessage = function(event) &#123; //消息文本放置在data属性中,可以是任何JavaScript对象. alert(&quot;合计值为&quot; + event.data + &quot;。&quot;);&#125;;function calculate() &#123; var num = parseInt(document.getElementById(&quot;num&quot;).value, 10); //将数值传给线程 worker.postMessage(num);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入数值:&lt;input type=&quot;text&quot; id=&quot;num&quot;&gt;&lt;button onclick=&quot;calculate()&quot;&gt;计算&lt;/button&gt;&lt;/body&gt; (2)后台线程文件（SumCalculate.js）123456789onmessage = function(event) &#123; var num = event.data; var result = 0; for (var i = 0; i &lt;= num; i++) result += i; //向线程创建源送回消息 postMessage(result);&#125; 数值过滤在Web应用中，建议用户将非及时性的任务处理放在后台实现，以减轻前台的压力。本示例设计在页面上随机生成一个整数的数组，然后将该整数数组传入线程，让后台帮助挑选出该数组中可以被3整除的数字，然后显示在页面表格中。(1)在前台脚本中随机生成整数数组，然后送到后台线程挑选出能够被3整除的数字，再传回前台脚本，在前台脚本中根据挑选结果动态表格中的行、列，并将挑选出来的数字显示在表格中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var intArray=new Array(200);//随机数组var intStr=&quot;&quot;;//生成200个随机数for(var i=0;i&lt;200;i++)&#123; intArray[i]=parseInt(Math.random()*200); if(i!=0) intStr+=&quot;;&quot;; //用分号作随机数组的分隔符 intStr+=intArray[i]; &#125;//向后台线程提交随机数组var worker = new Worker(&quot;script.js&quot;);worker.postMessage(intStr);//从线程中取得计算结果worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;) &#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0) &#123;//如果该行不存在，则添加行 tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123;//如果该行存在，则获取该行 tr=document.getElementById(&quot;tr&quot;+j); &#125; //添加列 td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)后台线程文件12345678910111213141516onmessage = function(event) &#123; var data = event.data; var returnStr; //将3的倍数拼接成字符串并返回 var intArray=data.split(&quot;;&quot;); //返回字符串中数字分隔符为; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++) &#123; if(parseInt(intArray[i])%3==0) //能否被3整除 &#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //返回3的倍数拼接成的字符串&#125; 并发处理利用线程可以嵌套的特性，可以在Web应用中实现多个任务并发处理，这样能够提高Web应用程序的执行效率和反应速度。同时通过线程嵌套把一个较大的后台任务切分成几个子线程，在每个子线程中各自完成一部分相对独立的任务。本示例在上一节示例基础上，把主页脚本中随机生成数组的工作放在后台线程中，然后使用另一个子线程在随机数组中挑选可以被3整除的数字。对于数组的传递以及挑选结果的传递均采用JSON对象来进行转换，以验证是否能在线程之间进行Javascript对象的传递工作。(1)在主页面中定义一个线程。设计不向该线程发送数据，在onmessage事件回调函数中进行后期数据处理，并把返回的数据显示在页面中。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var worker = new Worker(&quot;script.js&quot;);worker.postMessage(&quot;&quot;);// 从线程中取得计算结果worker.onmessage = function(event) &#123;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)在后台主线程文件script.js中，随机生成200个整数构成的数组，然后把这个数组提交到子线程，在子线程中可以把能被3整除的数字挑选出来，然后送回主线程。主线程再把挑选结果送回页面进行显示。1234567891011121314onmessage=function(event)&#123; var intArray=new Array(200); for(var i=0;i&lt;200;i++) intArray[i]=parseInt(Math.random()*200); var worker; //创建子线程 worker=new Worker(&quot;worker2.js&quot;); //把随机数组提交给子线程进行挑选工作 worker.postMessage(JSON.stringify(intArray)); worker.onmessage = function(event) &#123; //把挑选结果返回主页面 postMessage(event.data); &#125;&#125; (3)设计子线程的任务处理代码。子线程在接收到的随机数组中挑选能够被3整除的数字，然后拼接成字符串并返回。12345678910111213141516onmessage = function(event) &#123; //还原整数数组 var intArray= JSON.parse(event.data); var returnStr; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++)&#123; if(parseInt(intArray[i])%3==0)&#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //关闭子线程 close(); &#125; 在子线程中向发送源发送回消息后，如果该子线程不再使用的话，应该使用close语句关闭子线程。(4)在页面的主线程回调函数中处理后台线程返回的数据，并将这些数据显示在页面中。12345678910111213141516171819202122worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;)&#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0)&#123; tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123; tr=document.getElementById(&quot;tr&quot;+j); &#125; td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;; 线程通信本示例继续在前面示例的基础上，将创建随机数组的工作也放到一个单独的子线程中，在该线程中创建随机数组，然后将随机数组传递到另一个子线程中进行能够被3整除的数字挑选工作，最后把挑选结果传递回主页面进行显示。设计思路：当主线程嵌套多个子线程时，子线程之间可以通过下面几个步骤进行通信。 先创建发送数据的子线程 执行子线程中的任务，然后把要传递的数据发送给主线程 在主线程接收到子线程传回来的消息时，创建接收数据的子线程，然后把发送数据的子线程中返回的消息传递给接收数据的子线程 执行接收数据子线程中的代码操作步骤：(1)完成主页面的设计。包括HTML结构和CSS样式。在主页脚本中创建一个主线程，定义请求数据为空，在主线程响应事件onmessage回调函数中处理后台返回的处理数据，并把它们显示在页面中。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var worker = new Worker(&quot;script.js&quot;);worker.postMessage(&quot;&quot;);// 从线程中取得计算结果worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;)&#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0)&#123; tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123; tr=document.getElementById(&quot;tr&quot;+j); &#125; //添加列 td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)修改主线程中的代码。在主线程中定义一个子线程（发送数据），让其随机生成200个数字，并返回这个随机数组。在该子线程的回调函数中再定义一个子线程（接受数据），把接受到的随机数组传递给它，并接收该线程过滤后的数组。1234567891011121314151617181920onmessage=function(event)&#123; var worker; //创建发送数据的子线程 worker=new Worker(&quot;worker1.js&quot;); worker.postMessage(&quot;&quot;); worker.onmessage = function(event) &#123; //接收子线程中数据:创建好的随机数组 var data=event.data; //创建接收数据子线程 worker=new Worker(&quot;worker2.js&quot;); //把从发送数据子线程中发回消息传递给接收数据的子线程 worker.postMessage(data); worker.onmessage = function(event) &#123; //获取接收数据子线程中传回数据，本示例中为挑选结果 var data=event.data; //把挑选结果发送回主页面 postMessage(data); &#125; &#125;&#125; (3)在发送数据的子线程中创建一个200个整数构成的随机数组。然后把它转换为字符串并返回，最后关闭该子线程。1234567onmessage = function(event) &#123; var intArray=new Array(200); for(var i=0;i&lt;200;i++) intArray[i]=parseInt(Math.random()*200); postMessage(JSON.stringify(intArray)); close();&#125; (4)在接受数据子线程中对接受到的随机数组中挑选能被3整除的数字，然后拼接成字符串并返回。12345678910111213141516onmessage = function(event) &#123; //还原整数数组 var intArray= JSON.parse(event.data); var returnStr; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++)&#123; if(parseInt(intArray[i])%3==0)&#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //关闭子线程 close(); &#125; Fibonacchi数列运算Fibonacci数列以递归的方式进行定义：F0=0；F1=1；Fn=F(n-1)+F（n-2）（n&gt;2）使用Javascript实现Fibonacci数列运算的一般方法为：123var fibonacci =function(n) &#123; return n &lt;2? n : arguments.callee(n -1) + arguments.callee(n -2);&#125;; 当计算工作量较大的时候，非常有可能造成浏览器罢工，可以使用Web Workers将数列计算过程放入一个后台线程里。(1)主页文件：123456789101112131415161718&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;web worker fibonacci&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; onload =function()&#123; var worker =new Worker(&apos;fibonacci.js&apos;); worker.addEventListener(&apos;message&apos;, function(event) &#123; console.log(event.data); &#125;, false); worker.postMessage(40); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; (2)后台线程文件（fibonacci.js）1234567var fibonacci =function(n) &#123; return n &lt;2? n : arguments.callee(n -1) + arguments.callee(n -2);&#125;;onmessage =function(event) &#123; var n = parseInt(event.data, 10); postMessage(fibonacci(n));&#125;;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>Web Workers</tag>
      </tags>
  </entry>
</search>
