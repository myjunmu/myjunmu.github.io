<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F09%2FjQuery%E4%B8%AD%E7%9A%84ajax%2F</url>
    <content type="text"><![CDATA[jQuery封装了Ajax交互过程，用户仅需要调用jQuery方法，就可以轻松实现客户端与服务器端异步通信，从而帮助开发人员从繁琐的底层技术中解脱出来，专注于业务层开发。 使用GET请求jQuery定义了get()方法，专门负责通过远程HTTP GET请求方式载入信息。该方法具有简单的GET请求功能，以取代负责的$.ajax()方法。基本用法：jQuery.get(url,[data],[callback],[type])get()方法包含4个参数，其中第一个参数为必选项，后面三个参数为可选项。第一个参数表示要请求页面的URL地址。第二个参数表示一个对象结构的名/值对列表。第三个参数表示异步交互成功之后的回调函数。回调函数的参数值为服务器端响应的信息。第四个参数表示服务器端响应信息返回的内容格式，如XML、HTML、Script、JSON和Text，或者_default。【示例1】本例使用get()方法向服务器端test2.php文件发出一个请求，然后在回调函数中读取并显示服务器端响应的消息。1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;jquery/jquery-3.1.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;$(function()&#123; $(&quot;input&quot;).click(function()&#123; //绑定click事件 $.get(&quot;test1.php&quot;,&#123; //向test1.asp文件发出请求 name : &quot;css8&quot;, //发送的请求信息 pass : 123456, age : 1 &#125;,function(data)&#123; //回调函数 alert(data); //显示响应信息 &#125;); &#125;);&#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;jQuery实现的异步请求&quot; /&gt;&lt;/body&gt;&lt;/html&gt; test2.php123456&lt;?php $name=$_GET[&quot;name&quot;]; //$_REQUEST[&quot;name&quot;] $pass=$_GET[&quot;pass&quot;]; $age=$_GET[&quot;age&quot;]; echo &quot;$name,$pass,$age&quot;;?&gt; get()方法能够在请求成功时调用回调函数，如果需要在请求失败时执行函数，则必须使用$.ajax()方法。可以把get()方法的第二个参数所传递的数据，以查询字符串的形式附加在第一个参数URL的后面。123$.get(&quot;test2.php?name=css8&amp;pass=123456&amp;age=1&quot;,function(data)&#123; //回调函数 alert(data); //显示响应信息 &#125;); jQuery还定义了两个专用方法getJSON()和getScript()。这两个方法的功能和用法与get()是完全相同的，不过getJSON()方法能够请求载入JSON数据，getScript()方法能够请求载入Javascript文件。这两个方法与get()方法的区别在于只支持前三个参数，不需要设置第四个参数，即指定响应数据的类型，因为方法本身已经说明了接受的数据类型。 使用POST请求jQuery定义了post()方法，专门负责通过远程HTTP POST请求方法载入信息。该方法具有一个简单的POSt请求功能，以取代复杂的$.ajax()方法。基本用法：jQuery.post(url,[data],[callback],[type])post()方法和get()方法的参数是一样的。【示例1】在本示例中，使用post()方法向服务器端test2.php文件发出一个请求，然后在回调函数中读取并显示服务器端响应的消息。1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script src=&quot;jquery/jquery-3.1.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;$(function()&#123; $(&quot;input&quot;).click(function()&#123; //绑定click事件 $.post(&quot;test2.php&quot;,&#123; //向test1.asp文件发出请求 name : &quot;css8&quot;, //发送的请求信息 pass : 123456, age : 1 &#125;,function(data)&#123; //回调函数 alert(data); //显示响应信息 &#125;); &#125;);&#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;jQuery实现的异步请求&quot; /&gt;&lt;/body&gt;&lt;/html&gt; test2.php123456&lt;?php $name=$_POST[&quot;name&quot;]; $pass=$_POST[&quot;pass&quot;]; $age=$_POST[&quot;age&quot;]; echo &quot;$name,$pass,$age&quot;;?&gt; get()方法和post()方法的用法是完全相同的，数据传递和接受响应的方法都相同，唯一的区别就是请求方式不同。具体选用哪个方法，主要根据客户端所需要传递的数据容量和格式确定，同时应该考虑服务端接受数据的处理方式。不管是get()方法还是post()方法，都是一种简单的请求方式，对于特殊的数据请求和响应处理，应该选择$.ajax()方法，$.ajax()方法的参数比较多且复杂，能够处理各种特殊的异步交互行为。 使用ajax()请求ajax()是jQuery实现Ajax的底层方法，也就是说它是post()和get()方法的基础，使用该方法可以完成HTTP请求加载远程数据。由于aiax()方法的参数比较复杂，在没有特殊需求的情况下，使用get()和post()方法即可。基本用法：jQuery.ajax([settings])ajax()方法只有一个参数，即一个列表结构的对象，包含各配置及回调函数信息。【示例4】加载Javascript文件，可以使用下面的参数选项。12345$.ajax(&#123; type:&quot;GET&quot;, url:&quot;test.js&quot;, dataType:&quot;script&quot;&#125;); 【示例5】如果把客户端的数据传递给服务器端，并获取服务器端的响应信息，可以使用类似于下面的参数选项。12345678$.ajax(&#123; type:&quot;POST&quot;, url:&quot;test.php&quot;, data:&quot;name=zj&amp;pwd=123456&quot;， success：function(data)&#123; alert(data) &#125;&#125;); 【示例6】加载HTML页面，则可以使用下面的参数选项。1234567$.ajax(&#123; url:&quot;test.html&quot;, cache:false; success：function(html)&#123; $(&quot;#box&quot;).append(html); &#125;&#125;); ajax()方法的参数选项列表123456789101112131415161718192021222324async 布尔值，表示请求是否异步处理。默认是 true,即所有请求均为异步请求。如果需要发送同步请求，设置为false即可。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行beforeSend(xhr) 发送请求前运行的函数。如添加自定义 HTTP 头。XMLHttpRequest 对象是唯一的参数。这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。cache 布尔值，表示浏览器是否缓存被请求页面。默认是 true，当dataType为script时，默认为false。complete(xhr,status) 请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。参数： XMLHttpRequest 对象和一个描述请求类型的字符串。contentType 发送数据到服务器时所使用的内容类型。默认是：&quot;application/x-www-form-urlencoded&quot;。context 为所有 AJAX 相关的回调函数规定 &quot;this&quot; 值。data 规定要发送到服务器的数据，将自动转换为请求字符串格式，数据类型可以是字符串或对象。dataFilter(data,type) 给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。dataType 预期的服务器响应的数据类型。如果不指定，jQuery会根据HTTP包含的MIME信息返回responseXML或responseText，并作为回调函数参数传递。可用值：xml、html、json、jsonp、script、texterror(xhr,status,error) 如果请求失败要运行的函数。该函数包括三个参数，XHR对象，错误信息，错误对象。如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 &quot;timeout&quot;, &quot;error&quot;, &quot;notmodified&quot; 和 &quot;parsererror&quot;。global 布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。ifModified 布尔值，仅在服务器数据改变时获取新数据。默认是 false。jsonp 在一个 jsonp 中重写回调函数的名字，这个值用来替代在 &quot;callback=?&quot; 这种 GET 或 POST 请求中 URL 参数里的 &quot;callback&quot; 部分，比如 &#123;jsonp:&apos;onJsonPLoad&apos;&#125; 会导致将 &quot;onJsonPLoad=?&quot; 传给服务器。jsonpCallback 为 jsonp 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让 jQuery 生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存 GET 请求的时候，指定这个回调函数名。password 规定在 HTTP 访问认证请求中使用的密码。processData 布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。scriptCharset 只有当请求时 dataType 为 &quot;jsonp&quot; 或 &quot;script&quot;，并且 type 是 &quot;GET&quot; 才会用于强制修改 charset。success(result,status,xhr) 当请求成功时运行的函数。参数由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串；XHR对象。timeout 设置本地的请求超时时间（以毫秒计）。traditional 布尔值，规定是否使用参数序列化的传统样式。type 规定请求的类型（GET 或 POST），默认为GET。url 规定发送请求的 URL，默认是当前页面。username 规定在 HTTP 访问认证请求中使用的用户名。xhr 用于创建 XMLHttpRequest 对象的函数。 在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载） 跟踪状态jQuery在XMLHttpRequest对象定义的readyState属性基础上，对异步交互中服务器响应状态进行封装，提供了6个响应事件，以便于进一步细化对整个请求响应过程的跟踪。ajaxStart(),ajax请求开始时进行响应ajaxSend()，ajax请求发送时进行响应ajaxComplete()，ajax请求完成时进行响应ajaxSuccess()，ajax请求成功时进行响应ajaxStop()，ajax请求结束时进行响应ajaxError()，ajax请求发生错误时进行响应【示例1】在本示例中，为当前异步请求绑定6个jQuery定义的ajax事件，在浏览器中预览则可以看到浏览器根据请求和响应的过程，逐步提示过程进展。首先，响应的是ajaxStart和ajaxSend事件，然后是ajaxSuccess事件，最后是ajaxComplete和ajaxStop事件。(貌似没看见ajaxStart和ajaxSend事件)123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;test&lt;/title&gt;&lt;script src=&quot;jquery/jquery-1.3.2.js&quot; type=&quot;text/javascript&quot; &gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;$(function()&#123; $(&quot;input&quot;).click(function()&#123; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;test2.php&quot;, data: &quot;name=css8&quot; &#125;); $(&quot;div&quot;).ajaxStart(function()&#123; alert(&quot;Ajax请求开始&quot;); &#125;) $(&quot;div&quot;).ajaxSend(function()&#123; alert(&quot;Ajax请求将要发送&quot;); &#125;) $(&quot;div&quot;).ajaxComplete(function()&#123; alert(&quot;Ajax请求完成&quot;); &#125;) $(&quot;div&quot;).ajaxSuccess(function()&#123; alert(&quot;Ajax请求成功&quot;); &#125;) $(&quot;div&quot;).ajaxStop(function()&#123; alert(&quot;Ajax请求结束&quot;); &#125;) $(&quot;div&quot;).ajaxError(function()&#123; alert(&quot;Ajax请求发生错误&quot;); &#125;) &#125;);&#125;)&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;jQuery实现的异步请求&quot; /&gt;&lt;div&gt;&lt;/div&gt;&lt;/html&gt; 在这些事件中，大部分都会包含几个默认参数。例如ajaxSuccess、ajaxSend、ajaxComplete都包含event、request和settings，其中event表示事件类型，request表示请求信息、settings表示设置的选项信息。ajaxError事件还包含4个默认参数，event、XHR、ajaxOptions和thrownError，最后一个参数表示抛出的错误。 载入文件遵循ajax异步交互的设计原则，jQuery定义了可以加载网页文档的方法load()。该方法与getScript()方法的功能相似，都是加载外部文件，但是他们的用法完全不同。load()方法能够把加载的网页文件附加到指定的网页标签。 新建一个简单网页。1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table width=&quot;100%&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;pass&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;zhu&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;zhang&lt;/td&gt; &lt;td&gt;456&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;wang&lt;/td&gt; &lt;td&gt;789&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 在另一网页中输入下面的脚本。1234567891011121314151617181920&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;test&lt;/title&gt;&lt;script src=&quot;jquery/jquery-1.11.0.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;$(function()&#123; $(&quot;input&quot;).click(function()&#123; $(&quot;div&quot;).load(&quot;table.html&quot;); &#125;);&#125;)&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt; &lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;jQuery实现的异步请求&quot; /&gt;&lt;div&gt;&lt;/div&gt;&lt;/html&gt; 当单击按钮时，会把请求文件中的数据表格加载到当前页面的div元素中。使用ajax方法可以替换load()方法。123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;test&lt;/title&gt;&lt;script src=&quot;jquery/jquery-1.11.0.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;$(function()&#123; $(&quot;input&quot;).click(function()&#123; var str = ($.ajax(&#123; //调用ajax()方法，返回XMLHttpRequest对象 url : &quot;table.html&quot;, //载入的URl async: false //禁止异步载入 &#125;)).responseText; //获取XMLHttpRequest对象中包含的服务器响应信息 $(&quot;div&quot;).html(str); //把载入的网页内容附加到div元素内 &#125;);&#125;)&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt; &lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;jQuery实现的异步请求&quot; /&gt;&lt;div&gt;&lt;/div&gt;&lt;/html&gt; 设置ajax选项对于频繁与服务器进行交互的页面来说，每一次交互都要设置很多的选项，这种操作是很繁琐的。jQuery定义了ajaxSetup()方法，该方法可以预设异步交互中通用选项，从而减轻频繁设置选项的繁琐。ajaxSetup()方法的参数仅包含一个参数选项的列表对象，这与ajax()方法的参数选项设置是相同的。在该方法中设置的选项，可以实现全局共享，从而在具体交互中只需要设置个性化参数即可。【示例1】本示例中，先使用$.ajaxSetup()方法把本页面异步交互的公共选项进行预设，包括请求的服务器端文件。禁止触发全局ajax事件、请求方式、响应数据类型和响应成功后的回调函数。这样在不同按钮上绑定异步请求时，只需要设置发送请求的消息即可。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;test&lt;/title&gt; &lt;script src=&quot;jquery/jquery-1.11.0.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;$(function()&#123; $.ajaxSetup(&#123; //预设公共选项 url: &quot;test.php&quot;, //请求的URL global: false, //禁止触发全局Ajax事件 type: &quot;POST&quot;, //请求方式 dataType: &quot;text&quot;, //响应数据的类型 success : function(data)&#123; //响应成功之后的回调函数 alert(data); &#125; &#125;); $(&quot;input&quot;).eq(0).click(function()&#123; //为按钮1绑定异步请求 $.ajax(&#123; data : &quot;name=zhu&quot; //发送请求的信息 &#125;); &#125;); $(&quot;input&quot;).eq(1).click(function()&#123; //为按钮2绑定异步请求 $.ajax(&#123; data : &quot;name=wang&quot; //发送请求的信息 &#125;); &#125;); $(&quot;input&quot;).eq(2).click(function()&#123; //为按钮3绑定异步请求 $.ajax(&#123; data : &quot;name=zhang&quot; //发送请求的信息 &#125;); &#125;); &#125;)&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; value=&quot;异步请求1&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;异步请求2&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;异步请求3&quot; /&gt;&lt;div&gt;&lt;/div&gt;&lt;/html&gt; 服务器端文件1234&lt;?php $name=$_POST[&quot;name&quot;]; echo &quot;$name&quot;;?&gt; 序列化字符串在ajax异步通信过程中，客户端所发送的请求字符串必须是由&amp;字符连接起来的多个名/值对。而当使用表单发送数据时，发送请求的信息并非按照此格式进行传递。用户需要手工编写发送信息的字符串格式，为了减轻开发人员不必要的劳动量，特意定义了serialize()方法，该方法可以帮助用户按名/值对的字符串格式进行快速的整理，并返回合法的请求字符串。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;test&lt;/title&gt;&lt;script src=&quot;jquery/jquery-1.11.0.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;$(function()&#123; $(&quot;#submit&quot;).click(function()&#123; $(&quot;p&quot;).html($(&quot;form&quot;).serialize()); //获取和格式化表单的请求字符串信息，并显示出来 return false; //禁止提交表单 &#125;);&#125;)&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;&lt;br /&gt; 性别： &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;man&quot; checked=&quot;checked&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;woman&quot; /&gt;女&lt;br /&gt; 年级： &lt;select name=&quot;grade&quot;&gt; &lt;option value=&quot;1&quot;&gt;一&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;二&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;三&lt;/option&gt; &lt;/select&gt;&lt;br /&gt; 科目： &lt;select name=&quot;subject&quot; size=&quot;6&quot; multiple=&quot;multiple&quot;&gt; &lt;option value=&quot;yuwen&quot;&gt;语文&lt;/option&gt; &lt;option value=&quot;shuxue&quot;&gt;数学&lt;/option&gt; &lt;option value=&quot;waiyu&quot;&gt;外语&lt;/option&gt; &lt;option value=&quot;wuli&quot;&gt;物理&lt;/option&gt; &lt;option value=&quot;huaxue&quot;&gt;化学&lt;/option&gt; &lt;option value=&quot;jisuanji&quot;&gt;计算机&lt;/option&gt; &lt;/select&gt;&lt;br /&gt; 兴趣： &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;yundong&quot; /&gt;运动 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;wenyi&quot; /&gt;文艺 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;yinyue&quot; /&gt;音乐 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;meishu&quot; /&gt;美术 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;youxi&quot; /&gt;游戏&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot; /&gt; &lt;/form&gt;&lt;p&gt;&lt;/p&gt;&lt;/html&gt; 除了serialize()方法外，jQuery对象还定义了aerialzieArray()方法，此方法能够返回指定表单域值的JSON结构对象。此方法返回的是JSON对象，而非JSON字符串。JSON对象是有一个对象数组组成的，其中每个对象包含一个或两个名值对：name参数和value参数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;test&lt;/title&gt;&lt;script src=&quot;jquery/jquery-1.11.0.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;$(function()&#123; $(&quot;#submit&quot;).click(function()&#123; //var array = $(&quot;form&quot;).serializeArray(); //注意，不能够直接在form元素上调用该方法 var array = $(&quot;input, select&quot;).serializeArray(); //在表单域对象上调用serializeArray()方法，//返回包含传递表单域和值的JSON对象 var str = &quot;[ &lt;br /&gt;&quot; for(var i = 0; i&lt;array.length; i++)&#123; //遍历数组格式的JSON对象 str += &quot; &#123;&quot; for(var name in array[i])&#123; //遍历数组元素对象 str += name + &quot;:&quot; + array[i][name] + &quot;,&quot; //组合为JSON格式字符串 &#125; str = str.substring(0,str.length-1); //清除最后一个字符，即最后一个逗号 str += &quot;&#125;,&lt;br /&gt;&quot;; &#125; str = str.substring(0,str.length-7); //清除最后7个字符，即最后一个空行 str += &quot;&lt;br /&gt;]&quot;; $(&quot;p&quot;).html(str); //显示返回的JSON结构字符串 return false; &#125;);&#125;)&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;&lt;/head&gt; &lt;body&gt;&lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;&lt;br /&gt; 性别： &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;man&quot; checked=&quot;checked&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;men&quot; /&gt;女&lt;br /&gt; 年级： &lt;select name=&quot;grade&quot;&gt; &lt;option value=&quot;1&quot;&gt;一&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;二&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;三&lt;/option&gt; &lt;/select&gt;&lt;br /&gt; 科目： &lt;select name=&quot;kemu&quot; size=&quot;6&quot; multiple=&quot;multiple&quot;&gt; &lt;option value=&quot;yuwen&quot;&gt;语文&lt;/option&gt; &lt;option value=&quot;shuxue&quot;&gt;数学&lt;/option&gt; &lt;option value=&quot;waiyu&quot;&gt;外语&lt;/option&gt; &lt;option value=&quot;wuli&quot;&gt;物理&lt;/option&gt; &lt;option value=&quot;huaxue&quot;&gt;化学&lt;/option&gt; &lt;option value=&quot;jisuanji&quot;&gt;计算机&lt;/option&gt; &lt;/select&gt;&lt;br /&gt; 兴趣： &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;yundong&quot; /&gt;运动 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;wenyi&quot; /&gt;文艺 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;yinyue&quot; /&gt;音乐 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;meishu&quot; /&gt;美术 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; value=&quot;youxi&quot; /&gt;游戏&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot; /&gt; &lt;/form&gt;&lt;p&gt;&lt;/p&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F09%2F%E4%BD%BF%E7%94%A8ajax%2F</url>
    <content type="text"><![CDATA[Ajax(Asynchronous Javascript and XML，异步Javascript 和 XML)是利用Javascript脚本与XML数据实现客户端与服务器端进行异步通信的一种方法。Ajax主要由下面几部分组成： 基于标准的HTML结构和CSS样式 通过DOM实现动态显示和交互 通过XML进行数据交换和处理 使用XMLHttpRequest插件进行异步通信 使用Javascript实现逻辑控制，以遍整合以上所有技术AJAX基础HTTP头部信息HTTP(HyperText Transfer Protocol，超文本传输协议)是一种应用层协议，负责超文本的传输，如文本、图像、多媒体等。HTTP由两部分组成：请求(Request)和响应(Response)。每个HTTP请求和响应都会带有响应的头部信息。XHR对象也提供了操作这两种头部信息的方法。默认情况下，在发送XHR请求的同时，还会发送下面这些头部信息：Request Headers:Accept:浏览器能够处理的内容类型；Accept-Charset：浏览器能够处理的字符集；Accept-Encoding：浏览器能够处理的压缩编码；Accept-Language：浏览器当前设置的语言；Connection：浏览器与服务器之间的连接类型；Cookies：当前页面设置的任何Cookie；Host：发出请求的页面；Referer：发出请求的页面URI；User-Agent：浏览器的用户代理字符串使用AJAX定义XMLHttpRequest对象XMLHttpRequest对象提供了与服务器端进行通信的协议，浏览器可以通过XMLHttpRequest对象向服务器发送请求，并使用Javascript处理响应信息，然后在DOM中显示数据。XMLHTTPRequest提供的方法和属性： onreadystatechange，指定当readyState属性改变时的事件处理句柄 readyState：返回当前请求的状态 status：返回当前请求的状态码 statusText：返回当前请求的响应行状态 responseBody：返回正文信息 responseStream：以文本流的形式返回响应信息 responseText：以字符串的形式返回响应信息 responseXML：以XML数据的形式返回响应信息 open()，创建一个新的HTTP请求，并指定此请求的方法、URL、以及验证信息 send(),发送请求到HTTp服务器并接受回应 getAllResponseHeaders(),获取响应的所有HTTP头部信息 getResponseHeader()，从响应信息中获取指定的HTTP头部信息 setRequestHeader()，单独指定请求的某个HTTP头部信息。 abort()，取消当前请求。使用XMLHttpRequest对象实现异步通信一般需要以下几个步骤。 定义XMLHttpRequest实例对象。 调用XMLHttpRequest对象的open()方法打开服务器端的URL地址。 注册onreadystatechange事件处理函数，准备接受响应数据，并进行处理。 调用XMLHttpRequest对象的send()方法发送请求。【示例1】现代标准浏览器都支持XMLHttpRequest对象，在IE早期版本浏览器中主要使用ActiveXObject()组件的方式创建XMLHttpRequest对象，为了兼容不同浏览器，可以使用下面的代码。1234567var xmlHttp;if (window.XMLHttpRequest)&#123; xmlHttp = new XMLHttpRequest();&#125;else&#123; xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125; 【示例2】下面的函数采用一种更高效的工厂模式把定义XMLHttpRequest对象功能进行封装，然后只要调用createXMLHTTPObject()方法就可以返回一个XMLHttpRequest对象。12345678910111213141516171819202122232425262728function createXMLHTTPObject()&#123; var xmlHttp; if (window.XMLHttpRequest)&#123; xmlHttp = new XMLHttpRequest(); &#125;else&#123; xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;; return xmlHttp;&#125;``` #### 建立XMLHttpRequest连接创建XMLHttpRequest对象之后，就可以使用该对象的open()方法建立一个HTTP请求。open()方法的基本用法：`XMLHttpRequest.open(bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword);`该方法包含5个参数，其中前面两个是必须的。* bstrMethod：HTTP方法字符串，如GET、POST，不区分大小写。* bstrUrl：请求的URL地址字符串，可以为绝对地址或相对地址。* varAsync：布尔值，可选参数，指定请求是否为异步方式，默认为true。如果为true，当状态改变时会调用onreadystatechange属性指定的回调函数。（不推荐使用false）* bstrUser：可选参数，如果服务器需要验证，该参数指定用户名，如果位指定，当服务器需要验证时，会跳出验证窗口。* bstrPassword：可选参数，验证信息中的密码部分，如果用户名为空，则此值会被忽略。建立连接之后，就可以使用send()方法发送请求到服务器端，并接收服务器的响应。send()方法的基本语法：`XMLHttpRequest.send(varBody);`参数varBody表示将通过该请求发送的数据，如果不传递信息，可以设置参数为null。使用XMLHttpRequest对象的responseBody、responseStream、responseText或responseXML属性可以接受响应数据。#### 发送get请求发送get请求时，只需要将包含查询字符串的URL传入open()方法，设置第一个参数值为“get”即可。服务器就能在URL尾部的查询字符串中接收用户传递过来的信息。使用get请求比较简单，也比较方便，它适合传递一些简单的信息，不易传输大容量或加密数据。【示例】本例演示如果用get方式实现Ajax请求。1.新建一个01.html的页面。 &lt;!DOCTYPE html&gt; AJAX var btn=document.getElementById(“btn”); btn.onclick=function(){ var xmlHttp=createXMLHTTPObject(); xmlHttp.open(“GET”,”01.php?user=zj&amp;pwd=123456”); xmlHttp.send(null); xmlHttp.onreadystatechange=function(){ if(xmlHttp.readyState==4 &amp;&amp; xmlHttp.status==200 ){ console.log(xmlHttp.responseText); } } }; }; function createXMLHTTPObject(){ var xmlHttp; if (window.XMLHttpRequest){ xmlHttp = new XMLHttpRequest(); }else{ xmlHttp = new ActiveXObject(“Microsoft.XMLHTTP”); }; return xmlHttp; } 12.新建一个01.php的页面&lt;?php $user=$_GET[‘user’]; $pwd=$_GET[‘pwd’]; echo “$user : $pwd”;?&gt;12345673.将01.html和01.php文件放在XAMPP的htdocs目录下，然后通过浏览器进行访问。不要直接点击文件进行访问。#### 发送post请求post请求支持发送任意格式、任意长度的数据，一般多用于表单提交。与get发送的数据格式相似，post发送的数据也必须进行解码，并用连字符进行分隔，格式如下：`send(&quot;name1=value1&amp;name2=value2...&quot;)`这些参数在发送post请求时，不会被附加到URL的末尾，而是作为send()方法的参数进行传递。【示例】本例演示如果用post方式实现Ajax请求。1.新建一个02.html的页面。&lt;!DOCTYPE html&gt; AJAX var btn=document.getElementById(“btn”); btn.onclick=function(){ var xmlHttp=createXMLHTTPObject(); xmlHttp.open(“GET”,”01.php”); xmlHttp.setRequestHeader(‘Content-type’,”application/x-www-form-urlencoded”); xmlHttp.send(“user=zj&amp;pwd=123456”); xmlHttp.onreadystatechange=function(){ if(xmlHttp.readyState==4 &amp;&amp; xmlHttp.status==200 ){ console.log(xmlHttp.responseText); } } }; }; function createXMLHTTPObject(){ var xmlHttp; if (window.XMLHttpRequest){ xmlHttp = new XMLHttpRequest(); }else{ xmlHttp = new ActiveXObject(“Microsoft.XMLHTTP”); }; return xmlHttp; } 12.新建一个02.php的页面&lt;?php $user=$_POST[‘user’]; $pwd=$_POST[‘pwd’]; echo “$user : $pwd”;?&gt;1234567891011121314151617181920212223242526272829303132333435363738393.将02.html和02.php文件放在XAMPP的htdocs目录下，然后通过浏览器进行访问。不要直接点击文件进行访问。比较GET和POST方法的区别：1. 使用POST方法发送的数据直接写在send方法的参数里面；而使用GET方法发送的数据需要写在open(）方法的URL参数的后面，并加上一个&quot;?&quot;,同时send()方法接受参数null；2. 使用POST方法在使用send()之前，需要设置请求头信息，即`xmlHttp.setRequestHeader(&apos;Content-type&apos;,&quot;application/x-www-form-urlencoded&quot;);`3. 用于发送POST请求的数据类型通常是application/x-www-form-urlencoded，这意味着也可以是text/xml或application/xml类型给服务器直接发送XML数据，甚至是application/json类型发送Javascript对象#### 跟踪状态XMLHttpRequest对象通过readyState属性实时跟踪异步交互状态。一旦该属性发生变化时，就触发readystatschange事件，调用该事件绑定的回调函数。readyState属性包括5个值：* 0，服务器端未初始化。表示对象已经建立，但是尚未初始化，尚未调用open()方法；* 1，服务器端正在连接。表示对象已经建立，尚未调用send方法；* 2，服务器端正在接收请求数据，表示send()方法已经调用，但是当前的状态以及HTTP头未知；* 3，服务器端正在响应，表示已经传输部分数据，因为响应及HTTP头不全，这时通过responseBody和responseText获取部分数据会出现错误；* 4，服务器端响应完毕，表示数据传输完成，此时可以通过responseBody和responseText获得完整的数据。如果readyState属性值为4.则说明响应完毕，那么就可以安全读取返回数据。另外，还需要检测HTTP状态码，只有当HTTP状态码为200时，才表示HTTP响应顺利完成。在XMLHttpRequest对象中可以借助status属性获取当前的HTTP状态码。如果readyState属性值为4，且status属性值为200，那么说明HTTP请求和响应过程顺利完成。注：HTTP状态码由三位数字组成，第一个数字定义了响应的类别。1xx：指示信息。表示请求已接受，继续处理；2xx：成功。表示请求已被成功接收、理解；3xx：重定向。要完成请求需要更进一步的操作；4XX：客户端错误。请求有语法错误，或者请求无法实现；5xx：服务器错误。常见的HTTP状态码：100 Continue 客户端应当继续发送请求，这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回302 Move temporarily 请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求304 Not Modified如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码305 Use Proxy 被请求的资源必须通过指定的代理才能被访问400 Bad Request 客户端请求有语法错误，不能被服务器所理解401 Unauthorized 当前请求需要用户验证403 Forbidden 服务器已经理解请求，但是拒绝执行它404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源500 Internal Server Error 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理503 Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复504 Gateway Timeout 请求超时505 HTTP Version Not Supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本#### 中止请求使用abort()方法可以中止正在进行的异步请求。在使用abort()方法前，应先清除onreadystatechange事件处理函数，因为IE和Mozilla在请求中止后也会激活这个事件处理函数，如果给onreadystatechange属性设置为null，则IE会引发异常，所以可以给它设置一个空函数。xmlhttp.onreadystatechange=function(){};xmlhttp.abort();1234#### 获取XML数据XMLHTTPRequest对象通过responseText、responseBody、responseStream或responseXML属性获取响应信息。在实际应用中，一般将格式设置为XML、HTML、JSON或其他纯文本格式。XML是使用最广泛的数据格式。因为XML文档可以被很多编程语言所支持，而且开发人员可以使用比较熟悉的DOM模型来解析数据，其缺点在于服务器的响应和解析XML数据的脚本可能变得相当冗长，查找数据不得不遍历每个节点。&lt;!doctype html&gt; function createXMLHTTPObject(){ var xmlHttp; if (window.XMLHttpRequest){ xmlHttp = new XMLHttpRequest(); }else{ xmlHttp = new ActiveXObject(“Microsoft.XMLHTTP”); }; return xmlHttp;} var x = createXMLHTTPObject();var url = “XML_server.xml”;x.open(“GET”, url, true);x.onreadystatechange = function (){ if ( x.readyState == 4 &amp;&amp; x.status == 200 ) { var info = x.responseXML; alert(info.getElementsByTagName(&quot;the&quot;)[0].firstChild.nodeValue); } }x.send(null); 1服务器文件 &lt;?xml version=”1.0” encoding=”gb2312”?&gt; XML123在上面的代码中，使用XML DOM对象提供的getElementByTagName()方法获取the节点，然后再定位第一个the节点的子节点内容。#### 获取HTML文本设计响应信息是HTML字符串是一种常见的方法，这样在客户端就可以直接使用innerHTML属性把获取的字符串插入到网页中。 function createXMLHTTPObject(){ var xmlHttp; if (window.XMLHttpRequest){ xmlHttp = new XMLHttpRequest(); }else{ xmlHttp = new ActiveXObject(“Microsoft.XMLHTTP”); }; return xmlHttp;} var x = createXMLHTTPObject();var url = “HTML_server.html”;x.open(“GET”, url, true);x.onreadystatechange = function (){ if ( x.readyState == 4 &amp;&amp; x.status == 200 ) { var o = document.getElementById(“grid”); o.innerHTML = x.responseText; }}x.send(null);1服务器文件 RegExp.exec() 通用的匹配模式 RegExp.test() 检测一个字符串是否匹配某个模式 1234在某些情况下，HTML字符串可能为客户端解析响应信息节省了一些Javascript脚本，但是也带来了一些问题。* 响应信息中包含大量无用的字符，响应数据会变得臃肿。* 响应信息中包含的结构无法有效利用，并且结构和信息混合，不符合标准设计原则#### 获取Javascript脚本 function createXMLHTTPObject(){ var xmlHttp; if (window.XMLHttpRequest){ xmlHttp = new XMLHttpRequest(); }else{ xmlHttp = new ActiveXObject(“Microsoft.XMLHTTP”); }; return xmlHttp;}var x = createXMLHTTPObject();var url = “code_server.js”;x.open(“GET”, url, true);x.onreadystatechange = function (){ if ( x.readyState == 4 &amp;&amp; x.status == 200 ) { var info = x.responseText; var o = eval(“(“+info+”)”+”()”); alert(o); }}x.send(null);1服务器文件function(){ var d = new Date() return d.toString();}12在转换时应在字符串前后附加两个小括号，一个是包含函数结构体的，一个是表示调用函数的。#### 获取JSON数据 function createXMLHTTPObject(){ var xmlHttp; if (window.XMLHttpRequest){ xmlHttp = new XMLHttpRequest(); }else{ xmlHttp = new ActiveXObject(“Microsoft.XMLHTTP”); }; return xmlHttp;}var x = createXMLHTTPObject();var url = “JSON_server.json”;x.open(“GET”, url, true);x.onreadystatechange = function (){ if ( x.readyState == 4 &amp;&amp; x.status == 200 ) { var info = x.responseText; var o=JSON.parse(info); alert(info); alert(o.name); }}x.send(null);1服务器文件 { “name”:”css8”, “pass”:”123456”}12#### 获取纯文本对于简短的信息，有必要使用纯文本格式进行响应。但是纯文本信息在响应时很容易丢失，且没有办法检测信息的完整性。 &lt;!doctype html&gt; function createXMLHTTPObject(){ var xmlHttp; if (window.XMLHttpRequest){ xmlHttp = new XMLHttpRequest(); }else{ xmlHttp = new ActiveXObject(“Microsoft.XMLHTTP”); }; return xmlHttp;}var x = createXMLHTTPObject();var url = “Text_server.txt”;x.open(“GET”, url, true);x.onreadystatechange = function (){ if ( x.readyState == 4 &amp;&amp; x.status == 200 ) { var info = x.responseText; if(info == &quot;true&quot;) alert(&quot;文本信息传输完整&quot;); else alert(&quot;文本信息可能存在丢失&quot;); } }x.send(null);1服务器文件 true`]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2018%2F02%2F02%2FCSS3%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[根据所获取页面元素的不同，可以把CSS选择器分为五大类，即基本选择器、组合选择器、伪类选择器、伪元素选择器和属性选择器。 基础选择器 通用元素选择器，匹配任何元素 E 标签选择器，匹配所有使用E标签的元素 .info/E.info Class选择器，匹配所有class属性包含info的元素/匹配所有class属性包含info的E元素 #info/E#info ID选择器，匹配所有id属性为info的元素/匹配所有id属性为info的E元素组合选择器 E,F 多元素选择器，同时匹配E元素或F元素，E和F之间用逗号隔开 E F 后代选择器，匹配所有属于E元素后代的F元素，E和F之间用空格隔开 E&gt;F 子元素选择器，匹配所有E元素的子元素F E+F 毗邻元素选择器，匹配所有紧跟E元素之后的同级元素F E~F 同级元素选择器，匹配任何在E元素之后的同级元素F属性选择器 [att]/E[att] 匹配所有具有att属性的元素/匹配所有具有att属性的E元素，不考虑属性的值 [att=val]/E[att=val],匹配所有att属性等于“val”的元素/匹配所有att属性等于“val”的E元素。属性值只有一个。 [att~=val]/E[att=~val]，匹配所有att属性具有多个空格分开的值，其中一个值等于“val”的元素/匹配所有att属性具有多个空格分开的值，其中一个值等于“val”的元素注意，[att=val]只会匹配到att属性只有一个值，且这个值就等于“val”的元素；而[att~=val]会匹配到att属性可以有多个值，也可以是一个值，但只要其中有一个值是“val”的元素。 [att|=val]/E[att|=val],匹配所有att属性具有多个空格分开的值，并且其中一个值是以val开头并用连接符”-“分隔的元素/配所有att属性具有多个空格分开的值，并且其中一个值是以val开头并用连接符”-“分隔的E元素/。如果值仅为val，也将被选择。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; border:1px solid #ddd; width:200px; height:200px; &#125; [class|=&quot;we&quot;]&#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;as we-te&quot;&gt;&lt;/div&gt; &lt;div class=&quot;we-te as&quot;&gt;&lt;/div&gt; &lt;div class=&quot;we&quot;&gt;&lt;/div&gt; &lt;div class=&apos;we sa&apos;&gt;&lt;/div&gt; &lt;div class=&apos;sa we&apos;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 只有第二个和第三个元素匹配，特别注意第一种情况匹配不到。 [att^=val]/E[att^=val],匹配所有att属性具有多个值，且其中一个值是以val开头的元素/匹配所有att属性具有多个值，且其中一个值是以val开头的E元素。如果值是val，也会被选择。注意：[att|=val]匹配的元素是val开头，且后面接一个连字符，而[att^=val]匹配的元素是val开头，后面不一定接什么其他的内容；[att|=val]匹配att属性值为val的元素时，仅能够包含val这一个值，但是[att|=val]匹配att属性值为val的元素时，除了val这一个值外，还能够包含其它的值。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; border:1px solid #ddd; width:200px; height:200px; &#125; [class^=&quot;we&quot;]&#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;as we-te&quot;&gt;&lt;/div&gt; &lt;div class=&quot;we-te as&quot;&gt;&lt;/div&gt; &lt;div class=&quot;we&quot;&gt;&lt;/div&gt; &lt;div class=&apos;we sa&apos;&gt;&lt;/div&gt; &lt;div class=&apos;sa we&apos;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 和上面的一个示例相比，这个示例的第四个div也能够匹配得到。 [att$=val]/E[att$=val]，匹配所有att属性是以val结尾的元素/匹配所有att属性是以val结尾的E元素。如果值为val，也将被选择。12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; border:1px solid #ddd; width:200px; height:200px; &#125; [class$=&quot;te&quot;]&#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;as we-te&quot;&gt;&lt;/div&gt; &lt;div class=&quot;we-te&quot;&gt;&lt;/div&gt; &lt;div class=&quot;we-te as&quot;&gt;&lt;/div&gt; &lt;div class=&quot;te&quot;&gt;&lt;/div&gt; &lt;div class=&apos;te sa&apos;&gt;&lt;/div&gt; &lt;div class=&apos;sa te&apos;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 只有第三个和第五个div元素匹配不到。 [att=val]/E[att=val]，匹配所有att属性中包含val的元素/匹配所有att属性中包含val的E元素。att属性的值可以是多个，当值仅为val时也能匹配。12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; border:1px solid #ddd; width:200px; height:200px; &#125; [class*=&quot;te&quot;]&#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;as we-te&quot;&gt;&lt;/div&gt; &lt;div class=&quot;we-te&quot;&gt;&lt;/div&gt; &lt;div class=&quot;we-te as&quot;&gt;&lt;/div&gt; &lt;div class=&quot;te&quot;&gt;&lt;/div&gt; &lt;div class=&apos;te sa&apos;&gt;&lt;/div&gt; &lt;div class=&apos;sa te&apos;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 所有div元素都能匹配得到。 伪类选择器(冒号前后不要加空格) E:first-child 匹配父元素的第一个E元素，E:last-child 匹配父元素的最后一个E元素即先找到E元素，再判断E元素是否是其父元素下的第一个或者最后一个元素。 E:link 匹配所有未被单击的链接， E:visited 匹配所有已被单击的链接，E:active 匹配所有鼠标已被按下，但还没有释放的元素， E:hover 匹配所有鼠标悬停在其上面的元素。这四种伪类选择器通常用于a标签。为了保证正常的效果，建议按照link、visited、hover和active的顺序进行书写。12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; a:link&#123; color:black; &#125; a:visited&#123; color:yellow; &#125; a:hover&#123; color:blue; &#125; a:active&#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;#1&quot;&gt;nihao&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;#2&quot;&gt;wohao&lt;/a&gt;&lt;br/&gt; &lt;a href=&quot;#3&quot;&gt;tahao&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 测试的时候务必注意，保证a标签连接指向不同的地址，不然很可能出现单击其中一个a标签，其它a标签的visited样式也发生了改变。 E:focus 匹配获得当前焦点的E元素 E:lang(c) 匹配所有lang属性等于c的E元素，只能等于c，不能包含其它的；并且c不能加引号。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; border:1px solid #ddd; width:200px; height:200px; &#125; div:lang(fr)&#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;as we-te&quot; lang=&quot;en fr&quot;&gt;&lt;/div&gt; &lt;div class=&quot;we-te&quot; lang=&quot;fr&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; E:root 匹配文档的根元素，对于HTML文档而言，就是html元素。实际上就是html{}。 E:nth-child(),选择某个元素的一个或多个特定的子元素,从1开始 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 匹配第一个li元素，li：first-child或者li:nth-child(1)，注意不是ul：first-child或者ul:nth-child(1); 撇皮最后一个li元素，li：last-child或者li:nth-child(5)，注意不是ul：last-child或者ul:nth-child(5)； li:nth-child(0)不匹配任何li元素，li:nth-child(n)，匹配所有的li元素，只能用n，不能用其它字母 li:nth-child(2n)，匹配第二个和第四个li元素，也可以用li:nth-child(even) li:nth-child(2n+1),匹配第一个、第三个和第五个li元素，也可以用li:nth-child(2n-1)或者li:nth-child(odd)12345li：nth-child(n)的实现过程：当n=0时，未选择任何元素；当n=1时，选择第一个li；当n=2时，选择第二个li；依次类推，其它出现n 的情况类似这种推导 E：nth-last-child，和E:nth-child()相似，但是它是从最后一个元素开始计算来选择特定元素。当参数为n相关的表达式时，推导过程和上面的示例一样 E：empty 用来选择没有任何内容的元素。这里的内容指的是一点内容都没有，哪怕是一个空格。 E：checked 匹配表单中被选中的radio或checkbox元素 E：diasbled 匹配表单中被禁用的元素 E：enabled 匹配表单中被激活的元素 E：target 匹配所有的E元素，且匹配元素被相关URL指向。当存在URL指向该匹配元素并触发时，样式生效。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;title&gt;目标伪类选择符&lt;/title&gt;&lt;style&gt;.test .hd&#123;padding:10px 0;&#125;.test .nav&#123;position:fixed;right:10px;left: 540px;&#125;.test .nav a&#123;display:block;margin: 10px 0;&#125;.test .bd .panel&#123;width:500px;margin-top:5px;border:1px solid #ddd;&#125;.test .bd h2&#123;border-bottom:1px solid #ddd;&#125;.test .bd .panel:target&#123;border-color:#f60;&#125;.test .bd .panel:target h2&#123;border-color:#f60;&#125;h2,p&#123;margin:0;padding:10px;font-size:16px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;test&quot;&gt; &lt;div class=&quot;hd nav&quot;&gt; &lt;a href=&quot;#panel1&quot;&gt;前往区块1&lt;/a&gt; &lt;a href=&quot;#panel2&quot;&gt;前往区块2&lt;/a&gt; &lt;a href=&quot;#panel3&quot;&gt;前往区块3&lt;/a&gt; &lt;a href=&quot;#panel4&quot;&gt;前往区块4&lt;/a&gt; &lt;a href=&quot;#panel5&quot;&gt;前往区块5&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;div id=&quot;panel1&quot; class=&quot;panel&quot;&gt; &lt;h2&gt;区块1&lt;/h2&gt; &lt;div&gt;&lt;p&gt;区块1内容&lt;/p&gt;&lt;p&gt;区块1内容&lt;/p&gt;&lt;p&gt;区块1内容&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;panel2&quot; class=&quot;panel&quot;&gt; &lt;h2&gt;区块2&lt;/h2&gt; &lt;div&gt;&lt;p&gt;区块2内容&lt;/p&gt;&lt;p&gt;区块2内容&lt;/p&gt;&lt;p&gt;区块2内容&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;panel3&quot; class=&quot;panel&quot;&gt; &lt;h2&gt;区块3&lt;/h2&gt; &lt;div&gt;&lt;p&gt;区块3内容&lt;/p&gt;&lt;p&gt;区块3内容&lt;/p&gt;&lt;p&gt;区块3内容&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;panel4&quot; class=&quot;panel&quot;&gt; &lt;h2&gt;区块4&lt;/h2&gt; &lt;div&gt;&lt;p&gt;区块4内容&lt;/p&gt;&lt;p&gt;区块4内容&lt;/p&gt;&lt;p&gt;区块4内容&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;panel5&quot; class=&quot;panel&quot;&gt; &lt;h2&gt;区块5&lt;/h2&gt; &lt;div&gt;&lt;p&gt;区块5内容&lt;/p&gt;&lt;p&gt;区块5内容&lt;/p&gt;&lt;p&gt;区块5内容&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; E：not(s) 匹配不符合当前选择器的E元素 123.demo li:not(:last-child) &#123; border-bottom: 1px solid #ddd;&#125; 给该列表中除最后一项外的所有列表项加一条底边线 E:only-child() 匹配的E元素是其父元素下唯一的子元素 E:only-of-type() 匹配到的E元素的父元素下有多个子元素，但是子元素只有一个E元素 E:nth-last-of-type(n) 匹配到的元素E是其父元素中的倒数第n个子元素(仅从其最后一个子元素是E元素时开始算起)1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p&gt;0&lt;/p&gt; &lt;span&gt;1&lt;/span&gt; &lt;p&gt;2&lt;/p&gt; &lt;span&gt;3&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用p:nth-last-child(2)匹配到的是&lt;p>2&lt;/p>，使用p:nth-last-of-type(2)匹配到的是&lt;p>0&lt;/p> E:first-of-type 匹配到的元素E是其父元素中的第一个为E的子元素123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p&gt;0&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用p:first-of-type匹配到的是&lt;p>0&lt;/p>和&lt;p>3&lt;/p>这两个元素，而使用p：first-child匹配到的仅仅是&lt;p>0&lt;/p>这一个元素。 E:last-of-type 匹配到的元素E是其父元素中的最后一个为E的子元素12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;0&lt;/span&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt;&lt;div&gt; &lt;p&gt;2&lt;/p&gt; &lt;span&gt;3&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用p：last-of-type匹配到的&lt;p>1&lt;/p>和&lt;p>2&lt;/p>,使用p:last-child匹配到的是&lt;p>1&lt;/p>。 E:nth-of-type(n) 匹配到的元素E是其父元素中的第n个子元素（仅从其子元素为E的时候开始数），而E：nth-child(n)匹配到的元素E是其父元素中的第n个子元素（从第一个子元素就开始数，不管它是不是E元素）123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中，如果使用p:nth-of-type(3)，匹配到的是&lt;p>5&lt;/p>,如果使用p:nth-child(3)，匹配到的是&lt;p>3&lt;/p>。 伪元素选择器 E::selection 匹配用户当前选中的元素 E::first-line/E:first-line 匹配E元素的第一行，只适用于块级元素，内联对象要使用该伪对象，必须先将其设置为块级对象。 E::first-letter/E:first::letter 匹配E元素的第一个字母，此伪对象仅作用于块对象。内联对象要使用该伪对象，必须先将其设置为块级对象。该伪类常被用来配合font-size属性和float属性制作首字下沉效果。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;title&gt;E::first-letter&lt;/title&gt;&lt;style&gt;h1&#123;font-size:16px;&#125;p&#123;width:200px;padding:5px 10px;border:1px solid #ddd;font:14px/1.5 simsun,serif,sans-serif;&#125;p:first-letter &#123;float:left;font-size:40px;font-weight:bold;line-height:1;&#125;p::first-letter &#123;float:left;font-size:40px;font-weight:bold;line-height:1;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;杂志常用的首字下沉效果&lt;/h1&gt;&lt;p&gt;今天，阳光明媚，晴空万里，非常适合户外活动，如踏青、远足之类的。长期坐在办公室的同学们要多注意运动。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; E:before/E::before 在E元素之前插入生成的内容，通常配合content属性一起使用 E：after/E::after 在E元素之后插入生成的内容，通常配合content属性一起使用 E::placeholder 用于控制表单输入框占位符的外观，它允许开发者/设计师改变文字占位符的样式，默认的文字占位符为浅灰色。有些浏览器中placeholder的文字颜色不能通过input标签的color属性来修改。]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2018%2F02%2F01%2FCSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[CSS(Cascading Style Sheet)层叠样式表，是用于控制网页样式并允许将样式代码与网页内容分离的一种标记性语言。CSS3是CSS规范的最新版本，它在CSS2.1的基础上增加了很多强大的新功能，以帮助开发人员能够解决一些实际的问题。 CSS3的新特性 完善选择器 完善视觉效果，如圆角，阴影，渐变背景，半透明，图片边框等。 完善背景效果 完善盒模型 增强背景功能 增加阴影效果，包括文本阴影和盒子阴影 增加多列布局和弹性盒模型布局 完善Web字体和Web Font图标 增强颜色和透明度功能 新增圆角和边框功能 增加变形操作 增加动画和交互效果 增加媒体特性和响应式布局CSS的三种引入方式 行内样式&lt;p style=&quot;color:red;font-size:20px&quot;&gt;你好&lt;/p&gt; 内部样式表通过style标签引入。style标签写在head标签内。 123456789101112131415&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;内部样式表&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; p&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;你好&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 外部样式表 通过link标签引入。 12345678910&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;外部样式表&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot; /&gt; &lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; @import方式引入 123456789101112131415&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;外部样式表&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; @import url(&quot;css/style.css&quot;); &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ol&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;/ol&gt;&lt;/html&gt; 该规则必须在样式表头部最先声明。并且其后的分号是必需的，如果省略了此分号，外部样式表将无法正确导入，并会生成错误信息。 使用url()和直接使用url需要注意的地方：123@import url(&quot;global.css&quot;);@import url(global.css);@import &quot;global.css&quot;; 以上3种方式都有效。当使用url(url)的方式时，包住路径的引号可有可无；当直接使用url时，包住路径的引号必须保留。 指定媒体查询：123@import url(example.css) screen and (min-width:800px);@import url(example.css) screen and (width:800px),(color);@import url(example.css) screen and (min-device-width:500px) and (max-device-width:1024px); 使用link标签引入css样式表的时候可以在media属性里指定媒体查询。 link和@import引入样式表的区别 link标签引入是HTML标签提供的功能；而@import是CSS提供的功能； link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link是HTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM去改变样式；而@import不支持。即document.getElementById(&quot;link1&quot;.href=&quot;other.css&quot;);CSS的优先级 CSS优先级的顺序：（从高到低） 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。 作为style属性写在元素内的样式 id选择器 类选择器 标签选择器 通配符选择器 浏览器自定义或继承同一级别中后写的会覆盖先写的样式。 出现多个级别的组合时，可以使用下面的方法简单判断。CSS优先级：是由四个级别和各级别的出现次数决定的。四个级别分别为：行内选择符、ID选择符、类别选择符、元素选择符。优先级的算法：每个规则对应一个初始”四位数”：0、0、0、0若是 行内选择符，则加1、0、0、0若是 ID选择符，则加0、1、0、0若是 类选择符/属性选择符/伪类选择符，则分别加0、0、1、0若是 元素选择符/伪元素选择符，则分别加0、0、0、1算法：将每条规则中，选择符对应的数相加后得到的”四位数“，从左到右进行比较，大的优先级越高。 如：1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div.test&#123; background-COLOR:#a00; width:100px; height: 100px; &#125; .test.test2&#123; background-COLOR:#0e0; width:100px; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;test test2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; div.class的权值是0,0,1,1，而.test1 .test2的权值是0,0,2,0，.test1 .test2的权值更多，所以div会应用.test1 .test2变成绿色。 CSS的一些语法规则！important提升指定样式规则的应用优先权。div {color: #f00 !important;} /commet/注释CSS中的某些内容。div {color: #f00; /*红色*/} @import指定导入的外部样式表及目标媒体。 @charset在外部样式表文件内使用。指定该样式表使用的字符编码。该规则后面的分号是必需的，如果省略了此分号，会生成错误信息。123@charset &quot;utf-8&quot;;body &#123; sRules &#125;div &#123; sRules &#125; @media媒体查询 @font-face设置嵌入HTML文档的字体。@font-face { font-family: &lt;identifier&gt;; src: &lt;fontsrc&gt; [, &lt;fontsrc&gt;]*; &lt;font&gt;;}&lt;fontsrc&gt; = &lt;url&gt; [format(&lt;string&gt;)]取值： ：字体名称 ：此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径 ：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype, opentype, embedded-opentype, svg等 ：定义字体相关样式12345678@font-face &#123; font-family: &apos;diyfont&apos;; src: url(&apos;diyfont.eot&apos;); /* IE9+ */ src: url(&apos;diyfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;diyfont.woff&apos;) format(&apos;woff&apos;), /* chrome、firefox */ url(&apos;diyfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url(&apos;diyfont.svg#fontname&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125; font-family和src是必选的，下面设置为可选项。 ：定义字体相关样式取值：font-stretch，定义如何拉伸字体。font-style:定义字体的样式，取值有normal、italic、oblique，默认为narmalfont-weight：定义字体的粗细，默认为normal1234567@font-face&#123;font-family: myFirstFont;src: url(&apos;Sansation_Bold.ttf&apos;), url(&apos;Sansation_Bold.eot&apos;); /* IE9+ */font-weight:bold;&#125; @keyframes定义CSS3动画。 @supports@supports检测是否支持某CSS特性。基本用法：@supports (rule)[operator (rule)]* { sRules }取值：rule：指定一条具体的CSS规则，必须使用括号包裹operator：使用or | and | not等操作符指定多条规则。【示例1】定义支持和不支持flex标准写法的浏览器分别使用不同的规则。12345678910111213141516171819202122@supports ( display: flex ) &#123; body &#123; display: flex; &#125; #aside &#123; width: 210px; &#125; #main &#123; flex: auto; &#125;&#125;@supports not ( display: flex ) &#123; #aside &#123; float: left; width: 210px; &#125; #main &#123; overflow: hidden; *zoom: 1; &#125;&#125; 【示例2】你也可以写多重规则来进行过滤。123456789@supports ( box-shadow: 2px 2px ) or ( -moz-box-shadow: 2px 2px ) or ( -webkit-box-shadow: 2px 2px ) &#123; .demo &#123; -moz-box-shadow: 2px 2px 0 rgba(0, 0, 0, .3); -webkit-box-shadow: 2px 2px 0 rgba(0, 0, 0, .3); box-shadow: 2px 2px 0 rgba(0, 0, 0, .3); &#125;&#125;]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML]]></title>
    <url>%2F2018%2F01%2F10%2FXML%2F</url>
    <content type="text"><![CDATA[使用XML数据XML格式是互联网数据传输的事实标准，传统的WEB服务大都建立在XML数据上。不过XML数据结构过于繁琐、冗长，数据访问过程复杂，浏览器兼容性问题严重，导致它在Web应用开发中逐渐被JSON格式数据取代。 新建XML文档XML是可扩展的标记语言，用户可以根据需要自定义标记，实现数据格式的自由定义与传输。123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- xml文档结构 --&gt;&lt;blog&gt; &lt;item&gt; &lt;id&gt;1&lt;/id&gt; &lt;title&gt;标题1&lt;/title&gt; &lt;time&gt;发布时间&lt;/time&gt; &lt;content&gt;日志内容&lt;/content&gt; &lt;word&gt; &lt;user&gt;昵称&lt;/user&gt; &lt;time&gt;留言时间&lt;/time&gt; &lt;text&gt;留言内容&lt;/text&gt; &lt;/word&gt; &lt;/item&gt;&lt;/blog&gt; 与HTML文档一样，XML文档也是由各种标签组成，文档内容由一个根节点包含，由开始标记&lt;blog>和结束标记&lt;/blog>组成。但XML标签能够自己命名，标记数据的语义，标签不承担显示效果。XML文档一般包括三个部分：XML声明、处理指令和XML数据结构，其中处理指令是可选部分。每个XML文档都必选有声明，声明信息是正确解析XML数据的基础，它必须是XML文档中的第一行内容，且前面不能包含任何字符，包括空格。在XML声明中必须指定version属性值，指明文档所采用的XML版本号，一般直接使用’1.0’的版本即可。同时定义文档字符集。 访问XML数据XML DOM 定义了访问和操作XML文档的标准方法。根据XML DOM 规范，XML文档中每个对象都是一个节点。 整个文档是一个文档节点 每个XML标签是一个元素节点 包含在XML标签里的文本是文本节点 每一个XML属性是一个属性节点 注释属于注释节点通过DOM接口，用户可以访问、修改、添加、删除、创建节点。创建XML DOM对象IE8及其早期版本的浏览器对于XML的支持通过基于ActiveX的MSXML组件实现。使用ActiveXObject()构造函数可以创建XML DOM对象，用法如下：var xmlDom=new ActiveXObject(&#39;Microsoft.XmlDom&#39;);在符合标准的现代浏览器中，可以通过document对象的Implementation属性，使用该对象的createDocument()方法创建XML DOM对象。createDocument()方法包含以下三个参数：第一个参数表示命名空间，但是Javascript管理命名空间比较困难，所以第一个参数通常是空字符串。第二个参数是包含文档根元素名称的字符串。第三个参数是要创建的文档类型，现在很多浏览器不提供对文档类型的Javascript支持，故第三个参数通常为null。【示例1】创建一个空的XML文档对象var xmlDom=document.implementation,createDocument(&quot;&quot;,&quot;&quot;,null);【示例2】创建一个以root为根元素的XML文档对象var xmlDom=document.implementation,createDocument(&quot;&quot;,&quot;root&quot;,null);加载XML数据IE支持使用XML DOM对象加载XML数据的方式有两种：loadXML()和load()。【示例1】loadXML()方法能够把XML数据字符串转换为XML DOM对象。1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;title&gt;XML&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;var o = new ActiveXObject(&apos;Microsoft.XmlDom&apos;);var s = &quot;&lt;recordset&gt;&lt;record&gt;&lt;ProductID&gt;1&lt;/ProductID&gt;&lt;ProductName&gt;苹果汁&lt;/ProductName&gt;&lt;/record&gt;&lt;/recordset&gt;&quot;o.onreadystatechange = function() &#123; if(o.readyState == 4) console.log(o.xml); &#125;o.loadXML(s);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 【示例2】load()方法能够加载XML数据文件。1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;title&gt;XML&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;var o = new ActiveXObject(&apos;Microsoft.XmlDom&apos;);o.onreadystatechange = function() &#123; if(o.readyState == 4) console.log(o.xml); &#125;o.load(&quot;test.xml&quot;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; load()方法的参数值可以是相对路径或绝对路径等。但是出于安全考虑，load()方法不能实现跨域访问XML文件。load()方法也可以用来加载字符串，但是loadXML()方法不能用来加载文件。load()方法在加载数据时，有两种模式：同步加载和异步加载。在同步模式下，XML文件被完全加载之后才能够执行其它操作；而异步加载时，用户不需要等待，可以执行其他操作，也可以跟踪加载过程并决定下一步的操作。 设置加载模式load()方法默认的加载模式为异步加载，也可以通过async属性来设置加载模式，该属性是布尔值，取值为false表示同步加载，取值为true表示异步加载。【示例3】下面使用load()方法加载XML文档。 123var o = new ActiveXObject(&apos;Microsoft.XmlDom&apos;);o.async = false;o.load(&quot;test.xml&quot;); 跟踪异步加载状态与XMLHttpRequest对象异步通信状态一样，XML DOM对象使用readyState属性跟踪加载进程。readyState属性的取值共有五个：0，尚未初始化；1，正在加载数据；2，完成了数据加载；3，已经可用，不过可能某些部分还不能使用；4，已经被完全加载，可以使用了。同时XML DOM对象定义了onreadystatechange属性，每当readyState属性值发生变化时，就会触发readystatechange事件，激活onreadystatechange事件处理函数。【示例4】】可以使用下面的方法，判断XML文件是否被完全加载到XML DOM对象。 123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;title&gt;XML&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;var o = new ActiveXObject(&apos;Microsoft.XmlDom&apos;);o.async = true;o.onreadystatechange=function()&#123; if(o.readyState==4)&#123; alert(&apos;已加载&apos;); &#125;&#125;;o.load(&quot;test.xml&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM2 仅仅支持load()方法加载外部XML数据。【示例5】使用load()方法加载XML数据。（浏览器会提示升级方法,同时不支持加载字符串）12var xmlDom = document.implementation.createDocument(&quot;&quot;,&quot;&quot;, null);xmlDom.load(&quot;test.xml&quot;); async属性可以设置是同步加载，还是异步加载。如果将async属性设置为false，表示以同步模式加载文档；否则，以异步模式加载文档。XML DOM对象不支持readyState属性和onreadystatechange事件处理函数。但是可以借助load事件和onload事件处理函数来检测XML文档加载是否完毕，当XML文档完全加载后会触发load事件。【示例6】跟踪加载状态。12345var xmlDom = document.implementation.createDocument(&quot;&quot;,&quot;&quot;, null);xmlDom.load(&quot;test.xml&quot;);xmlDom.onload = function()&#123; alert(&quot;加载完毕&quot;);&#125; 【示例7】DOM的XML DOM对象不支持loadXML()方法，不过可以通过DOMParse对象来模拟loadXML()的功能。该对象包含有parseFromString()的方法，用来记载字符串并解析成文档。123var s = &quot;&lt;recordset&gt;&lt;record&gt;&lt;ProductID&gt;1&lt;/ProductID&gt;&lt;ProductName&gt;Æ»¹ûÖ­&lt;/ProductName&gt;&lt;/record&gt;&lt;/recordset&gt;&quot;;var o = new DOMParser();var xmlDom = o.parseFromString(s,&quot;text/xml&quot;); 在上面代码中，创建了一个XML字符串，并作为参数传递给DOMParse的parseFromString()方法。该方法包含两个参数，分别是XML字符串和数据的内容类型。要解析XML代码，内容类型应该是’text/xml’或者’application/xml’,任何其它内容类型都会被忽略。该方法返回XML对象，因此上面代码生成的XML DOM对象与使用implementation.createDocument()方法创建XML DOM对象功能相同。 显示XML数据XML DOM严格遵循DOM2 标准，可以使用documentElement属性获取根元素，使用childNodes、firstChild等属性遍历节点。【示例1】在IE浏览器中，text属性可以读取当前节点包含的所有内容，包括所有子节点的文本。可以使用下面的方法进行模拟。123456789101112131415161718192021222324252627&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;var s = &quot;&lt;recordset&gt;&lt;record&gt;&lt;ProductID&gt;1&lt;/ProductID&gt;&lt;ProductName&gt;苹果&lt;/ProductName&gt;&lt;/record&gt;&lt;/recordset&gt;&quot;;var o = new DOMParser();var xmlDom = o.parseFromString(s,&quot;text/xml&quot;);var s = text(xmlDom.documentElement);alert(s);function text(o) &#123; var s = &quot;&quot;; for (var i = 0; i &lt; o.childNodes.length; i++) &#123; if (o.childNodes[i].hasChildNodes()) &#123; s += text(o.childNodes[i]); &#125; else &#123; s += o.childNodes[i].nodeValue; &#125; &#125; return s;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 【示例2】在IE浏览器中，xml属性将存放对当前节点包含的所有XML字符串。DOM不支持该属性，但是它提供了可以实现相同目的的XMLSerializer对象来完成这一功能。该对象定义了serializeToString()方法，可以通过该方法将XML数据转换成字符串。1234567891011121314151617&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;meta charset=&quot;gb2312&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;var s = &quot;&lt;recordset&gt;&lt;record&gt;&lt;ProductID&gt;1&lt;/ProductID&gt;&lt;ProductName&gt;Æ»¹ûÖ­&lt;/ProductName&gt;&lt;/record&gt;&lt;/recordset&gt;&quot;;var o = new DOMParser();var xmlDom = o.parseFromString(s,&quot;text/xml&quot;);var p=new XMLSerializer();var q=p.serializeToString(xmlDom.documentElement);console.log(q);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 解析XML字符串的兼容性写法IE使用 loadXML() 方法来解析 XML 字符串，而其他浏览器使用 DOMParser 对象。兼容性写法：1234567891011if (window.DOMParser) &#123; parser=new DOMParser(); xmlDoc=parser.parseFromString(txt,&quot;text/xml&quot;); &#125; //txt表示要解析的XML字符串，要解析XML代码，内容类型应该是&quot;text/xml&quot;或者&quot;application/xml&quot;,任何其他内容类型都会被忽略else // Internet Explorer &#123; xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;); xmlDoc.async=&quot;false&quot;; xmlDoc.loadXML(txt); &#125;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2018%2F01%2F09%2FJSON%2F</url>
    <content type="text"><![CDATA[JSON是随Ajax出现而诞生的一种轻量级的数据格式，它是Javascript的一个子集，符合ECMAScript语法规范，JSON数据实际上就是一段原生的Javascript代码，因此容易阅读和编写,同时也易于机器解析和生成。 JSON结构JSON结构可以由下面三种类型的数据组成。 值：表示字符串、数值、布尔值、对象、数组和null，但是不支持Javascript的undefined。 对象：表示一组无序键/值对。每个键/值对中的值可以是简单的值，也可以是复杂类型的值。 数组：表示一组无序的值列表，可以通过数字索引访问其中的值。数组的值也可以是任意类型。JSON可以由无数个对象、数组嵌套组成，构成一个复杂的数据结构。值最简单的JSON数据形式就是单个的值。1这是JSON表示数值1的方式。&quot;Hello World&quot;这是JSON表示字符串的方式。Javascript字符串和JSON字符串最大的区别在于：JSON字符串必须使用双引号，不能够使用单引号，使用单引号容易发生语法错误。对于特殊字符可以使用转义序列来表示。数值可以是整数、浮点数，也可以使用科学计数法来表示。数值可以直接引用，不需要添加引号。逻辑值包括true或false，直接使用，不需要添加引号。在JSON数据中，分隔符（如空格、制表符、换行符）是不被解析的，因此可以在数据结构内任意位置增加空白，以实现对数据的格式化排版。对象对象是无序的键/值对集合。基本构成规则：以左大括号开始，以右大括号结束，每个键与值之间使用冒号进行分隔，键/值对之间使用逗号分隔。【示例1】在下面这段JSON数据中，string为元素的名称，value为元素的值，中间使用冒号分隔。[&quot;string1&quot;:&quot;value1&quot;,&quot;string2&quot;:&quot;value2&quot;......]【示例2】JSON对象与Javascript对象直接量稍微有一些不同。1234var user=&#123; name:&quot;zhangsan&quot;; sex:&quot;male&quot;&#125;; 这是在Javascript中创建对象直接量的标准方式。但是在JSON中，对象要求给属性加双引号。1234&#123; &quot;name&quot;:&quot;zhangsan&quot;; &quot;sex&quot;:&quot;male&quot;&#125; 与Javascript的对象直接量相比，JSON对象没有声明变量，因为在JSON仅是一种表示结构化数据的格式，不支持变量、函数或类型实例。此外，没有末尾的分号，因为这不是Javascript语句，所以不需要分号。注意，JSON对象的属性必须加双引号，这在JSON中是必需的。属性的值可以是简单的值，也可以是复杂类型值。1234567891011121314151617181920&#123; &quot;name&quot;:&quot;w3c&quot;, &quot;book&quot;:&#123; &quot;name&quot;:[&#123;&quot;lang&quot;:&quot;cn&quot;&#125;,&quot;js&quot;]&#125;``` 上面的代码在顶层对象中嵌入了&quot;book&quot;信息。虽然有两个&quot;name&quot;属性，但是它们分别属于不同的对象，所以不会造成冲突，同一个对象中绝对不能出现同名属性。 #### 数组数组是有序值的集合。基本构成规则：以左中括号开始，以右中括号结束。值之间使用逗号分隔。`[&quot;value1&quot;,&quot;value2&quot;......]`在这个有序列表中，前后值的顺序是不能调换的，第一个值的索引是0，第二个值的索引是1，以此类推。JSON数组采用的是Javascript中数组直接量形式。Javascript中的数组直接量：`var arr=[1,true,&quot;false&quot;];`JSON中的数组：`[1,true,&quot;false&quot;]`注意，JSON数组也没有变量和分号。### JSON与XML比较与XML相比，JSON有很多优点，它是高性能AJAX的基石。【示例1】对于下面的XML文档，要想获取其中的数据，则必须要先定义XML DOM 对象，加载XML文档，然后再利用该对象所提供的方法和属性来遍历结构并逐一读取每个节点包含的数据内容，整个操作构成非常繁琐，还需要考虑浏览器的兼容性。 &lt;?xml version=”1.0” encoding=”utf-8”?&gt; XPath语言基础 w3c 2017 30.5 精通XPath css2 2017 50 1如果使用JSON数据格式，如下： [ { “title” : [ { “lang” : “cn”}, “XPath语言基础” ], “author” : “w3c”, “date” : “2017”, “price” : 30.5 }, { “title” : [ {“lang” : “en”}, “精通XPath” ], “author” : “css2”, “date” : “2017”, “price” : 50 }]12345678910111213直观比较，很显然JSON数据更简洁，它没有很多的元素名，数据传输量当然就小得多。并且这种格式与Javascript的语法规则一致，因此可以直接在Javascript的脚本中读取数据。比较XML和JSON两种数据格式，得出以下几点不同：* 可读性：两者都具有很强的可读性。XML数据严格遵循XML DOM规范，而JSON严格遵循Javascript语法。* 可扩展性：两者都具有很强的扩展性。XML通过自定义标签，可以设计更加负责的数据嵌套结构，而JSON通过数组和对象的相互嵌套组合也能够模拟XML的数据结构。* 编码难度：JSON编码比XML明显容易。* 解码难度：XML数据解析需要考虑结构层次，以及节点关系，解析难度大，而JSON数据不存在解析难度。### 解析JSONECMAScript 5提供了一个全局的JSON对象，用来序列化和反序列化对象为JSON格式。#### 使用JSON.parse()JSON.parse()能够把JSON格式的文本转换成一个ECMAScript值（如对象或数组）。用法如下：`JSON.parse(text[,reviver])`参数text表示一个有效的JSON字符串，最后返回一个对象或者数组。【示例1】下面代码使用JSON.parse将JSON字符串转换成对象。 var jsontext = ‘{“name”:”张三”,”qq”:”111111111”,”phone”:[“010-66666666”,”010-88888888”]}’;var contact = JSON.parse(jsontext);document.write(contact.name + “, “ + contact.qq);// 输出：张三, 11111111112345参数reviver为可选参数，它表示一个转换函数JSON.parse()将为对象的每个成员调用该参数函数。如果成员包含嵌套对象，则先于父对象转换嵌套对象。对于每个成员，会发生以下情况：* 如果reviver函数返回一个有效值，则成员值转换为转换后的值。* 如果reviver函数返回它接收的相同值，则不修改成员值。* 如果reviver函数返回null或undefined，则删除成员。【示例2】可选参数reviver是一个带有key和value两个参数的函数，其作用于结果，让过滤和转换返回值成为可能。例如，下面示例将把字符串&apos;&#123;&quot;a&quot;: &quot;1.5&quot;, &quot;b&quot;: &quot;2.3&quot;&#125;&apos;;转换为对象，然后通过int()函数对转换的对象成员值进行处理，确保每个值都为整数。 var n = ‘{“a”: “1.5”, “b”: “2.3”}’;var result = JSON.parse(n,int );document.write(result.a); //输出：1function int(key, value){ if (typeof value == ‘string’){ return parseInt(value); } else { return value; }}12#### 使用eval()eval(string):函数可计算某个字符串，并执行其中的的 JavaScript 代码。 eval(“var a=1”); // 声明一个变量a并赋值1。eval(“2+3”); // 执行加运算，并返回运算值。eval(“mytest()”); // 执行mytest()函数。eval(“{b:2}”); // 声明一个对象。12345678910111213141516171819使用eval(&apos;(&apos;+text+&apos;)&apos;)的方式也能够解析JSON。注意：为什么要加括号呢？原因在于：eval 本身的问题。 由于 json 是以 &#123;&#125; 的方式来开始以及结束的，在 js 中，它会被当成一个语句块来处理，所以必须强制性的将它转换成一种表达式。加上圆括号的目的是迫使 eval 函数在处理 JavaScript 代码的时候强制将括号内的表达式（expression）转化为对象，而不是作为语句（statement）来执行。虽然eval()和parse.JSON()都能够用来解析JSON，但是推荐后者。因为eval()在解析字符串的时候会执行字符串中的代码，隐藏着潜在的安全问题。而parse.JSON()只识别 JSON 文本，不会编译脚本。### 序列化JSONJSON.stringify()函数能够将Javascript值转换成JSON字符串。基本语法：`JSON.stringify(value[,replacer][,space])`参数说明如下：* value，必需参数，设置要转换的Javascript值，通常为对象或数组。* replacer，可选参数，用于转换结果的函数或数组。如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：&quot;&quot;。如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。* space，可选参数，用于向返回值JSON字符串中添加缩进、空格和换行符。如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。如果 space 是一个非空字符串，则返回值文本在每个级别中缩进字符串中的字符。如果space是长度大于10个字符的字符串，则使用前10个字符。JSON.stringify()函数的返回值是一个JSON格式的字符串。【示例1】下面示例演示了如何使用JSON.stringify将数组转换成JSON字符串，然后使用JSON.parse将该字符串重新转换成数组。 var arr = [“a”, “b”, “c”];var str = JSON.stringify(arr);document.write(str); // [“a”,”b”,”c”]document.write (““);var newArr = JSON.parse(str);while (newArr.length &gt; 0) { document.write(newArr.pop() + ““);}1【示例2】下面示例把对象nums转换为JSON字符串，然后传入replacer()函数过滤出即将被字符串化的对象中值为13的属性。 var nums = { “first”: 7, “second”: 14, “third”: 13}var luckyNums = JSON.stringify(nums,replacer);document.write(luckyNums); //{“first”:7,”second”:14}function replacer(key, value){ if (value == 13) { return undefined; } else { return value; }}1【示例3】下面示例是在上面示例基础上，设置space参数值为4，格式化JSON字符串，设置水平缩进为4个空格数。 var nums = { “first”: 7, “second”: 14, “third”: 13}var luckyNums = JSON.stringify(nums,replacer,4);document.write(““ + luckyNums + ““);function replacer(key, value){ if (value == 13) { return undefined; } else { return value; }}1【示例4】下面示例使用JSON.stringify将contact对象转换为JSON 文本，定义memberfilter数组以便只转换name、sex和tel成员，同时排序显示为name、sex和tel。 var contact = { qq : “111111111”, name : “张三”, tel : “13555556666”, sex : “men”, url : “http://www.mysite.cn/&quot;}var memberfilter = [“name”,”sex”,”tel”];var jsonText = JSON.stringify(contact, memberfilter, “\t”);document.write(““ + jsonText + ““); 1【示例5】下面示例使用JSON.stringify将一个数组进行转换，调用replaceToUpper 函数将数组中的每个字符串转换为大写形式。 var continents = [“Europe”,”Asia”,”Australia”,”Antarctica”,”North America”,”South America”,”Africa”];var jsonText = JSON.stringify(continents, replaceToUpper);function replaceToUpper(key, value) {//key为空，value是整个数组 return value.toString().toUpperCase();}document.write(jsonText); //输出：”EUROPE,ASIA,AUSTRALIA,ANTARCTICA,NORTH AMERICA,SOUTH AMERICA,AFRICA”`]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖放]]></title>
    <url>%2F2018%2F01%2F08%2F%E6%8B%96%E6%94%BE%2F</url>
    <content type="text"><![CDATA[在HTML5之前，要实现网页对象的拖放操作，需要借助Javascript的mousedown、mousemove、mouseup等事件，通过大量的Javascript脚本来实现。HTML5引入拖放（Drag and Drop）API，这样大大简化了网页对象拖放的编程难度。HTML5拖放API除了支持浏览器内部元素的拖放外，也支持浏览器和其他应用程序之间的数据互相拖动。 拖放API拖放API事件上包含两个部分：拖拽（Drag）和释放（Drop），拖拽指的是鼠标点按源对象后一直移动对象不松手，一旦松手即释放。提示：源对象：指鼠标点按的一个事物，如一张图片、一个div、一段文本等。目标对象：指拖动源对象后移动到一个区域，源对象可以进入这个区域，可以在这个区域上方悬停（未松手），可以释放源对象，将其放置目标对象内（已松手），也可以悬停后离开该区域。 拖放API基础拖放是一种常见的操作特性，即抓取对象以后拖到另一个位置。在HTML5中，拖放是标准的一部分，任何元素都能够拖放。在HTML5中，实现拖放操作的步骤如下： 设置源对象的draggable属性，设置属性值为”true”，这样就可以启动拖放功能。注：img和a标签默认开启了拖放功能，但必须设置href。 根据HTML5拖放API定义事件类型，编写与拖放有关的事件处理函数。被拖放的源对象可以出发的事件： dragstart:源对象开始被拖动 drag：源对象在拖放过程中，即鼠标可能在移动，也可能未移动 dragend：源对象被拖放结束(目标对象触发)拖动源对象进入到目标对象，在目标对象上可以触发的事件。 dragenter：目标对象被源对象拖动着进入 dragover：目标对象被源对象拖动着悬停在上方 dragleave：拖动着源对象离开了目标对象 drop：拖动着源对象在目标对象上松手【示例1】本例在页面上插入一个&lt;div id=’drag’&gt;标签，设置draggable=’true’，启动该元素的拖放功能。同时在页面中插入一个&lt;div id=’target’ &gt;标签，设置为目标对象。本例设计当每次拖放源对象到目标对象中时，追加一次提示信息。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;function init()&#123; var source = document.getElementById(&quot;drag&quot;); var dest = document.getElementById(&quot;target&quot;); // (1) 拖放开始 source.addEventListener(&quot;dragstart&quot;, function(ev) &#123; // 向dataTransfer对象追加数据 var dt = ev.dataTransfer; dt.effectAllowed = &apos;all&apos;; //(2) 拖动元素为dt.setData(&quot;text/plain&quot;, this.id); dt.setData(&quot;text/plain&quot;, &quot;拖入源对象&quot;); &#125;, false); // (3) dragend：拖放结束 dest.addEventListener(&quot;dragover&quot;, function(ev) &#123; //不执行默认处理（拒绝被拖放） ev.preventDefault(); &#125;, false); // (4) drop:被拖放 dest.addEventListener(&quot;drop&quot;, function(ev) &#123; // 从DataTransfer对象那里取得数据 var dt = ev.dataTransfer; var text = dt.getData(&quot;text/plain&quot;); dest.innerHTML += &quot;&lt;p&gt;&quot; + text + &quot;&lt;/p&gt;&quot;; &#125;, false);&#125;&lt;/script&gt;&lt;style&gt;#drag &#123; width: 100px; height: 100px; background-color: #93FB40; border-radius: 12px; text-align:center; line-height:100px; color:#F423CC; &#125;#target &#123; width: 200px; height: 200px; border: 1px dashed gray; margin: -100px 12px 12px; float:right;&#125;#target h1&#123; text-align:center; color:#F423CC; margin:6px 0; font-size:16px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body onload=&quot;init()&quot;&gt;&lt;!-- (7) 把draggable属性设为true --&gt;&lt;div id=&quot;drag&quot; draggable=&quot;true&quot;&gt;源对象&lt;/div&gt;&lt;div id=&quot;target&quot;&gt; &lt;h1&gt;目标对象&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; 代码解析： 开始拖动时，dragstart事件发生，使用setData()方法把要拖动的数据存入DataTransfer对象。DataTransfer对象专门用来存放拖放操作时要传递的数据，可以通过拖放事件对象的dataTransfer属性进行访问。DataTransfer对象包含两个重要方法setData()和getData()。其中setData()方法用于向DataTransfer对象传递值，而getData()方法能够从DataTransfer对象中读取值。setData()方法的第一个参数为携带数据的数据类型，第二个参数为携带的数据。MIME可选类型： text/plain:文本文字 text/html:HTML文字 text/xml:xml文字 text/uri-list:url列表，每个url为一行2.针对拖放的目标对象，在dragover事件内调用事件对象的preventDefault()方法阻止默认行为，不然不会触发drop事件。dest.addEventListener(&quot;dragover&quot;, function(event){event.preventDefault(); }, false);也可以设置整个页面不执行默认行为，document.ondragover = function(e){e.preventDefault();};两者的区别仅在于拖放图标的显示效果不一样。 目标参数接受到被拖放元素之后，执行getData()方法从DataTransfer对象中获取数据。getData()方法包含一个参数，参数为setData()方法中指定的数据类型。使用DataTransfer对象DataTransfer对象的属性：dropEffect：表示拖放操作的视觉效果，允许设置值为：none，copy，link、move。该效果必须在effectAllowed属性指定的视觉效果范围内。effectAllowed：指定当元素被拖放时所允许的视觉效果。可以指定的值为none、copy、copyLink、copyMove、link、linkMove、move、all、unintialized。types:存入数据的类型，字符串的伪数组。DataTransfer对象的方法：setData():向DataTransfer对象存入数据getData():从DataTransfer对象读取数据clearData():清除DataTransfer对象中存放的数据。包含一个参数，设置要清除数据的类型；如果省略该参数，则清除全部数据。setDragImage():设置拖放图标。 dropEffect和effectAllowed属性结合起来设置拖放时的视觉效果。effectAllowed属性表示当一个元素被拖动时所允许的视觉效果，一般在dragstart事件中定义。取值：copy：允许将被拖动元素复制到拖动的目标元素中move：允许将被拖动的元素移动到拖放的目标元素中link：通过拖放操作，被拖动元素将链接到拖动的目标元素上none：不允许执行任何拖动操作copyLink：被拖动元素被复制或链接到拖动的目标元素中。根据拖动的目标来决定执行复制操作还是链接操作copyMove：被拖动元素被复制或移动到拖动的目标元素中。根据拖动的目标来决定执行复制操作还是移动操作linkMove：被拖动元素被移动或链接到拖动的目标元素中。根据拖动的目标来决定执行移动操作还是链接操作all：允许执行所有的拖动操作，包括复制、移动与链接操作uninitialize，不指定effectAllowed属性值，将执行浏览器中默认允许的拖放操作。 dropEffect属性表示实际拖放时的视觉效果，一般在dragover时间中指定。允许设置的值为none、copy、link、move。dropEffect所表示的实际视觉效果必须与effectAllowed属性值所表示的允许操作相匹配。如果effectAllowed属性设置为none，则不允许拖放元素；如果dropEffect属性设置为none，则不允许被拖放到目标元素；如果effectAllowed属性设置为all或不设置，则dropEffect属性允许被设置为任意值。【示例1】DataTransfer对象的setDragImage()方法包含3个参数：第一个参数设置拖放图标的图标元素；第二个参数设置拖放图标里鼠标指针的x轴方向的位移量；第三个参数设置拖放图标里鼠标指针的y轴方向的位移量。（-10，-10），鼠标指针在图片的左上方。123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt;//创建图标元素var dragIcon=document.createElement(&apos;img&apos;);//设置图标来源dragIcon.src=&apos;images/11.png&apos;;function init()&#123; var source = document.getElementById(&quot;drag&quot;); var dest = document.getElementById(&quot;target&quot;); source.addEventListener(&quot;dragstart&quot;, function(ev) &#123; var dt = ev.dataTransfer; dt.setDragImage(dragIcon, -10, -10); dt.effectAllowed = &apos;copy&apos;; dt.setData(&quot;text/plain&quot;, this.id); &#125;, false); dest.addEventListener(&quot;dragover&quot;, function(ev) &#123; var dt = ev.dataTransfer; dt.dropEffect = &apos;copy&apos;; &#125;, false); dest.addEventListener(&quot;dragend&quot;, function(ev) &#123; ev.preventDefault(); &#125;, false); dest.addEventListener(&quot;drop&quot;, function(ev) &#123; var dt = ev.dataTransfer; var text = dt.getData(&quot;text/plain&quot;); dest.innerHTML += &quot;&lt;p&gt;&quot; + text + &quot;&lt;/p&gt;&quot;; ev.preventDefault(); ev.stopPropagation(); &#125;, false);&#125;document.ondragover = function(e)&#123;e.preventDefault();&#125;;document.ondrop = function(e)&#123;e.preventDefault();&#125;;&lt;/script&gt;&lt;style&gt;#drag &#123; width: 100px; height: 100px; background-color: #93FB40; border-radius: 12px; text-align:center; line-height:100px; color:#F423CC; &#125;#target &#123; width: 200px; height: 200px; border: 1px dashed gray; margin: 12px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body onload=&quot;init()&quot;&gt;&lt;img id=&quot;drag&quot; src=&quot;images/1.png&quot; width=&quot;314&quot; height=&quot;314&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;target&quot;&gt;&lt;/div&gt;&lt;/body&gt; 实战案例删除项目【示例1】本例设计一个简单的列表容器，允许用户通过鼠标拖拽的方式把指定的列表项删除。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;style&gt;body &#123; font-size: 84%; &#125;#dustbin &#123; width: 100px; height: 260px; line-height: 1.4; background-color: gray; font-size: 36px; font-family: &quot;微软雅黑&quot;, &quot;Yahei Mono&quot;; text-align: center; text-shadow: -1px -1px #bbb; float: left; &#125;.dragbox &#123; width: 500px; padding-left: 20px; float: left; &#125;.draglist &#123; padding: 10px; margin-bottom: 5px; border: 2px dashed #ccc; background-color: #eee; cursor: move; &#125;.draglist:hover &#123; border-color: #cad5eb; background-color: #f0f3f9; &#125;#dragremind &#123; padding-top: 2em; clear: both; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;dustbin&quot;&gt;&lt;br&gt; 垃&lt;br&gt; 圾&lt;br&gt; 箱&lt;/div&gt;&lt;div class=&quot;dragbox&quot;&gt; &lt;div class=&quot;draglist&quot; draggable=&quot;true&quot;&gt;列表1&lt;/div&gt; &lt;div class=&quot;draglist&quot; draggable=&quot;true&quot;&gt;列表2&lt;/div&gt; &lt;div class=&quot;draglist&quot; draggable=&quot;true&quot;&gt;列表3&lt;/div&gt; &lt;div class=&quot;draglist&quot; draggable=&quot;true&quot;&gt;列表4&lt;/div&gt; &lt;div class=&quot;draglist&quot; draggable=&quot;true&quot;&gt;列表5&lt;/div&gt; &lt;div class=&quot;draglist&quot; draggable=&quot;true&quot;&gt;列表6&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;dragremind&quot;&gt;&lt;/div&gt;&lt;script&gt;var eleDustbin = document.getElementById(&quot;dustbin&quot;), eleDrags = document.getElementsByClassName(&quot;draglist&quot;), lDrags = eleDrags.length, eleRemind = document.getElementById(&quot;dragremind&quot;), eleDrag = null;for (var i=0; i&lt;lDrags; i+=1) &#123; eleDrags[i].ondragstart = function(ev) &#123; ev.dataTransfer.effectAllowed = &quot;move&quot;; ev.dataTransfer.setData(&quot;text&quot;, ev.target.innerHTML); ev.dataTransfer.setDragImage(ev.target, 0, 0); eleDrag = ev.target; &#125;; eleDrags[i].ondragend = function(ev) &#123; ev.dataTransfer.clearData(&quot;text&quot;); eleDrag = null; &#125;;&#125;eleDustbin.ondragover = function(ev) &#123; ev.preventDefault();&#125;;eleDustbin.ondragenter = function(ev) &#123; this.style.color = &quot;#ffffff&quot;;&#125;;eleDustbin.ondrop = function(ev) &#123; if (eleDrag) &#123; eleRemind.innerHTML += &apos;&lt;strong&gt;&quot;&apos; + eleDrag.innerHTML + &apos;&quot;&lt;/strong&gt;被扔进了垃圾箱&lt;br&gt;&apos;; eleDrag.parentNode.removeChild(eleDrag); &#125; this.style.color = &quot;#000000&quot;;&#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接纳对象【示例2】本例设计一个简单的方形盒子，允许用户通过鼠标拖拽方形盒子，并允许将它拖入不同的容器中。12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;style&gt;#demo1 &#123; margin: 20px; &#125;#demo1 .panel-list &#123; overflow: hidden; list-style: none; margin: 0; padding: 0; &#125;#demo1 .panel-item &#123; float: left; margin-right: 30px; width: 100px; height: 100px; background: #ddd; border: 1px solid #ddd; &#125;#demo1-src &#123; display: inline-block; width: 50px; height: 50px; background: purple; &#125;#demo1 .over &#123; border: 1px dashed #000; -webkit-transform: scale(0.8, 0.8); &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;demo1&quot;&gt; &lt;ul class=&quot;panel-list&quot;&gt; &lt;li class=&quot;panel-item&quot;&gt;&lt;/li&gt; &lt;li class=&quot;panel-item&quot;&gt;&lt;/li&gt; &lt;li class=&quot;panel-item&quot;&gt;&lt;/li&gt; &lt;li class=&quot;panel-item&quot;&gt;&lt;/li&gt; &lt;li class=&quot;panel-item&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;拖拽下面的方块到上面任意容器中&lt;/h2&gt; &lt;!-- 设置draggable使元素成为可拖拽元素 --&gt; &lt;span class=&quot;movable&quot; id=&quot;demo1-src&quot; draggable=&quot;true&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;script&gt; var src=document.getElementById(&apos;demo1-src&apos;); var desc=document.getElementsByClassName(&apos;panel-item&apos;); for(var i=0,len=desc.length;i&lt;len;i++)&#123; desc[i].ondragover=function(e)&#123; e.preventDefault(); &#125;; desc[i].ondrop=function(e)&#123; this.appendChild(src); &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 拖选照片【示例3】本例设计一个照片可视化拖选操作，允许用户通过鼠标拖拽照片，并允许把它拖入不同目标容器中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;HTML5实现拖拽操作&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;style&gt;.album &#123; border: 3px dashed #ccc; float: left; margin: 10px; min-height: 200px; padding: 10px; width: 350px; &#125;.album img &#123; width: 100px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;info&quot;&gt; &lt;h2&gt;温馨提示：可将照片直接拖到已选容器中&lt;/h2&gt;&lt;/div&gt;&lt;div id=&quot;album&quot; class=&quot;album&quot;&gt; &lt;h2&gt;备选相册&lt;/h2&gt; &lt;img draggable=&quot;true&quot; id=&quot;img1&quot; src=&quot;images/1.png&quot; /&gt; &lt;img draggable=&quot;true&quot; id=&quot;img2&quot; src=&quot;images/2.png&quot; /&gt; &lt;img draggable=&quot;true&quot; id=&quot;img3&quot; src=&quot;images/3.png&quot; /&gt;&lt;/div&gt;&lt;div id=&quot;selected&quot; class=&quot;album&quot;&gt; &lt;h2&gt;已选照片&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; function init()&#123; var info = document.getElementById(&quot;info&quot;); //获得被拖放的元素，本示例为相册所在的DIV var src = document.getElementById(&quot;album&quot;); //开始拖放操作 src.ondragstart = function (e) &#123; //获得被拖放的照片ID var dragImgId = e.target.id; //获得被拖动元素 var dragImg = document.getElementById(dragImgId); e.dataTransfer.setData(&quot;text&quot;,dragImgId); &#125;; //拖放过程中 src.ondrag = function(e)&#123; info.innerHTML=&quot;&lt;h2&gt;--照片正在被拖动--&lt;/h2&gt;&quot;; &#125; //获得拖放的目标元素 var target = document.getElementById(&quot;selected&quot;); target.ondragover = function(e)&#123; e.preventDefault(); &#125; //有东西拖放到了目标元素 target.ondrop = function (e) &#123; var draggedID = e.dataTransfer.getData(&quot;text&quot;); //获取相册中的DOM对象 var oldElem = document.getElementById(draggedID); //从相册DIV中删除该照片的节点 oldElem.parentNode.removeChild(oldElem); //将被拖动的照片DOM节点添加到垃圾桶DIV中； target.appendChild(oldElem); info.innerHTML=&quot;&lt;h2&gt;温馨提示：可将照片直接拖到垃圾箱中&lt;/h2&gt;&quot;; // e.preventDefault(); &#125; &#125; init()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 扔入垃圾桶【示例4】本示例设计一个文档元素删除操作，允许用户通过鼠标拖拽页面底部的图片，并允许把它拖入不同垃圾桶中删除。12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;style&gt;body &#123; text-align: center; &#125;#trash &#123; opacity: .2; margin: 15px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;拖动飞机到垃圾桶后从DOM树中删除元素&lt;/h3&gt;&lt;img id=&quot;trash&quot; src=&quot;images/trash.png&quot;&gt;&lt;hr/&gt;&lt;img id=&quot;p3&quot; class=&quot;src&quot; src=&quot;images/1.png&quot;&gt;&lt;img id=&quot;p4&quot; class=&quot;src&quot; src=&quot;images/2.png&quot;&gt;&lt;img id=&quot;p5&quot; class=&quot;src&quot; src=&quot;images/3.png&quot;&gt; &lt;script&gt; //为源对象添加事件监听 —— 记录拖动了哪一个源对象 var srcList = document.querySelectorAll(&apos;.src&apos;);//找到全部img元素 for(var i=0; i&lt;srcList.length; i++)&#123; //遍历img元素 var p = srcList[i]; p.ondragstart = function(e)&#123; //开始拖动源对象 e.dataTransfer.setData(&apos;PlaneID&apos;,this.id);//保存数据--该img元素的id &#125; &#125; //为目标对象添加事件监听 —— 删除拖动的源对象 trash.ondragenter = function()&#123; //源对象进入目标对象 trash.style.opacity = &quot;1&quot;; //将透明度变成1 &#125; trash.ondragleave= function()&#123; //源对象离开目标对象后 trash.style.opacity = &quot;.2&quot;; //将透明度变为0.2 &#125; trash.ondragover= function(e)&#123; //源对象在悬停在目标对象上时 e.preventDefault(); //阻止默认行为，使得drop可以触发 &#125; trash.ondrop= function(e)&#123; //源对象松手释放在了目标对象中 trash.style.opacity = &quot;.2&quot;; //将透明度变为0.2 //删除被拖动的源对象 var id = e.dataTransfer.getData(&apos;PlaneID&apos;);//得到数据--id值 var p = document.getElementById(id); //根据id值找到相关的元素 p.parentNode.removeChild(p); //从父元素中删除子节点 &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>drag API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5表单]]></title>
    <url>%2F2018%2F01%2F07%2F%E5%A2%9E%E5%BC%BAHTML5%E8%A1%A8%E5%8D%95%E5%92%8C%E9%A1%B5%E9%9D%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[HTML5吸纳了Web Forms 2.0标准，大幅增强了针对表单元素的功能，使关于表单的开发更快、更方便。 HTML5 input类型在Web应用开发过程中，表单是页面上非常重要的一项内容，用户可以输入的大部分内容都是在表单上完成的，客户端与服务器端的交互在大多数情况下也是通过表单完成的。 HTML5之前支持的input输入类型（name属性是用于提交给服务器来使用的，服务器不识别id属性） &lt;input type=’text’&gt;定义单行输入字段，用于在表单中输入字母、数字等内容，默认宽度为20个字符。 &lt;input type=’radio’&gt;定义单选按钮，一组单选按钮应该具有相同的name属性值。 &lt;input type=’checkbox’&gt;定义复选框，用于从给定的选择中选取一个或若干选项。一组复选框应该具有相同的name属性值。 &lt;input type=’password’&gt;定义密码框，输入的内容会以点或星号的形式出现。 &lt;input type=submit’&gt;定义提交按钮，用于将表单数据发送到服务器。 &lt;input type=’reset’&gt;定义重置按钮，用户可以单击重置按钮以清除表单中的所有数据。 &lt;input type=’image’&gt;定义图像形式的提交按钮，用户可以通过选择不同的图像来自定义这种按钮的样式。需配合src属性使用。 &lt;input type=’file’&gt;定义输入字段和‘浏览’按钮，用于文件上传。 &lt;input type=’hidden’&gt;定义隐藏的输入字段。一般需配合后台开发使用。 &lt;input type=’button’&gt;定义普通的可点击按钮。HTML5新增的表单类型 &lt;input type=’email’&gt;email类型的input元素是一种专门用于输入Email地址的文本框，在提交表单的时候，会自动验证Email输入框的值。如果不是一个有效的电子邮件地址，则该输入框不允许提交该表单。对于不支持type= ‘email’的浏览器,会以type=’text’的形式来处理。 &lt;input type=’url’&gt;url类型的input元素提供用于输入url地址这类特殊文本的文本框。当提交表单时，如果所输入的内容不是url地址格式的文本，则不允许提交。对于不支持type= ‘url’的浏览器,会以type=’text’的形式来处理。 &lt;input type=’number’&gt;number类型的input元素提供用于输入数值的文本框。用户还可以设定对所接受的数字的限制，包括规定允许的最大值和最小值、合法的数字间隔和默认值等。如果所输入的数字不在限定的范围内，则会出现错误提示。属性：max：规定允许的最大值min：规定允许的最小值step：规定合法的数字间隔（如果step=’4’,则合法的数字时-4,0,4,8等）value：规定默认值 &lt;input type=’range’&gt;range类型的input元素提供用于输入包含一定范围内数字值的文本框，在网页中显示为滑动条。用户还可以设定对所接受的数字的限制，包括规定允许的最大值和最小值、合法的数字间隔或默认值等。如果所输入的数字不在限定范围之内，则会出现错误提示。range类型的属性与number类型的属性完全相同，这两种类型的区别仅在于外观上。 &lt;input type=’search’&gt;search类型的input元素提供用于输入搜索关键词的文本框。在外观上来看，search类型的input元素与普通的text类型只是稍有区别，但是如果在搜索框中输入要搜索的关键词，在搜索框的右侧会出现一个’x’按钮（Firefox不支持）。 &lt;input type=’tel’&gt;tel类型的input元素提供专门用来输入电话号码的文本框。它并不限定只输入数字，因为很多的电话号码还包括其它字符（如：86-0536-8888888）。实际上与type=’text’是一样的，但是移动端的浏览器在唤醒键盘的时候可能会改变键盘屏幕方便用户输入。 &lt;input type=’color’&gt;color类型的input元素提供专门用于输入颜色的文本框。当color类型的文本框获取焦点后，会自动调用系统的颜色接口。 &lt;input type=’date’&gt;date类型的日期选择器用于选取日、月、年，即选择一个具体的日期。 &lt;input type=’month’&gt;month类型的日期选择器用于选取月、年，即选择一个具体的月份。 &lt;input type=’week’&gt;week类型的日期选择器用于选取周和年，即选择一个具体的周。 &lt;input type=’time’&gt;time类型的日期选择器用于选取时间，具体到小时和分钟。 &lt;input type=’datetime’&gt;datetime类型的日期选择器用于选取时间、日、月、年，其中时间为UTC时间。很多浏览器已不提供对它的支持。 &lt;input type=’datetime-local’&gt;datetime-local类型的日期选择器用于选取时间，日，月、年，其中时间为本地时间。HTML5 input属性 autocomplete属性多数浏览器都带有辅助用户完成输入的自动完成功能，只要开启了该功能，用户在下次输入相同的内容时，浏览器就会自动完成内容的输入。HTML5新增的autocomplete属性可以帮助用户在input类型的输入框中自动完成内容输入。这些input类型包括：text、search、url、tel、password、date pickers、range以及color。不过在某些浏览其中可能需要首先启用浏览器的自动完成功能，才能使complete属性生效。autocomplete属性同样适用于form标签，默认状态下表单的autocomplete属性是处于打开状态的，其中的输入类型继承所在表单的autocomplete状态。用户也可以单独将表单中某输入类型的autocomplete状态设置为打开状态。autocomplete属性有两个值：on和off。【示例1】本例将表单的autocomplete属性设置为on，而单独将其中某一输入类型的autocomplete属性值设置为off。1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/formexample.asp&quot; method=&quot;get&quot; autocomplete=&quot;on&quot;&gt;姓名：&lt;input type=&quot;text&quot; name=&quot;name1&quot; /&gt;&lt;br /&gt;职业：&lt;input type=&quot;text&quot; name=&quot;career1&quot; /&gt;&lt;br /&gt;电子邮件地址：&lt;input type=&quot;email&quot; name=&quot;email1&quot; autocomplete=&quot;off&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=”提交信息” /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 【示例2】本例使用autocomplete属性、datalist标签及list属性实现自动完成。123456789101112131415161718&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;输入你最喜欢的城市名称&lt;/h2&gt;&lt;form autocompelete=&quot;on&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;city&quot; list=&quot;cityList&quot;&gt; &lt;datalist id=&quot;cityList&quot; style=&quot;display:none;&quot;&gt; &lt;option value=&quot;BeiJing&quot;&gt;BeiJing&lt;/option&gt; &lt;option value=&quot;QingDao&quot;&gt;QingDao&lt;/option&gt; &lt;option value=&quot;QingZhou&quot;&gt;QingZhou&lt;/option&gt; &lt;option value=&quot;QingHai&quot;&gt;QingHai&lt;/option&gt; &lt;/datalist&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在本例中，当用户将焦点定位到文本框中，会自动出现一个城市列表供用户选择。而当用户点击页面其它位置的时候，这个列表就会消失。此外，当用户输入时，该列表会随用户的输入进行更新，例如：当输入字母q时，只列出以q开头的城市名称。 autofocus属性HTML5 新增了autofocus属性，它可以实现在页面加载时，某表单控件自动获得焦点，这些控件可以是文本框、复选框、单选按钮、普通按钮等所有input标签的类型。在同一个页面中只能指定一个autofocus属性值。【示例2】如果浏览器不支持autofocus属性，则会将其忽略掉。因此要使得所有浏览器都能实现自动获得焦点，可以在Javascript脚本中加一小段脚本，以检测浏览器是否支持autofocus属性。 123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;p&gt;请仔细阅读许可协议：&lt;/p&gt; &lt;p&gt; &lt;label for=&quot;textarea1&quot;&gt;&lt;/label&gt; &lt;textarea name=&quot;textarea1&quot; id=&quot;textarea1&quot; cols=&quot;45&quot; rows=&quot;5&quot;&gt;许可协议具体内容......&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt; &lt;input id=&quot;ok&quot; type=&quot;submit&quot; value=&quot;同意&quot; autofocus&gt; &lt;input type=&quot;submit&quot; value=&quot;拒绝&quot; &gt; &lt;/p&gt;&lt;/form&gt;&lt;script&gt;if (!(&quot;autofocus&quot; in document.createElement(&quot;input&quot;))) &#123; document.getElementById(&quot;ok&quot;).focus();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; form属性在HTML5之前，用户要提交一个表单，必须把相关的空间元素都放在表单内部。在提交表单时，form标签以外的控件都将被忽略。HTML5新增了一个form属性，可以把表单内的从属元素写在页面上的任何一个位置，然后只要为这个元素指定一下form属性并为其指定属性值为该表单的id。如此一来，便规定了该表单元素属于指定的这一个表单。此外，form属性也允许规定一个表单元素从属于多个表单。form属性适用于所有input类型的输入框。【示例3】下面是一个form属性的应用示例。 1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;get&quot; id=&quot;form1&quot;&gt;请输入姓名：&lt;input type=&quot;text&quot; name=&quot;name1&quot; autofocus/&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;&lt;p&gt;下面的输入框在form元素之外，但因为指定的form属性，并且值为表单的id，所以该输入框仍然是表单的一部分。&lt;/p&gt;请输入住址：&lt;input type=&quot;text&quot; name=&quot;address1&quot; form=&quot;form1&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 如果一个form属性要引用两个或两个以上的表单，则需要使用空格将表单的id分隔开。&lt;input type=&#39;text&#39; form=&#39;form1 form2&#39;/&gt; 表单重写属性HTML5 新增了很多表单重写属性，用于重写form表单的某些属性设定。 formaction：用于重写表单的action属性 formenctype：用于重写表单的enctype属性 formmethod：用于重写表单的method属性 formnovalidate：用于重写表单的novalidate属性 formtarget：用于重写表单的target属性。表单重写属性只适用于submit和image输入类型。【示例4】在HTML5之前，只能使用表单的action属性将表单内的所有元素同一提交到另一个页面。而使用formaction属性，则可以通过重写表单的action属性，实现将表单提交到不同的页面中去。1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;1.asp&quot; id=&quot;testform&quot;&gt;请输入电子邮件地址： &lt;input type=&quot;email&quot; name=&quot;userid&quot; /&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交到页面1&quot; formaction=&quot;1.asp&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交到页面2&quot; formaction=&quot;2.asp&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交到页面3&quot; formaction=&quot;3.asp&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; height和width属性height和width属性设置image类型的input标签的图像高度和宽度，这两个属性只适用于image类型的input标签。【示例5】下面是height和width属性应用的示例代码。 123456789101112&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;testform.asp&quot; method=&quot;get&quot;&gt;请输入用户名: &lt;input type=&quot;text&quot; name=&quot;user_name&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;image&quot; src=&quot;images/submit.png&quot; width=&quot;720&quot; height=&quot;26&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; list属性HTML5 新增了一个datalist元素，可以实现数据列表下拉效果。而list属性用于指定输入框绑定哪一个datalist元素，其值是某个datalist的id。【示例6】下面是list属性的应用示例代码。 123456789101112131415161718&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;testform.asp&quot; method=&quot;get&quot;&gt; 请输入网址： &lt;input type=&quot;url&quot; list=&quot;url_list&quot; name=&quot;weblink&quot; /&gt; &lt;datalist id=&quot;url_list&quot;&gt; &lt;option label=&quot;新浪&quot; value=&quot;http://www.sina.com.cn&quot; /&gt; &lt;option label=&quot;搜狐&quot; value=&quot;http://www.sohu.com&quot; /&gt; &lt;option label=&quot;网易&quot; value=&quot;http://www.163.com&quot; /&gt; &lt;/datalist&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; min、max和step属性HTML5新增min、max和step属性，用于为包含数字或日期的input输入类型设置限值，也就是给这些类型的输入框加一个数值的约束，适用于date pickers、number和range标签。min属性：设置输入框所允许的最小值max属性：设置输入框所允许的最大值step属性：为输入框设置合法的数字间隔，例如step=’4’，则合法的数值是-4,0,4等。【示例7】本例中，显示一个数字输入框，并规定输入框接受0~12范围的值，且数字间隔为4，即合法的值为0,4,8,12。 12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;testform.asp&quot; method=&quot;get&quot;&gt; 请输入数值： &lt;input type=&quot;number&quot; name=&quot;number1&quot; min=&quot;0&quot; max=&quot;12&quot; step=&quot;4&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; multiple属性在HTML5之前，input输入类型中的file类型只支持选择单个文件来上传，而新增的multiple属性支持一次性选择多个文件，并且该属性同样支持新增的email类型。【示例8】下面是一个multiple属性的示例。 12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;testform.asp&quot; method=&quot;get&quot;&gt; 请选择要上传的多个文件： &lt;input type=&quot;file&quot; name=&quot;img&quot; multiple /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; pattern属性pattern属性用于验证input类型输入框中用户输入的内容是否与自定义的正则表达式相匹配，该属性适用于以下类型的input标签：text、search、url、tel、email、password。pattern属性允许用户自定义一个正则表达式，而用户的输入必须符合正则表达式所指定的规则。pattern属性中的正则表达式语法与Javascript中的正则表达式语法相匹配。【示例9】该示例的文本框规定必须输入六位数的邮政编码。 1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/testform.asp&quot; method=&quot;get&quot;&gt; 请输入邮政编码: &lt;input type=&quot;text&quot; name=&quot;zip_code&quot; pattern=&quot;[0-9]&#123;6&#125;&quot;title=&quot;请输入6位数的邮政编码&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; placeholder属性placeholder属性用于为input类型的输入框提供一种提示，这些提示可以描述输入框期待用户输入何种内容，在输入框为空时显式出现，而当输入框获得焦点时则会消失。placeholder属性适用于以下了类型的input标签：text、search、url、tel、email、password。【示例10】下面的例子演示placeholder的用法。 1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/testform.asp&quot; method=&quot;get&quot;&gt; 请输入邮政编码: &lt;input type=&quot;text&quot; name=&quot;zip_code&quot; pattern=&quot;[0-9]&#123;6&#125;&quot;placeholder=&quot;请输入6位数的邮政编码&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; required属性新增的required属性用于定义输入框填写的内容不能为空，否则不允许用户提交表单。该属性适用于以下的input输入类型：text、search、url、tel、email、password、number、date pickers、number、checkbox、radio、file。【示例11】下面是required属性的一个应用示例。该示例的文本框必须输入内容，否则表单不能被提交。 12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/testform.asp&quot; method=&quot;get&quot;&gt; 请输入姓名: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; required=&quot;required&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 新表单控件 datalist元素datalist元素用于为输入框提供一个可选的列表，用户可以直接选择列表中的某一预设的项，从而避免输入的麻烦。该列表由datalist中的option元素创建。如果用户不希望从列表中选择某项，也可以自行输入其它的内容。在实际应用中，如果要把datalist提供的列表绑定到某输入框，则需要使用输入框的list属性来引用datalist元素的id。注意：每个option元素都必须设置一个value值。 123456789101112131415161718&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;testform.asp&quot; method=&quot;get&quot;&gt; 请输入网址： &lt;input type=&quot;url&quot; list=&quot;url_list&quot; name=&quot;weblink&quot; /&gt; &lt;datalist id=&quot;url_list&quot;&gt; &lt;option label=&quot;新浪&quot; value=&quot;http://www.sina.com.cn&quot; /&gt; &lt;option label=&quot;搜狐&quot; value=&quot;http://www.sohu.com&quot; /&gt; &lt;option label=&quot;网易&quot; value=&quot;http://www.163.com&quot; /&gt; &lt;/datalist&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; keygen元素keygen是秘钥对生成器，能够使得用户验证更加可靠。用户提交表单时会生成两个键：一个私钥，一个公钥。其中私钥会被存储在客户端，而公钥则会被发送到服务器。公钥可以用于之后验证用户的客户端证书。【示例1】下面是一个keygen元素的应用示例。 1234567891011121314151617&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/testform.asp&quot; method=&quot;get&quot;&gt; 请输入用户名: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt; &lt;br&gt; 请选择加密强度: &lt;keygen name=&quot;security&quot; /&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 不同浏览器的支持情况不一致。 output元素output元素用于在浏览器中显示计算结果或脚本输出，包含完整的开始和结束标签。【示例1】该示例计算用户输入的两个数字的乘积。12345678910111213141516171819&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; function multi()&#123; a=parseInt(prompt(&quot;请输入第1个数字。&quot;,0)); b=parseInt(prompt(&quot;请输入第2个数字。&quot;,0)); document.forms[&quot;form&quot;][&quot;result&quot;].value=a*b; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;multi()&quot;&gt;&lt;form action=&quot;testform.asp&quot; method=&quot;get&quot; name=&quot;form&quot;&gt; 两数的乘积为: &lt;output name=&quot;result&quot;&gt;&lt;/output&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; output元素不会出现边框效果。 新表单属性 autocomplete属性 novalidate属性form元素的novalidate属性用于在提交表单时取消整个表单的验证，即关闭对表单内所有元素的有效性检查。如果要只取消表单中较少部分的验证而不妨碍提交大部分内容，则可以将novalidate属性单独用于form中的这些元素。【示例1】下面是novalidate属性的一个应用示例。该示例中取消了整个表单的验证。 12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;testform.asp&quot; method=&quot;get&quot; novalidate&gt; 请输入电子邮件地址: &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 显式验证除了为input元素新增属性，以便对输入内容进行自动验证外，HTML5为form、input、select和textarea元素都定义了一个checkValidity()方法。调用该方法，可以显示地对表单内所有元素内容或单个元素内容进行有效性验证。checkValidity()方法将返回一个布尔值，以提示是否通过验证。【示例2】本示例使用checkValidity()方法，主动验证用户输入的Email地址是否有效。 1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script&gt;function check()&#123; var email = document.getElementById(&quot;email&quot;); if(email.value==&quot;&quot;)&#123; alert(&quot;请输入Email地址&quot;); return false; &#125; else if(!email.checkValidity())&#123; alert(&quot;请输入正确的Email地址&quot;); return false; &#125; else alert(&quot;您输入的Email地址有效&quot;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form id=&apos;testform&apos; onsubmit=&quot;check();&quot; novalidate&gt; &lt;label for=&apos;email&apos;&gt;Email&lt;/label&gt; &lt;input name=&apos;email&apos; id=&apos;email&apos; type=&apos;email&apos; /&gt; &lt;br/&gt; &lt;input type=&apos;submit&apos;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在HTML5中，form和input元素都有一个validity属性，该属性返回一个ValidityState对象，该对象有一个valid属性，它表示表单内所有元素内容是否有效或单个input元素内容是否有效。 新增页面元素 figure和figcaption元素figure元素可以定义独立的流内容，如图像、图表、照片、代码等。figure元素的内容应该与主页面的内容相关，但如果被删除，则不应对文档流产生影响。figure元素是一种元素的组合，带有可选标题。figcaption元素表示figure元素的标题，它从属于figure元素，必须书写在figure元素的内部，可以书写在figure元素内的其它从属元素的前面或后面。一个figure元素内最多只允许放一个figcaption元素。【示例1】本例设计一个不带标题的figure元素。1234567891011&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;figure&gt; &lt;img src=&quot;images/1.png&quot; alt=&quot;学生&quot;&gt;&lt;/figure&gt;&lt;/body&gt;&lt;/html&gt; 【示例2】本例设计一个带标题的figure元素。123456789101112&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;figure&gt; &lt;img src=&quot;images/1.png&quot; alt=&quot;学生&quot;&gt; &lt;figcaption&gt;中学生&lt;/figcaption&gt;&lt;/figure&gt;&lt;/body&gt;&lt;/html&gt; 【示例3】本例设计为多幅图片设计一个标题。1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;figure&gt; &lt;img src=&quot;images/1.png&quot; height=&quot;300&quot; alt=&quot;学生&quot;&gt; &lt;img src=&quot;images/2.png&quot; height=&quot;300&quot; alt=&quot;学生&quot;&gt; &lt;img src=&quot;images/3.png&quot; height=&quot;300&quot; alt=&quot;学生&quot;&gt; &lt;figcaption&gt;中学生&lt;/figcaption&gt;&lt;/figure&gt;&lt;/body&gt;&lt;/html&gt; figure元素的内容通常是图片、统计图或代码示例。 details和summary元素details元素用于描述文档或文档某个部分的细节，被details表示的内容可以展开、收缩显示。details元素内可以包含文字、表单、插件或表格等任何超文本信息。该元素新增一个布尔类型的open属性，当该属性设置为true时，其包含的子元素应该展开显示；当该属性值为false时，其包含的子元素应该索索起来不显示。open属性的默认值为false，页面打开时，其内部的子元素默认是收缩状态的。summary元素时details元素的子元素，可以为details定义标题，标题是可见的，用户点击标题时，会显示出details的详细信息。【示例1】本例演示了details和summary元素配合使用，设计折叠面板的效果。123456789101112&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;details&gt; &lt;summary&gt;学生&lt;/summary&gt; &lt;p&gt;&lt;img src=&quot;images/1.png&quot; alt=&quot;学生&quot;&gt;&lt;/p&gt;&lt;/details&gt;&lt;/body&gt;&lt;/html&gt; 【示例2】如果details元素内没有summary元素，浏览器会提供默认的文字以供单击。1234567891011&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;details&gt; &lt;p&gt;&lt;img src=&quot;images/1.png&quot; alt=&quot;学生&quot;&gt;&lt;/p&gt;&lt;/details&gt;&lt;/body&gt;&lt;/html&gt; 当details元素的状态从展开切换为收缩，或从收缩切换到展开时，会触发toggle事件。【示例3】本例设计当用户切换details元素显示或隐藏显示时，取消summary元素轮廓效果，并给details元素包含的内容加一个边框。1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;details id=&quot;detail&quot;&gt; &lt;summary&gt;学生&lt;/summary&gt; &lt;p id=&quot;p&quot;&gt;&lt;img src=&quot;images/1.png&quot; alt=&quot;学生&quot; height=&quot;200&quot;&gt;&lt;/p&gt;&lt;/details&gt;&lt;script&gt;var detail=document.getElementById(&apos;detail&apos;);var p=document.getElementById(&apos;p&apos;);var summary=detail.getElementsByTagName(&apos;summary&apos;)[0];detail.ontoggle = function()&#123; if(this.open)&#123; p.style.border=&quot;solid 2px red&quot;; summary.style.outline=&quot;none&quot;; &#125;else&#123; p.style.border=&quot;solid 2px #fff&quot;; &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; mark元素mark元素用来定义带有标记的文本，它表示页面中需要突出显示或高亮显示的信息，对于当前用户具有参考意义的一段文字。通常在引用原文的时候使用mark元素，目的是引起当前用户的注意。【示例1】本例使用mark元素高亮显示对’HTML’关键词的搜索结果。12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;h2&gt;&lt;mark&gt;HTML5&lt;/mark&gt;中国:中国最大的&lt;mark&gt;HTML5&lt;/mark&gt;中文门户 - Powered by Discuz!官网&lt;/h2&gt; &lt;p&gt;&lt;mark&gt;HTML5&lt;/mark&gt;中国,是中国最大的&lt;mark&gt;HTML5&lt;/mark&gt;中文门户。为广大&lt;mark&gt;html5&lt;/mark&gt;开发者提供&lt;mark&gt;html5&lt;/mark&gt;教程、&lt;mark&gt;html5&lt;/mark&gt;开发工具、&lt;mark&gt;html5&lt;/mark&gt;网站示例、&lt;mark&gt;html5&lt;/mark&gt;视频、js教程等多种&lt;mark&gt;html5&lt;/mark&gt;在线学习资源。&lt;/p&gt; &lt;p&gt;www.html5cn.org/ - 百度快照 - 86%好评&lt;/p&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; mark元素还可以用于表示引用原文，为了某种特殊目的而把原文作者没有重点强调的内容标识出来。【示例2】本例使用mark元素将唐诗中的韵脚特意高亮显示出来。1234567891011121314&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;h2&gt;静夜思 &lt;/h2&gt; &lt;h3&gt;李白&lt;/h3&gt; &lt;p&gt;床前明月&lt;mark&gt;光&lt;/mark&gt;，疑是地上&lt;mark&gt;霜&lt;/mark&gt;。&lt;/p&gt; &lt;p&gt;举头望明月，低头思故&lt;mark&gt;乡&lt;/mark&gt;。&lt;/p&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 在HTML5之前，用户习惯使用em或strong元素来突出显示文字，但是mark元素的作用于这两个元素的作用是有区别的。mark元素的标示目的与原文作者无关，或者说它不是被原文作者用来标示文字的，而是后来被引用时添加上去的，它的目的是吸引当前用户的注意力，供用户参考。而strong是原文作者强调一段文字的重要性的，em是作者为了突出文章重点文字而使用的，表现为斜体。 progress元素progress元素定义任务的进度。这个进度可以是不确定的，表示进度正在进行，但不清楚还有多少进度没有完成，也可以用0到某个最大数字（如100）之间的数字来表示进度完成情况。progress元素包含两个新增属性，表示当前任务完成情况。max：定义任务一共需要多少工作量。单位随意，不用指定value：定义已经完成了多少任务在设置属性的时候，max和value的属性只能指定为有效的浮点数，value属性的值必须大于0、小于或等于max属性值，max属性的值必须大于0。【示例1】本例演示如何使用progress元素。12345678910111213141516171819&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;progress id=&apos;progress&apos; value=&quot;10&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; &lt;script type=&quot;text/javascript&quot;&gt; function move()&#123; var progress=document.getElementById(&apos;progress&apos;); if(progress.value&lt;=100)&#123; progress.value++; &#125;; requestAnimationFrame(move); &#125;; requestAnimationFrame(move); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; progress元素不适合用来表示度量衡，例如磁盘空间使用情况等。如需表示度量衡，可以使用meter元素。 meter元素meter元素定义已知范围或分数值内的标量测量。meter元素不应该用于指示进度。如果标记进度值，应该使用progress元素。属性：value：在元素中特别标识出来的实际值min：设置规定范围时，允许使用的最小值，默认为0，设定的值不能小于0max：设置规定范围时，允许使用的最大值。如果设定是，该属性值小于min属性的值，那么把min属性的值视为最大值。max属性的默认值为1。low:规定被视作低的值的范围high：规定被视作高的值的范围optimum：规定最优值form：规定meter元素所属的表单值当设置low和high属性时，value的值位于上下限的时候会显示不同的颜色。【示例1】本例简单演示meter元素的使用。 123456789101112&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;meter value=&apos;3&apos; min=&apos;0&apos; max=&apos;10&apos;&gt;&lt;/meter&gt;&lt;meter value=&quot;3&quot; min=&quot;0&quot; max=&quot;10&quot; high=&quot;8&quot; optimum=&quot;5&quot; low=&apos;4&apos;&gt;&lt;/meter&gt;&lt;meter value=&apos;0.1&apos;&gt;&lt;/meter&gt;&lt;meter value=&apos;3&apos;&gt;&lt;/meter&gt;&lt;/body&gt;&lt;/html&gt; dialog元素dialog元素定义对话框或窗口。在默认状态下，dialog元素处于隐藏状态，可以在Javascript脚本中使用show()方法显示dialog元素，可以使用close()方法隐藏dialog元素。【示例1】本例演示了一个打开的对话框。 123456789&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;dialog open&gt;打开的对话框&lt;/dialog&gt;&lt;/body&gt;&lt;/html&gt; 【示例2】本例演示如何使用Javascript脚本控制对话框的显示或隐藏。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;style&gt;#dg &#123; width: 60%; text-align: center; &#125;#dg label &#123;display:block; margin:6px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;打开对话框&quot;&gt;&lt;dialog id=&quot;dg&quot;&gt; &lt;h2&gt;用户登录&lt;/h2&gt; &lt;main&gt; &lt;form&gt; &lt;label for=&quot;txtName&quot; value=&quot;用户名：&quot;/&gt; &lt;input type=&quot;text&quot; id=&quot;txtName&quot;/&gt; &lt;/label&gt; &lt;label for=&quot;txtPassword&quot; value=&quot;密 码：&quot;/&gt; &lt;input type=&quot;password&quot; id=&quot;txtPassword&quot; autofocus/&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;登 录&quot; /&gt; &lt;input id=&quot;cls&quot; type=&quot;button&quot; value=&quot;关 闭&quot; /&gt; &lt;/form&gt; &lt;/main&gt;&lt;/dialog&gt;&lt;script&gt;var btn = document.getElementById(&quot;btn&quot;);var dg = document.getElementById(&quot;dg&quot;);var cls = document.getElementById(&quot;cls&quot;);btn.onclick = function()&#123; dg.showModal(); dg.returnValue=&apos;对话框的值&apos;;&#125;cls.onclick = function()&#123; dg.close(); console.log( dg.returnValue );&#125;dg.onclose = function()&#123; console.log(&apos;对话框被关闭&apos;);&#125;dg.oncancel = function()&#123; console.log(&apos;用户在模态窗口中按下Esc键&apos;);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; dialog元素的showModal()方法以模式对话框的形式显示dialog元素；如果要在页面打开时即显示dialog元素，可以使用dialog元素的open属性；可以使用dialog元素的returnValue属性为对话框设置或返回一个返回值。]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表单]]></title>
    <url>%2F2018%2F01%2F06%2FHTML%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[HTML表单用于搜索不同类型的用户输入。 表单标签form 标签用于为用户输入创建 HTML 表单。表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等等。表单还可以包含 menus、textarea、fieldset、legend 和 label 元素。表单用于向服务器传输数据。form 元素是块级元素，其前后会产生折行。 fieldset&lt;fieldset>标签用于从逻辑上将表单中的元素组合起来。使用&lt;fieldset> 标签会在相关表单元素周围绘制边框，使用&lt;legend> 标签为 fieldset 元素定义标题。12345678&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;Personalia:&lt;/legend&gt; Name: &lt;input type=&quot;text&quot; /&gt;&lt;br /&gt; Email: &lt;input type=&quot;text&quot; /&gt;&lt;br /&gt; Date of birth: &lt;input type=&quot;text&quot; /&gt; &lt;/fieldset&gt;&lt;/form&gt; selectselect 元素可创建单选或多选菜单。&lt;select> 元素中的 &lt;option> 标签用于定义列表中的可用选项。123456&lt;select&gt; &lt;option value =&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value =&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;opel&quot;&gt;Opel&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt;&lt;/select&gt; &lt;optgroup>定义选项组,当您使用一个长的选项列表时，对相关的选项进行组合会使处理更加容易。optgroup标签的label属性用于选项组的名称。` Volvo Saab Mercedes Audi ` textarea&lt;textarea> 标签定义多行的文本输入控件。文本区中可容纳无限数量的文本，可以通过 cols 和 rows 属性来规定 textarea 的尺寸。 inputinput标签的详细内容参考“增强HTML5表单和页面功能”的内容。 label&lt;label> 标签为 input 元素定义标注（标记）。label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。 &lt;label> 标签的 for 属性应当与相关元素的 id 属性相同。 button&lt;button> 标签定义一个按钮。在 button 元素内部，您可以放置内容，比如文本或图像。 控件 与 相比，提供了更为强大的功能和更丰富的内容。 与 标签之间的所有内容都是按钮的内容，其中包括任何可接受的正文内容，比如文本或多媒体内容。例如，我们可以在按钮中包括一个图像和相关的文本，用它们在按钮中创建一个吸引人的标记图像。请始终为按钮规定 type 属性。 表单属性form属性accept-charset:规定服务器可处理的表单数据字符集action:规定当提交表单时向何处发送表单数据autocomplete:规定是否启用表单的自动完成功能enctype:规定在发送表单数据之前如何对其进行编码取值： application/x-www-form-urlencoded 在发送前编码所有字符（默认）,（空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值） multipart/form-data,不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 text/plai,空格转换为 “+” 加号，但不对特殊字符编码。method: 规定用于发送 form-data 的 HTTP 方法。取值： get：提交的数据量要小于1024字节，表单提交时表单域数值（表单请求的信息：账号、密码…）将在地址栏显示 post：传递的数据量不受限制，表单提交时表单的域值（表单请求的信息：账号、密码…）不会在地址栏显示，安全性能较高，对信息进行了隐藏，一般在开发中采用postname：规定表单的名称novalidate：如果使用该属性，则提交表单时不进行验证target：规定在何处打开action URL取值： _blank，在新窗口打开 _self，在相同框架下打开，默认 _parent，在父框架集中打开 _top，在整个窗口中打开 framename，在指定的框架中打开select属性autofocus：规定在页面加载后文本区域自动获得焦点disabled：规定禁用该下拉列表form：规定文本区域所属的一个或多个表单multiple：规定可选择多个选项name：规定下拉列表的名称required：规定文本区域是必填的size：规定下拉列表中可见选项的数目option属性disabled，规定此选项应在首次加载时被禁用selected，规定选项（在首次显示在列表中时）表现为选中状态value，定义送往服务器的选项值label,没什么大用处textarea属性autofocus，规定在页面加载后文本区域自动获得焦点cols，规定文本区内的可见宽度disabled，规定禁用该文本区form，规定文本区域所属的一个或多个表单maxlength，规定文本区域的最大字符数name，规定文本区的名称placeholder，规定描述文本区域预期值的简短提示readonly，规定文本区为只读required，规定文本区域是必填的rows，规定文本区内的可见行数wrap，规定当在表单中提交时，文本区域（text area）中的文本如何换行。取值： hard，当在表单中提交时，textarea 中的文本换行（包含换行符）。当使用 “hard” 时，必须规定 cols 属性。 soft，当在表单中提交时，textarea 中的文本不换行。默认值。label属性for：规定label 绑定到哪个表单元素form：规定 label 字段所属的一个或多个表单button属性autofocus,规定当页面加载时按钮应当自动地获得焦点disabled,规定应该禁用该按钮form,规定按钮属于一个或多个表单formaction,覆盖 form 元素的 action 属性formenctype,覆盖 form 元素的 enctype 属性formmethod,覆盖 form 元素的 method 属性formnovalidate覆盖 form 元素的 novalidate 属性formtarget,覆盖 form 元素的 target 属性。name,规定按钮的名称type,规定按钮的类型取值： button，普通按钮 reset，重置按钮 submit，提交按钮value：规定按钮的初始值，可由脚本进行修改。如果在 HTML 表单中使用 button 元素，不同的浏览器会提交不同的值。Internet Explorer 将提交 与 之间的文本，而其他浏览器将提交 value 属性的内容。请在 HTML 表单中使用 input 元素来创建按钮。]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>form</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表格]]></title>
    <url>%2F2018%2F01%2F05%2FHTML%20%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[表格由 &lt;table> 标签来定义。每个表格均有若干行（由 &lt;tr> 标签定义），每行被分割为若干单元格（由 &lt;td> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。【示例1】本例演示一个最简单的表格。12345678910&lt;table&gt; &lt;tr&gt; &lt;td&gt;row1,col1&lt;/td&gt; &lt;td&gt;row1,col2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,col1&lt;/td&gt; &lt;td&gt;row2,col2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格标签&lt;table>、&lt;tr>、&lt;td>&lt;table>、&lt;tr>、&lt;td>标签是表格的基础，分别用来定义表格、定义表格的行、定义表格的列。 &lt;capition>&lt;capition>标签用来定义表格的标题。caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。1234567891011&lt;table&gt; &lt;caption&gt;表格的标题&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;row1,col1&lt;/td&gt; &lt;td&gt;row1,col2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,col1&lt;/td&gt; &lt;td&gt;row2,col2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;th>&lt;th>标签定义表格表头单元格。HTML 表单中有两种类型的单元格： 表头单元格 - 包含表头信息（由 th 元素创建） 标准单元格 - 包含数据（由 td 元素创建）th 元素内部的文本通常会呈现为居中的粗体文本，而 td 元素内的文本通常是左对齐的普通文本。1234567891011&lt;table&gt; &lt;caption&gt;表格的标题&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;row1,col1&lt;/th&gt; &lt;th&gt;row1,col2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,col1&lt;/td&gt; &lt;td&gt;row2,col2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;thead>、&lt;tbody>、&lt;tfoot> &lt;thead>、&lt;tbody>、&lt;tfoot>标签分别用于定义表格的页眉、表格的主体和表格的页脚。如果您使用 thead、tfoot 以及 tbody 元素，您就必须使用全部的元素。它们的出现次序是：thead、tfoot、tbody，页面中的显示顺序为thead、tbody、tfoot。您必须在 table 元素内部使用这些标签。 、 以及 很少被使用，这是因为糟糕的浏览器支持。1234567891011121314151617181920212223242526&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt; &lt;td&gt;$180&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;February&lt;/td&gt; &lt;td&gt;$80&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &lt;col> 标签为表格中一个或多个列定义属性值。col 元素是仅包含属性的空元素。如需对全部列应用样式，&lt;col> 标签很有用，这样就不需要对各个单元和各行重复应用样式了。您只能在 table 或 colgroup 元素中使用 &lt;col> 标签。123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot;&gt; .left&#123; background-color:red; &#125; .middle&#123; background-color:yellow &#125; .right&#123; background-color:blue &#125;&lt;/style&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt; &lt;caption&gt;表格的标题&lt;/caption&gt; &lt;col class=&apos;left&apos;&gt; &lt;col class=&apos;middle&apos;&gt; &lt;col class=&apos;right&apos;&gt; &lt;tr&gt; &lt;th&gt;row1,col1&lt;/th&gt; &lt;th&gt;row1,col2&lt;/th&gt; &lt;th&gt;row1,col3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,col1&lt;/td&gt; &lt;td&gt;row2,col2&lt;/td&gt; &lt;td&gt;row2,col3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; colgroup 标签用于对表格中的列进行组合，以便对其进行格式化。通过使用 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。只能在 table 元素内使用 标签。(测试结果好像是colgroup和col是一样的) 表格属性table属性 在 HTML5 中，table标签仅支持 “border” 属性，并且只允许使用值 “” 或 “1”。 “”,表示表格单元周围没有边框 “1”,表示表格单元周围添加边框设置表格border的css样式，只会影响表格最外围的边框显示，而不会影响单元格的边框显示效果。12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot;&gt; table&#123; border:3px solid #f0f; &#125;&lt;/style&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt; &lt;caption&gt;表格的标题&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;row1,col1&lt;/th&gt; &lt;th&gt;row1,col2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,col1&lt;/td&gt; &lt;td&gt;row2,col2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; HTML5之前支持的属性（现在使用依然有效果，但是建议使用css样式实现相同的效果）align：规定表格相对于周围元素的对齐方式。通常来说，HTML 表格的前后都会出现折行。通过运用 align 属性，可实现其他 HTML 元素围绕表格的效果。取值为：left、center、right。bgcolor：规定表格的背景颜色width：规定表格的宽度height：规定表格的高度summary：规定表格的摘要，但是不会产生任何视觉上的变化rules：规定内侧边框的哪些部分是可见的，不建议使用frame：规定外侧边框的哪些部分是可见的，不建议使用cellpadding:规定单元边沿与其内容之间的空白cellspacing：规定单元格之间的空白tr属性 HTML5中不支持tr的任何属性。 HTML5以前支持的tr属性align：定义表格行的内容对齐方式，取值为right、left、center、justify、charbgcolor：规定表格行的颜色char：规定根据哪个字符进行文本对齐，没有浏览器支持charoff：规定第一个对齐字符的偏移量，没有浏览器支持valign：规定表格行中内容的垂直对齐方式,取值为top、middle、bottom、baselinetd属性 HTML5中支持的属性colspan：规定此单元格可横跨的列数rowspan：规定此单元格可横跨的行数headers：规定与单元格相关的一个或多个表头单元格，没有实际上的视觉效果 HTML5以前支持的属性abbr：规定单元格中内容的缩写版本，没有实际上的视觉效果align：规定单元格内容的水平对齐方式，取值为right、left、center、justify、charaxis：用于对单元格进行分类，没有浏览器支持bgcolor：规定单元格的背景颜色char：规定根据哪个字符进行文本对齐，没有浏览器支持charoff：规定第一个对齐字符的偏移量，没有浏览器支持height：规定表格单元格的高度width：规定表格单元格的宽度nowrap：规定单元格的内容不换行scope：将表头单元与数据单元相关联，没有实际上的视觉效果valign：规定表格单元格的垂直对齐方式,取值为top、middle、bottom、baselineth属性 HTML5中支持的属性colspan：规定此单元格可横跨的列数rowspan：规定此单元格可横跨的行数headers：规定与单元格相关的一个或多个表头单元格，没有实际上的视觉效果scope：规定此表头单元格是否是行、列、行组或列组的头部，没有实际上的视觉效果 HTML5以前支持的属性和td标签支持的属性是一样的。caption属性 HTML5中没有caption支持的属性 HTML5以前支持的属性align：规定标题的对齐方式。取值：left、right、top、bottom，该属性将 caption 作为块元素向表格的左边、右边、顶部、底部进行对齐。thead、tbody、tfoot属性 HTML5中没有thead、tbody、tfoot支持的属性 HTML5以前支持的属性（align、valign、char、charoff）]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML列表]]></title>
    <url>%2F2018%2F01%2F04%2FHTML%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[HTML支持有序、无序和定义列表。 列表标签无序列表ul无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。无序列表始于 &lt;ul> 标签。每个列表项始于 &lt;li>。12345&lt;ul&gt; &lt;li&gt;熊猫&lt;/li&gt; &lt;li&gt;老虎&lt;/li&gt; &lt;li&gt;狮子&lt;/li&gt;&lt;/ul&gt; 有序列表ol有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于 &lt;ol> 标签。每个列表项始于 &lt;li> 标签。12345&lt;ol&gt; &lt;li&gt;熊猫&lt;/li&gt; &lt;li&gt;老虎&lt;/li&gt; &lt;li&gt;狮子&lt;/li&gt;&lt;/ol&gt; 定义列表自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 标签开始。每个自定义列表项以 开始。每个自定义列表项的定义以 开始。123456&lt;dl&gt; &lt;dt&gt;熊猫&lt;/dt&gt; &lt;dd&gt;一种带有黑眼圈的动物&lt;/dd&gt; &lt;dt&gt;老虎&lt;/dt&gt; &lt;dd&gt;一种非常凶猛的动物&lt;/dd&gt;&lt;/dl&gt; 其它标签与表格相关的标签还有&lt;dir>和&lt;menu>,其中&lt;dir>标签HTML5不支持，&lt;menu>标签没有浏览器支持。 列表属性ul属性 HTML5不再支持ul的所有属性 HTML5以前的属性compact：规定列表的呈现效果比正常情况下小巧，没有浏览器支持type：规定列表的项目符号的类型，取值：disc(实心圆，默认)，square(实心方块)，circle(空心圆) ol属性 HTML5支持的属性：reversed：规定列表顺序为降序(如5,4,3,2,1)start：规定有序列表的起始值（该属性没有CSS的替代方案）type：规定在列表中使用的标记类型取值： 1 默认。十进制数字 (1, 2, 3, 4)。 a 字母顺序的有序列表，小写 (a, b, c, d)。 A 字母顺序的有序列表，大写 (A, B, C, D)。 i 罗马字母，小写 (i, ii, iii, iv)。 I 罗马字母，大写 (I, II, III, IV)。 HTML5以前的属性：compact：规定列表的呈现效果比正常情况下小巧，没有浏览器支持li属性type：规定使用哪种项目符号。取值：A、a、I、i、1、disc、square、circlevalue：规定列表项目的数字，取值为数字dl、dt、dd属性支持HTML的全局属性]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>ul</tag>
        <tag>ol</tag>
        <tag>dl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requestAnimationFrame]]></title>
    <url>%2F2018%2F01%2F03%2Fanimation%2F</url>
    <content type="text"><![CDATA[在HTML5+CSS3时代，设计Web动画可以有很多种选择。简单说明如下： 使用CSS3的animation+keyframes 使用CSS3的transition 通过HTML5的canvas作图来实现动画 借助jQuery动画来实现 使用Javascript原生的setTimeout()或者setTimeInterval()实现HTML5新增了一个动画实现的方案，也就是requestAnimationFrame()方法。 动画基础屏幕刷新频率屏幕刷新频率，即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般的电脑而言，这个频率大概是60Hz。即使当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。为什么你感觉不到这个变化？ 那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)， 所以会让你误以为屏幕上的图像是静止不动的。而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。动画原理根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新。而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。 那怎么样才能做到这种效果呢？刷新频率为60Hz的屏幕每16.7ms刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即1px。这样一来，屏幕每次刷出来的图像位置都比前一个要差1px，因此你会看到图像在移动；由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。setTimeout理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但我们会发现，利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因： setTimeout的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？首先要明白，setTimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。假设屏幕每隔16.7ms刷新一次，而setTimeout每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：第0ms: 屏幕未刷新，等待中，setTimeout也未执行，等待中；第10ms: 屏幕未刷新，等待中，setTimeout开始执行并设置图像属性left=1px；第16.7ms: 屏幕开始刷新，屏幕上的图像向左移动了1px， setTimeout 未执行，继续等待中；第20ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=2px;第30ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=3px;第33.4ms:屏幕开始刷新，屏幕上的图像向左移动了3px， setTimeout未执行，继续等待中……从上面的绘制过程中可以看出，屏幕没有更新left=2px的那一帧画面，图像直接从1px的位置跳到了3px的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。requestAnimationFrameMozilla的Robert O’Callahan指出，CSS变换和动画的优势在于浏览器知道动画什么时候开始，因此会计算出正确的循环间隔，在恰当的时候刷新UI。而对于JavaScript动画，浏览器无从知晓什么时候开始。requestAnimationFrame()可以告诉浏览器某些JavaScript代码将要执行动画。这样浏览器可以在运行某些代码后进行适当的优化。requestAnimationFrame的特点与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。除此之外，requestAnimationFrame还有以下两个优势： CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame()则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame()也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。 函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。requestAnimationFrame的使用requestAnimationFrame()方法接收一个参数，即在重绘屏幕前调用的一个函数。这个函数负责改变下一次重绘时的DOM样式。为了创建动画循环，可以像以前使用setTimeout()一样，把多个对requestAnimationFrame()的调用连缀起来。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&apos;status&apos; style=&quot;border: 1px solid black;width: 10px;height: 10px;background-color: black&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function updateProgress()&#123; var div=document.getElementById(&apos;status&apos;); div.style.width=(parseInt(div.style.width,10)+5)+&quot;%&quot;; //parseInt的第二个参数10表示十进制 if(div.style.width !=&apos;100%&apos;)&#123; requestAnimationFrame(updateProgress); &#125; &#125; requestAnimationFrame(updateProgress); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; （实际测试，不太需要考虑浏览器的兼容性，但是Safari貌似不支持。）基本语法：window.requestAnimationFrame(callback);参数说明：callback，一个指定函数的参数，该函数在下次重新绘制动画时调用。这个回调函数只有一个传参，该参数用来指示requestAnimationFrame() 开始触发回调函数的当前时间。返回值：一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。requestAnimationFrame（）解决了浏览器不知道Javascript动画什么时候开始，不知道最佳循环间隔时间的问题。如果想确定代码什么时候执行，可以在回调函数中传递一个参数，它是一个时间码（从1970年1月1日起至今的毫秒数），表示下一次重绘的实际时间。requestAnimationFrame（）会根据这个时间码设定将来的某个时刻进行重绘，而根据这个时间码，你也能知道那个时刻是什么时间。然后再优化动画就有了依据。1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&apos;status&apos; style=&quot;border: 1px solid black;width: 10px;height: 10px;background-color: black&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var start = null; var element = document.getElementById(&apos;status&apos;); element.style.position = &apos;absolute&apos;; function step(timestamp) &#123; if (!start) start = timestamp; //第一次传入后这个值就不再变化了 var progress = timestamp - start;//每次执行requestAnimationFrame(step)函数的时候，timestamp的值都会更新 element.style.left = Math.min(progress / 10, 200) + &apos;px&apos;; if (progress &lt; 2000) &#123; window.requestAnimationFrame(step); &#125; &#125; window.requestAnimationFrame(step); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实战案例设计进度条【示例1】本例设计一个进度条动画，初始div宽度为1px，在step()函数中将进度加1，然后更新到div宽度上，在进度达到100之前，一直重复这个过程。12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;test&quot; style=&quot;width:1px;height:17px;background:#0f0;&quot;&gt;0%&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;Run&quot; id=&quot;run&quot;/&gt;&lt;script&gt;var start = null;var ele = document.getElementById(&quot;test&quot;);var progress = 0;function step(timestamp) &#123; progress += 1; ele.style.width = progress + &quot;%&quot;; ele.innerHTML=progress + &quot;%&quot;; if (progress &lt; 100) &#123; requestAnimationFrame(step); &#125;&#125;requestAnimationFrame(step);document.getElementById(&quot;run&quot;).addEventListener(&quot;click&quot;, function() &#123; ele.style.width = &quot;1px&quot;; progress = 0; requestAnimationFrame(step);&#125;, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设计粒子动画【示例2】本例模拟一个粒子动画。首先在页面上插入一个&lt;canvas>标签，然后设计一块画布，在画布上随机生成一个圆点，颜色、运动方向随机；接着从画布中央向四周运动，同时逐步增大半径；最后调用requestAnimationFrame()方法，传递回调函数为粒子生成函数，从而设计随机粒子数放射运动的效果。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html &gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;style&gt;body &#123; margin:0;padding:0; overflow: hidden; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id=&quot;motion&quot;&gt;当前浏览器不支持画布&lt;/canvas&gt;&lt;script&gt; var lastTime = 0; window.requestAnimationFrame = function(callback) &#123; var now = Date.now(); var nextTime = Math.max(lastTime + 16, now); return setTimeout(function() &#123; callback(lastTime = nextTime); &#125;,nextTime - now); &#125;; window.cancelAnimationFrame = clearTimeout; var getRandomColor = function()&#123; return &apos;#&apos;+(Math.random()*0xffffff&lt;&lt;0).toString(16); &#125; var canvas = document.getElementById(&quot;motion&quot;), c = canvas.getContext(&quot;2d&quot;), particles = &#123;&#125;, particleIndex = 0, particleNum = 0.2; canvas.width = window.innerWidth; canvas.height = window.innerHeight; function Particle()&#123; this.x = canvas.width/2; this.y = canvas.height/2; this.vx = Math.random() * 6 - 3; this.vy = Math.random() * 4 - 2; this.growth = ( Math.abs(this.vx) + Math.abs(this.vy) ) * 0.007; particleIndex++; particles[particleIndex] = this; this.id = particleIndex; this.size = Math.random() * 1; this.color = getRandomColor(); &#125; Particle.prototype.draw = function()&#123; this.x += this.vx; this.y += this.vy; this.size += this.growth; if(this.x &gt; canvas.width || this.y &gt; canvas.height)&#123; delete particles[this.id]; &#125; c.fillStyle = this.color; c.beginPath(); c.arc(this.x, this.y, this.size,0*Math.PI,2*Math.PI); c.fill(); &#125;; function animate()&#123; requestAnimationFrame( animate ); c.fillStyle = &quot;#000&quot;; c.fillRect(0,0,canvas.width,canvas.height); if(Math.random() &gt; particleNum)&#123; new Particle(); &#125; for(var i in particles)&#123; particles[i].draw(); &#125; &#125; requestAnimationFrame( animate );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>requestAnimationFrame，Web 动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建HTML5结构]]></title>
    <url>%2F2018%2F01%2F02%2F%E6%9E%84%E5%BB%BAHTML5%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[HTML5 全面升级了文档结构的标识元素，确保文档结构更加清晰明确，容易阅读。 设计主体结构为了使文档的结构更加清晰明确，HTML5 新增与页眉、页脚、内容块等文档结构相关联的结构元素。内容块是指将HTML页面按逻辑进行分割后的区域单位。例如，对于正文页来说，导航菜单、文章正文、文章的评论等每一个部分都可称为内容块。 定义文章块article元素用来表示文档、页面中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客或报刊中的文章、一篇论坛帖子、一段用户评论或者独立的插件等。另外，一个article元素通常会有它自己的标题，一般放在一个header元素里面，有时它还有自己的脚注。当article元素嵌套使用的时候，内部的article元素必须和外部的article元素内容相关。【示例1】下面代码演示了如何使用article元素设计网络新闻展示。1234567891011121314151617181920&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;新闻&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;Twitter直播平台Periscope推出360度全景直播&lt;/h1&gt; &lt;time pubdate=&quot;pubdate&quot;&gt;2016年12月29日 18:12&lt;/time&gt; &lt;/header&gt; &lt;p&gt;新浪科技讯 北京时间12月29日晚间消息，Twitter今日在其直播平台Periscope上推出了360度视频直播服务。Twitter CEO杰克-多西（Jack Dorsey）称，只要将全景VR相机Insta360固定在智能手机上，就可以展示身边的全景世界了。目前，该功能只支持Insta360相机。&lt;/p&gt; &lt;footer&gt; &lt;p&gt;http://www.sina.com.cn&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 这个示例是一篇讲述科技新闻的文章，在header元素中嵌入了文章的标题部分，在这部分内容中，文章的标题被镶嵌在h1元素中，文章的发表日期被镶嵌在time元素中。在标题下面的p元素中，嵌入了一大段该博客文章的正文，在结尾处的footer元素中，嵌入了文章的著作权，作为脚注。整个示例的内容相对比较完整、独立，因此这部分内容使用了article元素。article元素可以嵌套使用，内层的内容在原则上需要与外层的内容相关联。例如，针对该新闻的相关评论就可以使用嵌套article元素的方式。【示例2】本例在上面代码的基础上演示如何实现artcile元素的嵌套使用。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;新闻&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;Twitter直播平台Periscope推出360度全景直播&lt;/h1&gt; &lt;time pubdate=&quot;pubdate&quot;&gt;2016年12月29日 18:12&lt;/time&gt; &lt;/header&gt; &lt;p&gt;新浪科技讯 北京时间12月29日晚间消息，Twitter今日在其直播平台Periscope上推出了360度视频直播服务。Twitter CEO杰克-多西（Jack Dorsey）称，只要将全景VR相机Insta360固定在智能手机上，就可以展示身边的全景世界了。目前，该功能只支持Insta360相机。&lt;/p&gt; &lt;footer&gt; &lt;p&gt;http://www.sina.com.cn&lt;/p&gt; &lt;/footer&gt; &lt;section&gt; &lt;h2&gt;评论&lt;/h2&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;天舞之城&lt;/h3&gt; &lt;p&gt; &lt;time pubdate datetime=&quot;2016-12-29 19:40-08:00&quot;&gt; 1小时前 &lt;/time&gt; &lt;/p&gt; &lt;/header&gt; &lt;p&gt;ok&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;西子与子夕&lt;/h3&gt; &lt;p&gt; &lt;time pubdate datetime=&quot;2016-12-29 19:50-08:00&quot;&gt; 1小时前 &lt;/time&gt; &lt;/p&gt; &lt;/header&gt; &lt;p&gt;well&lt;/p&gt; &lt;/article&gt; &lt;/section&gt; &lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 定义内容块section元素用来对网站或者应用程序中页面上的内容进行分区。一个section通常由内容及其标题组成。div元素也可以用来对内容进行分区，但section元素并非一个普通的容器元素，当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div元素，而非section元素。div元素关注结构的独立性，而section元素关注内容的独立性，section中包含的内容可以单独存储到数据库中或输出到word文档中。【示例1】本例使用section元素把新歌排行榜的内容进行单独分隔。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;section&gt; &lt;h1&gt;经典儿歌TOP10&lt;/h1&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;铃儿响叮当&lt;/h3&gt; &lt;span&gt;小蓓蕾组合 《015、儿歌曲库..》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;拔萝卜&lt;/h3&gt; &lt;span&gt;小蓓蕾组合 《004、儿歌曲库..》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;数鸭子&lt;/h3&gt; &lt;span&gt;少儿歌曲 《童年的歌谣 CD1》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;你在他乡还好吗&lt;/h3&gt; &lt;span&gt;光头李进 《留在蓉城的微笑》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;小兔子乖乖&lt;/h3&gt; &lt;span&gt;小蓓蕾组合 《015、儿歌曲库..》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;爸爸妈妈听我说&lt;/h3&gt; &lt;span&gt;小葡萄 《彭野新儿歌精选》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;让我们荡起双桨&lt;/h3&gt; &lt;span&gt;小蓓蕾组合 《014、儿歌曲库..》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;儿歌：铃儿响叮当&lt;/h3&gt; &lt;span&gt;民族乐团 《胎教音乐（2）CD》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;采蘑菇的小姑娘&lt;/h3&gt; &lt;span&gt;小蓓蕾组合 《004、儿歌曲库..》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;蓝精灵&lt;/h3&gt; &lt;span&gt;儿歌 民族乐团 &lt;/span&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; article元素和section元素都是HTML5 新增的元素，它们的功能与div类似，都是用来区分不同的区域，使用方法也相似。但是它们之间也是有区别的。article元素代表文档、页面或者应用程序中独立完整的可以被外部引用的内容。例如：博客中的一篇文章、论坛中的一个帖子或者一段浏览者的评论等。因为article元素是一段独立的内容，所以article通常包含头部（header元素）、底部（footer元素）。section元素用于对网站或者应用程序中页面上的内容进行分块。一个section元素通常由内容以及标题组成。section元素需要包含一个&lt;hn>标题元素，一般不用包含头部或者底部。通常用section元素为那些有标题的内容进行分段。section元素的作用是对页面上的内容进行分块处理，如对文章分段等，相邻的section元素的内容，应该是相关的，而不是像article元素那样是独立的。【示例2】在本例中，读者能够观察到artcile元素与section元素的区别。事实上article元素可以看做是特殊的section元素。article更强调独立性、完整性，section更强调相关性。1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;潜行者m的个人介绍&lt;/h1&gt; &lt;/header&gt; &lt;p&gt;潜行者m是一个中国男人，是一个帅哥。。。。&lt;/p&gt; &lt;section&gt; &lt;h2&gt;评论&lt;/h2&gt; &lt;article&gt; &lt;h3&gt;评论者：潜行者n&lt;/h3&gt; &lt;p&gt;确实，m同学真的很帅&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h3&gt;评论者：潜行者a&lt;/h3&gt; &lt;p&gt;M今天吃药了没？&lt;/p&gt; &lt;/article&gt; &lt;/section&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 能否用artcile、section元素取代div来布局网页呢？答案是否定的，div的用处就是用来布局网页，划分大的区域。div就是用来布局大块，在不同的内容块中，我们按照需求添加article、section等内容块，并且显示其中的内容，这样才是合理的使用这些元素。 使用section元素时应注意的几个问题： 不要将section元素当做设置样式的容器，对于此类操作应使用div元素来实现 如果artcile元素、aside元素或nav元素更符合条件，不要使用section元素 不要为没有标题的内容块使用section元素【示例3】再看一个artcile和section混合使用的例子。123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;h1&gt;W3C&lt;/h1&gt; &lt;p&gt;万维网联盟（World Wide Web Consortium，W3C），又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。建立者是万维网的发明者蒂姆&amp;middot;伯纳斯-李。&lt;/p&gt; &lt;section&gt; &lt;h2&gt;CSS&lt;/h2&gt; &lt;p&gt;全称Cascading Style Sheet，级联样式表，通常又称为&quot;风格样式表（Style Sheet）&quot;，它是用来进行网页风格设计的。&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;HTML&lt;/h2&gt; &lt;p&gt;全称Hypertext Markup Language，超文本标记语言，用于描述网页文档的一种标记语言。&lt;/p&gt; &lt;/section&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 从上面的代码看，首先可以看到整个板块是一段独立的、完整的内容，因此使用artcile元素。该内容是一片关于W3C的介绍，文章分为3段，每一段都有一个独立的标题，因此使用了两个section元素。 定义导航块nav元素时一个可以用来做页面导航的链接组，其中的导航元素链接到其他页面或当前页面的其他部分。并不是所有的链接组都要放进nav元素，主要将主要的、基本的链接组放进nav元素中即可。例如，在页脚中通常会有一组链接，包括服务条款、首页、版权声明等，这时使用footer元素最恰当。一个页面中可以拥有多个nav元素，作为页面整体或不同部分的导航。具体来说，nav元素可以适合传统导航条、侧边导航栏、页内导航、翻页操作等。【示例1】在HTML5 中，主要是导航性质的链接，就可以很方便地将其放在nav元素中。该元素可以在文档中多次出现。1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;nav&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;book.html&quot;&gt;图书&lt;/a&gt; &lt;a href=&quot;bbs.html&quot;&gt;论坛&lt;/a&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; 【示例2】在下面的示例中，页面由几部分组成，每个部分都带有链接，但只将最主要的链接放nav元素。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;技术资料&lt;/h1&gt;&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/blog&quot;&gt;博客&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;HTML5+CSS3&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#HTML5&quot;&gt;HTML5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#CSS3&quot;&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;section id=&quot;HTML5&quot;&gt; &lt;h1&gt;HTML5&lt;/h1&gt; &lt;p&gt;HTML5特性说明&lt;/p&gt; &lt;/section&gt; &lt;section id=&quot;CSS3&quot;&gt; &lt;h1&gt;CSS3&lt;/h1&gt; &lt;p&gt;CSS3特性说明。&lt;/p&gt; &lt;/section&gt; &lt;footer&gt; &lt;p&gt; &lt;a href=&quot;?edit&quot;&gt;编辑&lt;/a&gt; | &lt;a href=&quot;?delete&quot;&gt;删除&lt;/a&gt; | &lt;a href=&quot;?add&quot;&gt;添加&lt;/a&gt; &lt;/p&gt; &lt;/footer&gt;&lt;/article&gt;&lt;footer&gt; &lt;p&gt;&lt;small&gt;版权信息&lt;/small&gt;&lt;/p&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 第一个nav元素用于页面导航，将页面跳转到其他页面上去；第二个nav元素放置在article元素中，表示在文章中内容进行导航。 定义侧边栏aside元素用来表示当前页面或文章的附属信息部分，它可以包含于当前页面或主要内容相关的引用、侧边栏、广告、导航条，以及其他类似的有别于主要内容的部分。【示例1】作为主要内容的附属信息部分，包含在article中，其中的内容可以是与当前文章有关的参考名词、名词解释等。12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;h1&gt;HTML5&lt;/h1&gt;&lt;/header&gt;&lt;article&gt; &lt;h1&gt;HTML5历史&lt;/h1&gt; &lt;p&gt;HTML5草案的前身名为Web Applications 1.0，于2004年被WHATWG提出，于2007年被W3C 接纳，并成立了新的 HTML工作团队。HTML5 的第一份正式草案已于2008年1月22日公布。2014年10月28日，W3C的HTML工作组正式发布了HTML5的官方推荐标准。&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;名词解释&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;WHATWG&lt;/dt&gt; &lt;dd&gt;Web Hypertext Application Technology Working Group,HTML工作开发组的简称，目前与W3C组织同时研发HTML5。&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;W3C&lt;/dt&gt; &lt;dd&gt;World Wide Web Consortium，万维网联盟，万维网联盟是国际著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。&lt;/dd&gt; &lt;/dl&gt; &lt;/aside&gt;&lt;/article&gt;&lt;/body&gt; 【示例2】作为页面或站点全局的附属信息部分，在artcile元素之外使用。最典型的形式是侧边栏，其中的内容可以是友情链接，博客中其他文章列表、广告单元等。123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;aside&gt; &lt;nav&gt; &lt;h2&gt;友情链接&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;网站1&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;网站2&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;网站3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/aside&gt;&lt;/body&gt;&lt;/html&gt; 友情链接在博客类网站比较常见，一般放在左右两侧的边栏中，因此可以使用aside元素来实现。但是该侧边栏又是具有导航作用的，因此嵌套了一个nav元素。 定义主要区域main元素表示网页中的主要内容。主要内容区域是指与网页标题或应用程序中本页主要功能直接相关或进行扩展的内容。该区域为每一个网页中特有的内容，不能包含整个网站的导航条、版权信息、网站logo、公共搜索表单等整个网站内容的共同内容。每个网页内部只能放置一个main元素。不能将main元素放置在任何article、aside、footer、header或nav元素内。【示例1】本例使用main元素包裹页面主要区域，这样更有利于网页内容的语义分区，同时搜索引擎也能够主动抓取主要信息，避免被辅助性文字所干扰。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;其他&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt;&lt;main&gt; &lt;h1&gt;科技新闻&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#web&quot;&gt;互联网&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#zmt&quot;&gt;自媒体&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#cycx&quot;&gt;创业创新&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;H2 id=&quot;web&quot;&gt;互联网&lt;/H2&gt; &lt;h3&gt;互联网2016：从流量为王到生产率贡献制胜&lt;/h3&gt; &lt;p&gt;白银时代，也许就是经历2015年诸神退位后，中国互联网相当长一段时间的现实。最初那些完全建立在互联网上的红利接近消耗殆尽，就像BAT在搜索、电商和社交这三大传统领域正经历的，而新的机会主要存在于互联网在各行各业的渗透，这意味着你必须同那些行业已经存在的生产者展开生产率的竞争，这将变得不再性感，挤泡沫将贯穿始终。 &lt;/p&gt; &lt;h2 id=&quot;zmt&quot;&gt;自媒体&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;高通魅族达成和解：套路的高通和魅族的套路&lt;/li&gt; &lt;li&gt;同道大叔、李叫兽先后套现上岸，2017年内容创业暗流涌动？&lt;/li&gt; &lt;li&gt;凭什么要我脱离舒适区&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;cycx&quot;&gt;创业创新&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;创业者防坑手册：面对强大的投资人，你该如何正当防卫？&lt;/li&gt; &lt;li&gt;我们想要的不是微信小程序，是重新来过&lt;/li&gt; &lt;li&gt;全球首家MUJI Hotel落户深圳&lt;/li&gt; &lt;/ul&gt;&lt;/main&gt;&lt;footer&gt;Copyright © 虎嗅网 京ICP备12013432号-1&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 设计语义结构除了前面所说的几个主要的结构元素之外，HTML5内还增加了一些表示逻辑或附加信息的非主体结构元素。 定义标题栏header元素是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但也可以包含其它内容，如数据表格、搜索表单或相关的logo图片，因此整个页面的标题应该放在页面的开头。【示例1】在一个网页中可以多次使用header元素，下面显示为每个内容区块加一个header元素。12345678910111213141516&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;h1&gt;网页标题&lt;/h1&gt;&lt;/header&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;文章标题&lt;/h1&gt; &lt;/header&gt; &lt;p&gt;文章正文&lt;/p&gt;&lt;/article&gt;&lt;/body&gt; 在HTML5 中，header元素通常包含h1-h6元素，也可以包hgroup、table、form、nav等元素。只要是应该显示在头部区域的语义标签，都可以包含在header元素中。【示例2】下面是个人博客首页的头部区域代码示例，整个头部内容都放在header元素中。1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;我的博客&lt;/h1&gt; &lt;a href=&quot;#&quot;&gt;[URL]&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;[订阅]&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;[手机订阅]&lt;/a&gt; &lt;/hgroup&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;目录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;社区&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;微博我&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt;&lt;/body&gt; 定义标题组hgroup元素可以为标题或者子标题进行分组，通常它与h1-h6元素组合使用，一个内容块中的标题及其子标题可以通过hgroup元素组成一组。但是，如果文章只有一个主标题，则不需要hgroup元素。【示例1】本例显示如何使用hgroup元素把主标题、副标题和标题说明进行分组，以便让引擎更容易识别标题块。1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;主标题&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt; &lt;h3&gt;标题说明&lt;/h3&gt; &lt;/hgroup&gt; &lt;p&gt; &lt;time datetime=&quot;2017-6-20&quot;&gt;发布时间：2017年6月20日&lt;/time&gt; &lt;/p&gt; &lt;/header&gt; &lt;p&gt;新闻正文&lt;/p&gt;&lt;/article&gt;&lt;/body&gt; 定义脚注栏footer元素可以作为内容块的注脚，如在父级内容块中添加注释，或者在网页中添加版权信息等。【示例1】在HTML5 之前，要描述脚注信息，一般使用&lt;div id=’footer’&gt;标签定义包含框。123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;主标题&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt; &lt;h3&gt;标题说明&lt;/h3&gt; &lt;/hgroup&gt; &lt;p&gt; &lt;time datetime=&quot;2017-03-20&quot;&gt;发布时间：2017年10月29日&lt;/time&gt; &lt;/p&gt; &lt;/header&gt; &lt;p&gt;新闻正文&lt;/p&gt;&lt;/article&gt;&lt;footer&gt; &lt;ul&gt; &lt;li&gt;关于&lt;/li&gt; &lt;li&gt;导航&lt;/li&gt; &lt;li&gt;联系&lt;/li&gt; &lt;/ul&gt;&lt;/footer&gt;&lt;/body&gt; 【示例2】与header元素一样，页面中也可以多次使用footer元素。同时可以为article或者section元素添加footer元素。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;h1&gt;网页标题&lt;/h1&gt;&lt;/header&gt;&lt;article&gt; 文章内容 &lt;h2&gt;文章标题&lt;/h2&gt; &lt;p&gt;正文&lt;/p&gt; &lt;footer&gt;注释&lt;/footer&gt;&lt;/article&gt;&lt;section&gt; &lt;h2&gt;段落标题&lt;/h2&gt; &lt;p&gt;正文&lt;/p&gt; &lt;footer&gt;段落标记&lt;/footer&gt;&lt;/section&gt;&lt;footer&gt;网页版权信息&lt;/footer&gt;&lt;/body&gt; 定义联系信息段address元素用来在文档中定义联系信息，包括文档作者或文档编辑者名称、电子邮箱、电话号码、真实地址等。【示例1】address的用途不仅仅是用来描述电子邮箱或真实地址，还可以描述与文档相关的联系人的所有联系信息。123456789101112&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;address&gt; &lt;a href=&quot;http://www.w3.org/&quot;&gt;W3C&lt;/a&gt; &lt;a href=&quot;http://www.whatwg.org/&quot;&gt;WHATWG&lt;/a&gt; &lt;a href=&quot;http://www.mhtml5.com/&quot;&gt;HTML5研究小组&lt;/a&gt;&lt;/address&gt;&lt;/body&gt; 【示例2】也可以把footer元素、time元素与address元素结合起来使用。1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;footer&gt; &lt;section&gt; &lt;address&gt; &lt;a title=&quot;作者：MDN&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5&quot;&gt;HTML5 - Web开发者指南&lt;/a&gt; &lt;/address&gt; &lt;p&gt; 发布于： &lt;time datetime=&quot;2017-6-1&quot;&gt;2017年6月1日&lt;/time&gt; &lt;/p&gt; &lt;/section&gt;&lt;/footer&gt;&lt;/body&gt; 定义时间段HTML5 增加了一种新的元素来无歧义地、明确地对机器的时间进行编码，并且以让人易读的方式来展示它。这个元素就是time元素。【示例1】time元素代表24小时中的某个时刻或日期，表示时刻允许带时差。它可以定义很多格式的日期和时间。12345678910111213&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;time datetime=&quot;2017-11-13&quot;&gt;2017年11月13日&lt;/time&gt;&lt;time datetime=&quot;2017-11-13&quot;&gt;11月13日&lt;/time&gt;&lt;time datetime=&quot;2017-11-13&quot;&gt;我的生日&lt;/time&gt;&lt;time datetime=&quot;2017-11-13T20:00&quot;&gt;我生日的晚上8点&lt;/time&gt;&lt;time datetime=&quot;2017-11-13T20:00Z&quot;&gt;我生日的晚上8点&lt;/time&gt;&lt;time datetime=&quot;2017-11-13T20:00+09:00&quot;&gt;我生日的晚上8点的美国时间&lt;/time&gt;&lt;/body&gt; 编码时引擎读到的部分在datetime属性里，而元素的开始标记与结束标记中间的部分是显示在网页上的。datetime属性中日期与时间之间要用‘T’文字隔开。倒数第三行，时间加上Z文字表示给机器编码时使用UTC时间；倒数第二行加上了时差，表示向机器编码另一地区时间；如果是编码本地时间，则不需要添加时差。 定义发布时间pubdate属性是一个可选的布尔值属性，它可以用在article元素中的time元素上，意思是time元素代表了文章或整个网页的发布日期。123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;科技公司都变成了数据公司：但你真的了解什么是“数据工程师”吗？&lt;/h1&gt; &lt;p&gt;发布日期&lt;time datetime=&quot;2016-12-30&quot; pubdate&gt;2016-12-30 09:19&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;在和国内外顶尖公司交流的过程中，我发现他们多数都很骄傲有一支极其专业的数据团队。这些公司花了大量的时间和精力把数据工程这件事情做到了极致，有不小规模的工程师团队，开源了大量数据技术。Linkedin 有 kafka、samza, Facebook 有 hive、presto，Airbnb有airflow、superset，我所熟悉的 Yelp 也有 mrjob…… 这些公司在数据领域的精益求精，为后来的大步前进奠定了基石。&lt;/p&gt; &lt;footer&gt; &lt;p&gt;https://www.huxiu.com/article/176524.html&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt;&lt;/body&gt; time元素不仅仅表示发布时间，还可以表示其它用途的时间，如通知、约会等。【示例2】为了避免引擎误解发布时间，使用pubdate属性可以显示地告诉引擎文章中哪个是真正的发布时间。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;科技公司都变成了数据公司：但你真的了解什么是“数据工程师”吗？&lt;/h1&gt; &lt;p&gt;发布日期&lt;time datetime=&quot;2016-12-30&quot; pubdate&gt;2016-12-30 09:19&lt;/time&gt;&lt;/p&gt; &lt;p&gt;关于&lt;time datetime=2017-1-1&gt;1月1日&lt;/time&gt;更正通知&lt;/p&gt; &lt;/header&gt; &lt;p&gt;在和国内外顶尖公司交流的过程中，我发现他们多数都很骄傲有一支极其专业的数据团队。这些公司花了大量的时间和精力把数据工程这件事情做到了极致，有不小规模的工程师团队，开源了大量数据技术。Linkedin 有 kafka、samza, Facebook 有 hive、presto，Airbnb有airflow、superset，我所熟悉的 Yelp 也有 mrjob…… 这些公司在数据领域的精益求精，为后来的大步前进奠定了基石。&lt;/p&gt; &lt;footer&gt; &lt;p&gt;https://www.huxiu.com/article/176524.html&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt;&lt;/body&gt; 在这个例子中，有两个time元素，分别定义了两个日期：更正日期金和发布日期。由于都使用了time元素，所以需要使用pubdate属性表明哪个时间代表了新闻的发布时间。 实战案例设计完整的HTML5 文档结构1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;!-- 声明文档结构类型 --&gt;&lt;html lang=&apos;zh-cn&apos;&gt;&lt;!-- 规定元素内容的语言，zh-cn中文简体，en英语，fr法语&gt;&lt;head&gt;&lt;!-- 文档的头部区域 --&gt;&lt;meta charset=&apos;utf-8&apos;&gt;&lt;!-- 文档的头部区域中元数据区的字符集定义，utf-8表示国际通用的字符集编码格式 --&gt;&lt;title&gt;文档标题&lt;/title&gt;&lt;!-- 文档的头部区域的标题。title内容对于SEO来说极其重要--&gt;&lt;meta name=&apos;description&apos; content=&apos;文档描述信息&apos;&gt;&lt;!-- 文档的头部区域元数据区关于文档描述的定义 --&gt;&lt;meta name=&apos;author&apos; content=&apos;文档作者&apos;&gt;&lt;!-- 文档的头部区域元数据区关于开发人员姓名的定义 --&gt;&lt;meta name=&apos;copyright&apos; content=&apos;版权信息&apos;&gt;&lt;!-- 文档的头部区域元数据区关于版权的定义 --&gt;&lt;meta name=&apos;keywords&apos; content=&apos;&apos;&gt;&lt;!-- 文档的头部区域元数据区关于关键词的定义，有利于搜索引擎 --&gt;&lt;meta name=viewport content=width=device-width, user-scalable=no &gt;&lt;!-- 文档的头部区域对于不同接口设备的特殊声明。宽=设备宽，用户不能自行缩放 --&gt;&lt;link rel=&apos;stylesheet&apos; href=&apos;main.css&apos;&gt;&lt;!-- 文档的头部区域的样式文件引用 --&gt;&lt;script src=&apos;script.js&apos;&gt;&lt;/script&gt;&lt;!-- 文档的头部区域的JavaScript脚本文件调用 --&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt;HTML5文档的头部区域&lt;/header&gt;&lt;nav&gt;HTML5文档的导航区域&lt;/nav&gt;&lt;section&gt;HTML5文档的主要内容区域 &lt;aside&gt; HTML5文档的主要内容区域的侧边导航或菜单区 &lt;/aside&gt; &lt;article&gt; HTML5文档的主要内容区域的内容区 &lt;section&gt;以下是一个section和article的嵌套。 &lt;aside&gt; &lt;/aside&gt; &lt;article&gt; &lt;header&gt; HTML5文档的嵌套区域，可以对某个article区域进行头部和脚部的定义。这样做，可以有非常清晰和严谨的文档目录结构关系。 &lt;footer&gt; &lt;/article&gt; &lt;/section&gt; &lt;/article&gt;&lt;/section&gt;&lt;footer&gt;HTML5文档的脚部区域&lt;/footer&gt;&lt;/body&gt;&lt;/HTML&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>结构化标签，语义化标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程处理 -- Web Workers]]></title>
    <url>%2F2018%2F01%2F01%2Fwebwork%2F</url>
    <content type="text"><![CDATA[使用Javascript执行大型计算时，经常会出现假死现象。这是因为Javascript是单线程的编程语言，运算能力比较弱。HTML5新增的Web Workers API能够创建一个不影响前台处理的后台线程，并且在这个后台线程中可以创建多个子线程，以帮助Javascript实现多线程运算的能力。通过Web Workers，用户可以将耗时较长的处理交给后台线程去执行，从而解决了HTML5之前因为某个处理耗时过长而不得不提前结束的尴尬。 Web Workers 基础Web workers为网页脚本提供了一种能在后台进程中运行的方法。当创建Web Worker对象后，Web Workers就可以通过postMessage()方法向任务池发送任务请求，执行完之后再通过postMessage()返回消息给创建者指定的事件处理程序，然后通过onmessage捕获返回消息，实现前后台数据的交互。 认识Web Workers在Web应用程序中，Web Workers是一项后台处理技术。在此之前使用Javascript创建的Web程序中，因为所有的处理都是在单线程内执行，所以如果脚本需要很长时间运行的话，程序界面会长时间处于停止响应状态。甚至当等待时间超出一定的限度，浏览器会提示脚本运行时间较长需要终端正在执行的处理。为了解决这个问题，HTML5新增了一个Web Worker API。使用这个Api，用户可以很容易地创建在后台运行的线程，这个线程被称为worker，如果将可能耗费较长时间的处理交给后台去执行的话，对用户在前台页面中执行的操作就没有影响了。尽管Web Worker的功能强大，但并不是万能的，有些事情它还做不到。例如，在Web Worker中执行的脚本不能访问该页面的window对象，因此WebWorker不能直接访问Web页面和DOM API，虽然Web worker不会导致浏览器UI停止响应，但是仍会消耗CPU周期，导致系统反应速度变慢。如果开发人员创建的Web 应用程序需要执行一些后台数据处理，但又不希望这些数据处理任务影响Web页面本身的交互性，那么可以通过Web Workers生成一个worker去处理数据任务，同时添加一个时间监听器进行监听，并与之进行数据交互。 Web Workers能够为我们做什么？ 加载一个Javascript文件，进行大量的复杂计算，而不挂起主进程，并通过postMessage,onMessage进行通信 可以在Worker中通过importScripts（url）方法加载JavaScript脚本文件 可以使用setTimeout()、clearTimeout()、setInterval()、clearInterval() 可以使用XMLHttpRequest()进行异步请求 可以访问navigator的部分属性 可以使用Javascript的核心对象 Web Workers的局限性： 不能跨域加载JavaScript Worker内代码不能访问DOM 各个浏览器对Worker的实现没有完全完善，不是每个浏览器都支持所有的新特性 使用Web Workers加载数据没有JSONP和Ajax加载数据高效浏览器支持在调用Web Workers API函数之前，应该确认浏览器是否支持。如果不支持，可以提供一些备用信息，提醒用户使用最新的浏览器。12345function testWorker()&#123; if (typeof Worker !== &quot;undefined&quot;)&#123; document.getElementById(&apos;support&apos;).innerHTML=&apos;您的浏览器不支持 HTML5 Web Worker&apos;； &#125;&#125; 创建Web Workers调用Worker构造函数可以创建一个worker线程。Worker在初始化的时候会接受一个URL参数，参数URl表示要执行的脚本文件地址，其中包含了供Worker执行的代码。worker=new Worker(&#39;xxx.js&#39;)如果要获取worker进程的返回值，可以使用onmessage时间进行监听。1234var myWorker=new Worker(&apos;xxx.js&apos;);myWorker.onmessage=function(event)&#123; alert(&apos;Called back by the worker&apos;)；&#125;； 在上面的代码中，第一行代码将创建和运行worker进程，第二行设置worker的onmessage属性，绑定事件处理函数，当worker的postmessge()方法被调用时，这个被绑定的事件处理函数就会被调用。对于由多个JavaScript文件组成的应用程序来说，可以通过包含script元素的方式，在页面加载的时候同步加载JavaScript文件。由于Web Workers没有访问Document对象的权限，所以在worker中只能使用importScripts()方法导入其他JavaScript文件。importScripts（）是全局函数，该函数可以将脚本或库导入到它们的作用域中，导入的JavaScript文件只会在某一个已有的Worker中加载和执行。多个脚本的导入同样也可以使用importScripts（）函数，它们会按顺序执行。importScripts（）可以接受空的参数或多个脚本URl参数。(在后台线程中使用)123importScripts（）;importScripts（&apos;foo.js&apos;）;importScripts（&apos;foo.js&apos;,&apos;bar.js&apos;） JavaScript会加载列出的每一个脚本文件，然后运行并初始化。这些脚本中的任何全局对象都可以被worker使用。importScripts（）方法下载脚本的顺序可能不一样，但执行的顺序一定是按importScripts（）方法中列出的顺序进行，而且是同步的，在所有脚本加载完并运行结束后importScripts（）才会返回。Web Worker能够嵌套使用，以创建子Worker。用户可以创建多个子worker。子worker必须寄宿于同一个父页面下，且它的URL必须与父worker的地址同源，这样可以很好的维持它们的依赖关系。Web Workers可以使用setTimeout（）和setInterval()。如果希望Web Worker进程周期性地运行而不是不停地循环下去的话，使用这两个方法非常有用。用户可以通过Worker对象的onmessage事件获取后台线程反馈的消息。使用postMessage（）方法可以给后台线程发送消息。发送的消息是文本数据，但也可以是任何Javascript对象，需要通过JSON对象的stringify（）方法将其转换成文本数据。在线程调用的Javascript脚本文件中，所有可用的变量、函数和类的说明如下：self：self关键字用来表示本线程范围内的作用域。postMessage：向创建线程的源窗口发送消息。（myWorker.postMessage()是在源窗口向后台线程发送消息）onmessage：后台线程接受源窗口消息的事件句柄（myworker.onmessage（）是源窗口接受后台线程消息的事件句柄)importScripts（URL）：在后台线程中导入其它Javascript脚本文件。navigator对象：与window.navigator对象类似，具有appName、platform、userAgent、appVersion属性。sessionStorage/localStorage:在线程中可以使用web Storage。XMLHttpRequest:在线程中可以处理ajax请求。Web Workers：在线程中可以嵌套线程。setTimeout()/setInterval():在线程中可以实现定时处理。close：结束本线程（myworker.terminate()）eval()、isNaN()、escape()等：可以使用所有Javascript核心函数object：可以创建和使用本地对象WebSockets：可以使用Web Sockets API向服务器发送和接收消息 Web Workers通信使用后台线程不能访问页面或窗口对象，但是并不代表后台线程不能与页面进行数据交互。为了实现页面与Web Workers通信，可以调用postMessage函数传入所需数据。同时将建立一个监听器，用来监听由Web Workers 发送到页面的消息。为建立页面与worker之间的通信，首先要在页面中添加对postMessage（）函数的调用:123document.getElementById(&apos;helloButton&apos;).onclick=function()&#123; worker.postMessage(&apos;你好&apos;)；&#125; 当用户单击按钮后，相应消息会发送到worker，然后将事件监听器添加到页面中，用来监听从worker发来的消息。1234worker.addEventListener(&apos;message&apos;,messageHandler,true);function messageHandler(e)&#123; //来自worker的处理信息&#125; 编写HTML5 Web Workers Javascript文件。在该文件中，需要添加时间监听器以监听发来的消息，并且通过调用postMessage函数实现与页面之间的通信。为了完成页面与Web Workers之间的通信功能。首先，添加代码调用postMessage函数。123function messageHandler(e)&#123; postMessage(&apos;worker说：&apos;+e.data+&apos; too&apos;);&#125; 接下来，在Web Workers Javascript文件中添加事件监听器。以处理从页面发来的消息。接收到信息后马上调用messageHandler函数以保证信息能够及时返回。通过postMessage函数对象传递到Workers或者从中返回对象，这些将自动转换成JSON格式。(在workers中的对象不能包含函数和循环引用，因为JSON不支持它们)123var onmessage=function(e)&#123; postMessage(e.data);&#125;; 在Web Workers脚本中如果发生未处理的错误。会引发Web Workers对象的错误事件。特别是在调式用到Web Workers脚本时，对错误事件的监听器就显得尤为重要了。下面显示的Web Workers Javascript文件中的错误处理函数，它将错误记录在控制台上。123function errorHandler（e）&#123; console.log(e.message,e);&#125; 为了处理错误，还必须在主页上添加一个事件监听器：worker.addEventListener(&#39;error&#39;,errorHandler,true);当worker运行发生错误时，它的onerror事件就会被触发。该事件不会冒泡，并且可以取消。要取消该事件可以使用proventDefault()方法。该错误事件有三个属性：message：可读的错误信息filename：发生错误的脚本文件名称lineno：发生错误的脚本所在的行数Web Workers不能自行终止，但能够被启用它们的页面所终止，通用terminate()函数可以终止后台进程。被终止的Web Workers将不再响应任何消息或者执行任何其它的计算。终止之后，Worker不能被重新启动，但可以使用相同的URL创建一个新的worker。worker.terminate() 案例：使用Web Workers注意：由于一些浏览器不支持读取本地文件，所以为了保证测试效果，建议将测试代码放在服务器上进行测试。【示例1】本例演示了如何使用Web Worker在控制台显示一条提示信息。(1)主页文件：12345678910111213141516171819&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;//WEB页主线程var worker = new Worker(&quot;worker.js&quot;);//创建一个Worker对象并向它传递将在新线程中执行的脚本的URLworker.postMessage(&quot;hello world&quot;);//向worker发送数据worker.onmessage = function(evt) &#123;//接收worker传过来的数据函数 console.log(evt.data); //输出worker发送来的数据&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; (2)后台线程文件（worker.js）：123456onmessage = function(evt) &#123; var d = evt.data; //通过evt.data获得发送来的数据 postMessage(d); //将获取到的数据发送会主线程&#125; 通过上面的实例可以看出来，Web Workers包括两个部分： 定义主页线程 通过worker =new Worker（url）加载一个Javascript文件，创建一个worker，同时返回一个worker实例 通过worker.postMessage（data）方法向worker发送数据 通过worker.onmessage事件接受worker响应的数据 使用worker.terminate()可以终止一个worker执行 定义worker线程 通过postMessage（data）向主线程发送数据 绑定onmessage事件接受主线程发送过来的数据【示例2】本例演示如何创建Web workers，手动控制Web workers与页面进行通信的一般方法，同时设置如何处理异常，以及如何停止worker 任务处理。(1)主页文件：1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;p id=&quot;support&quot;&gt;你的浏览器不支持 HTML5 Web Workers&lt;/p&gt;&lt;button id=&quot;stopButton&quot; &gt;停止任务&lt;/button&gt;&lt;button id=&quot;helloButton&quot; &gt;发送消息&lt;/button&gt;&lt;script&gt;function stopWorker() &#123; worker.terminate(); &#125;function messageHandler(e) &#123; console.log(e.data);&#125;function errorHandler(e) &#123; console.warn(e.message, e);&#125;function loadDemo() &#123; if( typeof (Worker) !== &quot;undefined&quot;) &#123; document.getElementById(&quot;support&quot;).innerHTML = &quot;你的浏览器支持HTML5 Web Workers&quot;; worker = new Worker(&quot;worker.js&quot;); worker.addEventListener(&quot;message&quot;, messageHandler, true); worker.addEventListener(&quot;error&quot;, errorHandler, true); document.getElementById(&quot;helloButton&quot;).onclick = function() &#123; worker.postMessage(&quot;ok&quot;); &#125; document.getElementById(&quot;stopButton&quot;).onclick = stopWorker; &#125;&#125;window.addEventListener(&quot;load&quot;, loadDemo, true);&lt;/script&gt; (2)后台线程文件（worker.js）：1234function messageHandler(e) &#123; postMessage(&quot;worker says: &quot; + e.data );&#125;addEventListener(&quot;message&quot;, messageHandler, true); 【示例3】使用addEventListener方法注册后台线程的响应事件比较麻烦，我们可以把它修改为下面这种传统的写法：(1)主页文件1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;p id=&quot;support&quot;&gt;你的浏览器不支持 HTML5 Web Workers&lt;/p&gt;&lt;button id=&quot;stopButton&quot; &gt;停止任务&lt;/button&gt;&lt;button id=&quot;helloButton&quot; &gt;发送消息&lt;/button&gt;&lt;script&gt;window.onload = function() &#123; if( typeof (Worker) !== &quot;undefined&quot;) &#123; document.getElementById(&quot;support&quot;).innerHTML = &quot;你的浏览器支持HTML5 Web Workers&quot;; worker = new Worker(&quot;worker.js&quot;); worker.onmessage = function(e) &#123; console.log(e.data); &#125; worker.onerror = function(e) &#123; console.warn(e.message, e); &#125; document.getElementById(&quot;helloButton&quot;).onclick = function() &#123; worker.postMessage(&quot;ok&quot;); &#125; document.getElementById(&quot;stopButton&quot;).onclick = function() &#123; worker.terminate(); &#125;; &#125;&#125;&lt;/script&gt; (2)后台线程文件（worker.js）:123onmessage = function(e) &#123; postMessage(&quot;worker says: &quot; + e.data );&#125; 实战案例后台运算本示例设计一个文本框，允许用户在该文本框输入数字，然后点击计算按钮，在后台计算从1到给定数值的和。虽然对于从1到给定数值的求和计算只需要一个求和公式就可以了，本示例为了展示后台线程的使用方法，采取循环计算的方法。传统方法：12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;function calculate() &#123; var num = parseInt(document.getElementById(&quot;num&quot;).value, 10); var result = 0; for (var i = 0; i &lt;= num; i++) &#123; result += i; &#125; alert(&quot;合计值为&quot; + result + &quot;。&quot;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入数值:&lt;input type=&quot;text&quot; id=&quot;num&quot;&gt;&lt;button onClick=&quot;calculate()&quot;&gt;计算&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 虽然在文本框中输入较小的值时，不会有什么延迟问题。但是当用户在该文本框中输入特别巨大的数字，浏览器运行时间明显延迟。Web Workers方法：(1):主页文件123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;// 创建执行运算的线程var worker = new Worker(&quot;SumCalculate.js&quot;);//接收从线程中传出的计算结果worker.onmessage = function(event) &#123; //消息文本放置在data属性中,可以是任何JavaScript对象. alert(&quot;合计值为&quot; + event.data + &quot;。&quot;);&#125;;function calculate() &#123; var num = parseInt(document.getElementById(&quot;num&quot;).value, 10); //将数值传给线程 worker.postMessage(num);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入数值:&lt;input type=&quot;text&quot; id=&quot;num&quot;&gt;&lt;button onclick=&quot;calculate()&quot;&gt;计算&lt;/button&gt;&lt;/body&gt; (2)后台线程文件（SumCalculate.js）123456789onmessage = function(event) &#123; var num = event.data; var result = 0; for (var i = 0; i &lt;= num; i++) result += i; //向线程创建源送回消息 postMessage(result);&#125; 数值过滤在Web应用中，建议用户将非及时性的任务处理放在后台实现，以减轻前台的压力。本示例设计在页面上随机生成一个整数的数组，然后将该整数数组传入线程，让后台帮助挑选出该数组中可以被3整除的数字，然后显示在页面表格中。(1)在前台脚本中随机生成整数数组，然后送到后台线程挑选出能够被3整除的数字，再传回前台脚本，在前台脚本中根据挑选结果动态表格中的行、列，并将挑选出来的数字显示在表格中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var intArray=new Array(200);//随机数组var intStr=&quot;&quot;;//生成200个随机数for(var i=0;i&lt;200;i++)&#123; intArray[i]=parseInt(Math.random()*200); if(i!=0) intStr+=&quot;;&quot;; //用分号作随机数组的分隔符 intStr+=intArray[i]; &#125;//向后台线程提交随机数组var worker = new Worker(&quot;script.js&quot;);worker.postMessage(intStr);//从线程中取得计算结果worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;) &#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0) &#123;//如果该行不存在，则添加行 tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123;//如果该行存在，则获取该行 tr=document.getElementById(&quot;tr&quot;+j); &#125; //添加列 td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)后台线程文件12345678910111213141516onmessage = function(event) &#123; var data = event.data; var returnStr; //将3的倍数拼接成字符串并返回 var intArray=data.split(&quot;;&quot;); //返回字符串中数字分隔符为; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++) &#123; if(parseInt(intArray[i])%3==0) //能否被3整除 &#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //返回3的倍数拼接成的字符串&#125; 并发处理利用线程可以嵌套的特性，可以在Web应用中实现多个任务并发处理，这样能够提高Web应用程序的执行效率和反应速度。同时通过线程嵌套把一个较大的后台任务切分成几个子线程，在每个子线程中各自完成一部分相对独立的任务。本示例在上一节示例基础上，把主页脚本中随机生成数组的工作放在后台线程中，然后使用另一个子线程在随机数组中挑选可以被3整除的数字。对于数组的传递以及挑选结果的传递均采用JSON对象来进行转换，以验证是否能在线程之间进行Javascript对象的传递工作。(1)在主页面中定义一个线程。设计不向该线程发送数据，在onmessage事件回调函数中进行后期数据处理，并把返回的数据显示在页面中。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var worker = new Worker(&quot;script.js&quot;);worker.postMessage(&quot;&quot;);// 从线程中取得计算结果worker.onmessage = function(event) &#123;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)在后台主线程文件script.js中，随机生成200个整数构成的数组，然后把这个数组提交到子线程，在子线程中可以把能被3整除的数字挑选出来，然后送回主线程。主线程再把挑选结果送回页面进行显示。1234567891011121314onmessage=function(event)&#123; var intArray=new Array(200); for(var i=0;i&lt;200;i++) intArray[i]=parseInt(Math.random()*200); var worker; //创建子线程 worker=new Worker(&quot;worker2.js&quot;); //把随机数组提交给子线程进行挑选工作 worker.postMessage(JSON.stringify(intArray)); worker.onmessage = function(event) &#123; //把挑选结果返回主页面 postMessage(event.data); &#125;&#125; (3)设计子线程的任务处理代码。子线程在接收到的随机数组中挑选能够被3整除的数字，然后拼接成字符串并返回。12345678910111213141516onmessage = function(event) &#123; //还原整数数组 var intArray= JSON.parse(event.data); var returnStr; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++)&#123; if(parseInt(intArray[i])%3==0)&#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //关闭子线程 close(); &#125; 在子线程中向发送源发送回消息后，如果该子线程不再使用的话，应该使用close语句关闭子线程。(4)在页面的主线程回调函数中处理后台线程返回的数据，并将这些数据显示在页面中。12345678910111213141516171819202122worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;)&#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0)&#123; tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123; tr=document.getElementById(&quot;tr&quot;+j); &#125; td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;; 线程通信本示例继续在前面示例的基础上，将创建随机数组的工作也放到一个单独的子线程中，在该线程中创建随机数组，然后将随机数组传递到另一个子线程中进行能够被3整除的数字挑选工作，最后把挑选结果传递回主页面进行显示。设计思路：当主线程嵌套多个子线程时，子线程之间可以通过下面几个步骤进行通信。 先创建发送数据的子线程 执行子线程中的任务，然后把要传递的数据发送给主线程 在主线程接收到子线程传回来的消息时，创建接收数据的子线程，然后把发送数据的子线程中返回的消息传递给接收数据的子线程 执行接收数据子线程中的代码操作步骤：(1)完成主页面的设计。包括HTML结构和CSS样式。在主页脚本中创建一个主线程，定义请求数据为空，在主线程响应事件onmessage回调函数中处理后台返回的处理数据，并把它们显示在页面中。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var worker = new Worker(&quot;script.js&quot;);worker.postMessage(&quot;&quot;);// 从线程中取得计算结果worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;)&#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0)&#123; tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123; tr=document.getElementById(&quot;tr&quot;+j); &#125; //添加列 td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)修改主线程中的代码。在主线程中定义一个子线程（发送数据），让其随机生成200个数字，并返回这个随机数组。在该子线程的回调函数中再定义一个子线程（接受数据），把接受到的随机数组传递给它，并接收该线程过滤后的数组。1234567891011121314151617181920onmessage=function(event)&#123; var worker; //创建发送数据的子线程 worker=new Worker(&quot;worker1.js&quot;); worker.postMessage(&quot;&quot;); worker.onmessage = function(event) &#123; //接收子线程中数据:创建好的随机数组 var data=event.data; //创建接收数据子线程 worker=new Worker(&quot;worker2.js&quot;); //把从发送数据子线程中发回消息传递给接收数据的子线程 worker.postMessage(data); worker.onmessage = function(event) &#123; //获取接收数据子线程中传回数据，本示例中为挑选结果 var data=event.data; //把挑选结果发送回主页面 postMessage(data); &#125; &#125;&#125; (3)在发送数据的子线程中创建一个200个整数构成的随机数组。然后把它转换为字符串并返回，最后关闭该子线程。1234567onmessage = function(event) &#123; var intArray=new Array(200); for(var i=0;i&lt;200;i++) intArray[i]=parseInt(Math.random()*200); postMessage(JSON.stringify(intArray)); close();&#125; (4)在接受数据子线程中对接受到的随机数组中挑选能被3整除的数字，然后拼接成字符串并返回。12345678910111213141516onmessage = function(event) &#123; //还原整数数组 var intArray= JSON.parse(event.data); var returnStr; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++)&#123; if(parseInt(intArray[i])%3==0)&#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //关闭子线程 close(); &#125; Fibonacchi数列运算Fibonacci数列以递归的方式进行定义：F0=0；F1=1；Fn=F(n-1)+F（n-2）（n&gt;2）使用Javascript实现Fibonacci数列运算的一般方法为：123var fibonacci =function(n) &#123; return n &lt;2? n : arguments.callee(n -1) + arguments.callee(n -2);&#125;; 当计算工作量较大的时候，非常有可能造成浏览器罢工，可以使用Web Workers将数列计算过程放入一个后台线程里。(1)主页文件：123456789101112131415161718&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;web worker fibonacci&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; onload =function()&#123; var worker =new Worker(&apos;fibonacci.js&apos;); worker.addEventListener(&apos;message&apos;, function(event) &#123; console.log(event.data); &#125;, false); worker.postMessage(40); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; (2)后台线程文件（fibonacci.js）1234567var fibonacci =function(n) &#123; return n &lt;2? n : arguments.callee(n -1) + arguments.callee(n -2);&#125;;onmessage =function(event) &#123; var n = parseInt(event.data, 10); postMessage(fibonacci(n));&#125;;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>Web Workers</tag>
      </tags>
  </entry>
</search>
