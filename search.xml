<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue 2.0 学习之 -- Vue 实例]]></title>
    <url>%2F2018%2F09%2F29%2Fvue%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Vue实例每个Vue应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：123var vm=new Vue(&#123; //选项&#125;) 当创建一个 Vue 实例对象之后，你可以传入一个选项对象。一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可嵌套的、可复用的组件树构成。 数据与方法当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。当这些数据改变时，视图会重新渲染。但是只有在实例被创建时 data 中存在的属性才是响应式的。也就是说如果你添加一个新的属性，随后对b的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你可以设置一些初始值。唯一的例外是使用 object.freeze(),这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $ ,以便和用户定义的属性区分开来。]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue实例</category>
      </categories>
      <tags>
        <tag>Vue实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 学习之旅（一）--安装]]></title>
    <url>%2F2018%2F09%2F29%2Fvue%20%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[从今天开始学习前端框架 Vue，该系列的文章主要记录自己在 Vue 的学习过程中所了解到的一些基础知识。 兼容性Vue不支持 IE8 及以下版本。 辅助工具在使用 Vue 时推荐在浏览器上安装 Vue Devtools。它允许你在一个更友好的界面中审查和调试 Vue 应用。 Vue.js 安装教程直接下载直接下载vue.js文件，然后通过&lt;script>标签引用。&lt;script src=&quot;/地址/vue.js&quot;&gt;&lt;/script&gt; CDN 方法 BootCDN（国内） :&lt;script src=&quot;https://cdn.bootcss.com/2.5.16/vue.js&quot;&gt;&lt;/script&gt; 其它（国外）：&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https:/unpkg.com/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.16/vue.js&quot;&gt;&lt;/script&gt;改变&lt;script>标签内的数字就可以手动选择 Vue.js 的不同版本。关于 Vue.js 的版本情况你可以登录 http://www.bootcdn.cn/ 或者其他网址查看。版本说明开发版本 vue.js 包含完整的警告和调试模式（建议学习过程中使用该版本）生产版本 vue.min.js 是一个更小的构建，可以获得比开发环境下更快的速度体验。（建议在实际项目中使用该版本）下面附上一张第一次成功运行的图片：]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F05%2Fwebwork%2F</url>
    <content type="text"><![CDATA[多线程处理使用Javascript执行大型计算时，经常会出现假死现象。这是因为Javascript是单线程的编程语言，运算能力比较弱。HTML5新增的Web Workers API能够创建一个不影响前台处理的后台线程，并且在这个后台线程中可以创建多个子线程，以帮助Javascript实现多线程运算的能力。通过Web Workers，用户可以将耗时较长的处理交给后台线程去执行，从而解决了HTML 5 之前因为某个处理耗时过长而不得不提前结束的尴尬。 Web Workers 基础Web workers为网页脚本提供了一种能在后台进程中运行的方法。当创建Web Worker对象后，Web Workers就可以通过postMessage()方法向任务池发送任务请求，执行完之后再通过postMessage()返回消息给创建者指定的事件处理程序，然后通过onmessage捕获返回消息，实现前后台数据的交互。 ####认识Web Workers在Web应用程序中，Web Workers是一项后台处理技术。在此之前使用Javascript创建的Web程序中，因为所有的处理都是在单线程内执行，所以如果脚本需要很长时间运行的话，程序界面会长时间处于停止响应状态。甚至当等待时间超出一定的限度，浏览器会提示脚本运行时间较长需要终端正在执行的处理。为了解决这个问题，HTML5新增了一个Web Worker API。使用这个Api，用户可以很容易地创建在后台运行的线程，这个线程被称为worker，如果将可能耗费较长时间的处理交给后台去执行的话，对用户在前台页面中执行的操作就没有影响了。尽管Web Worker的功能强大，但并不是万能的，有些事情它还做不到。例如，在Web Worker中执行的脚本不能访问该页面的window对象，因此WebWorker不能直接访问Web页面和DOM API，虽然Web worker不会导致浏览器UI停止响应，但是仍会消耗CPU周期，导致系统反应速度变慢。如果开发人员创建的Web 应用程序需要执行一些后台数据处理，但又不希望这些数据处理任务影响Web页面本身的交互性，那么可以通过Web Workers生成一个worker去处理数据任务，同时添加一个时间监听器进行监听，并与之进行数据交互。 Web Workers能够为我们做什么？ 加载一个Javascript文件，进行大量的复杂计算，而不挂起主进程，并通过postMessage,onMessage进行通信 可以在Worker中通过importScripts（url）方法加载JavaScript脚本文件 可以使用setTimeout()、clearTimeout()、setInterval()、clearInterval() 可以使用XMLHttpRequest()进行异步请求 可以访问navigator的部分属性 可以使用Javascript的核心对象 Web Workers的局限性： 不能跨域加载JavaScript Worker内代码不能访问DOM 各个浏览器对Worker的实现没有完全完善，不是每个浏览器都支持所有的新特性 使用Web Workers加载数据没有JSONP和Ajax加载数据高效浏览器支持在调用Web Workers API函数之前，应该确认浏览器是否支持。如果不支持，可以提供一些备用信息，提醒用户使用最新的浏览器。12345function testWorker()&#123; if (typeof Worker !== &quot;undefined&quot;)&#123; document.getElementById(&apos;support&apos;).innerHTML=&apos;您的浏览器不支持 HTML5 Web Worker&apos;； &#125;&#125; 创建Web Workers调用Worker构造函数可以创建一个worker线程。Worker在初始化的时候会接受一个URL参数，参数URl表示要执行的脚本文件地址，其中包含了供Worker执行的代码。worker=new Worker(&#39;xxx.js&#39;)如果要获取worker进程的返回值，可以使用onmessage时间进行监听。1234var myWorker=new Worker(&apos;xxx.js&apos;);myWorker.onmessage=function(event)&#123; alert(&apos;Called back by the worker&apos;)；&#125;； 在上面的代码中，第一行代码将创建和运行worker进程，第二行设置worker的onmessage属性，绑定事件处理函数，当worker的postmessge()方法被调用时，这个被绑定的事件处理函数就会被调用。对于由多个JavaScript文件组成的应用程序来说，可以通过包含script元素的方式，在页面加载的时候同步加载JavaScript文件。由于Web Workers没有访问Document对象的权限，所以在worker中只能使用importScripts()方法导入其他JavaScript文件。importScripts（）是全局函数，该函数可以将脚本或库导入到它们的作用域中，导入的JavaScript文件只会在某一个已有的Worker中加载和执行。多个脚本的导入同样也可以使用importScripts（）函数，它们会按顺序执行。importScripts（）可以接受空的参数或多个脚本URl参数。(在后台线程中使用)123importScripts（）;importScripts（&apos;foo.js&apos;）;importScripts（&apos;foo.js&apos;,&apos;bar.js&apos;） JavaScript会加载列出的每一个脚本文件，然后运行并初始化。这些脚本中的任何全局对象都可以被worker使用。importScripts（）方法下载脚本的顺序可能不一样，但执行的顺序一定是按importScripts（）方法中列出的顺序进行，而且是同步的，在所有脚本加载完并运行结束后importScripts（）才会返回。Web Worker能够嵌套使用，以创建子Worker。用户可以创建多个子worker。子worker必须寄宿于同一个父页面下，且它的URL必须与父worker的地址同源，这样可以很好的维持它们的依赖关系。Web Workers可以使用setTimeout（）和setInterval()。如果希望Web Worker进程周期性地运行而不是不停地循环下去的话，使用这两个方法非常有用。用户可以通过Worker对象的onmessage事件获取后台线程反馈的消息。使用postMessage（）方法可以给后台线程发送消息。发送的消息是文本数据，但也可以是任何Javascript对象，需要通过JSON对象的stringify（）方法将其转换成文本数据。在线程调用的Javascript脚本文件中，所有可用的变量、函数和类的说明如下：self：self关键字用来表示本线程范围内的作用域。postMessage：向创建线程的源窗口发送消息。（myWorker.postMessage()是在源窗口向后台线程发送消息）onmessage：后台线程接受源窗口消息的事件句柄（myworker.onmessage（）是源窗口接受后台线程消息的事件句柄)importScripts（URL）：在后台线程中导入其它Javascript脚本文件。navigator对象：与window.navigator对象类似，具有appName、platform、userAgent、appVersion属性。sessionStorage/localStorage:在线程中可以使用web Storage。XMLHttpRequest:在线程中可以处理ajax请求。Web Workers：在线程中可以嵌套线程。setTimeout()/setInterval():在线程中可以实现定时处理。close：结束本线程（myworker.terminate()）eval()、isNaN()、escape()等：可以使用所有Javascript核心函数object：可以创建和使用本地对象WebSockets：可以使用Web Sockets API向服务器发送和接收消息 Web Workers通信使用后台线程不能访问页面或窗口对象，但是并不代表后台线程不能与页面进行数据交互。为了实现页面与Web Workers通信，可以调用postMessage函数传入所需数据。同时将建立一个监听器，用来监听由Web Workers 发送到页面的消息。为建立页面与worker之间的通信，首先要在页面中添加对postMessage（）函数的调用:123document.getElementById(&apos;helloButton&apos;).onclick=function()&#123; worker.postMessage(&apos;你好&apos;)；&#125; 当用户单击按钮后，相应消息会发送到worker，然后将事件监听器添加到页面中，用来监听从worker发来的消息。1234worker.addEventListener(&apos;message&apos;,messageHandler,true);function messageHandler(e)&#123; //来自worker的处理信息&#125; 编写HTML5 Web Workers Javascript文件。在该文件中，需要添加时间监听器以监听发来的消息，并且通过调用postMessage函数实现与页面之间的通信。为了完成页面与Web Workers之间的通信功能。首先，添加代码调用postMessage函数。123function messageHandler(e)&#123; postMessage(&apos;worker说：&apos;+e.data+&apos; too&apos;);&#125; 接下来，在Web Workers Javascript文件中添加事件监听器。以处理从页面发来的消息。接收到信息后马上调用messageHandler函数以保证信息能够及时返回。通过postMessage函数对象传递到Workers或者从中返回对象，这些将自动转换成JSON格式。(在workers中的对象不能包含函数和循环引用，因为JSON不支持它们)123var onmessage=function(e)&#123; postMessage(e.data);&#125;; 在Web Workers脚本中如果发生未处理的错误。会引发Web Workers对象的错误事件。特别是在调式用到Web Workers脚本时，对错误事件的监听器就显得尤为重要了。下面显示的Web Workers Javascript文件中的错误处理函数，它将错误记录在控制台上。123function errorHandler（e）&#123; console.log(e.message,e);&#125; 为了处理错误，还必须在主页上添加一个事件监听器：worker.addEventListener(&#39;error&#39;,errorHandler,true);当worker运行发生错误时，它的onerror事件就会被触发。该事件不会冒泡，并且可以取消。要取消该事件可以使用proventDefault()方法。该错误事件有三个属性：message：可读的错误信息filename：发生错误的脚本文件名称lineno：发生错误的脚本所在的行数Web Workers不能自行终止，但能够被启用它们的页面所终止，通用terminate()函数可以终止后台进程。被终止的Web Workers将不再响应任何消息或者执行任何其它的计算。终止之后，Worker不能被重新启动，但可以使用相同的URL创建一个新的worker。worker.terminate() 案例：使用Web Workers注意：由于一些浏览器不支持读取本地文件，所以为了保证测试效果，建议将测试代码放在服务器上进行测试。【示例1】本例演示了如何使用Web Worker在控制台显示一条提示信息。(1)主页文件：12345678910111213141516171819&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;//WEB页主线程var worker = new Worker(&quot;worker.js&quot;);//创建一个Worker对象并向它传递将在新线程中执行的脚本的URLworker.postMessage(&quot;hello world&quot;);//向worker发送数据worker.onmessage = function(evt) &#123;//接收worker传过来的数据函数 console.log(evt.data); //输出worker发送来的数据&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; (2)后台线程文件（worker.js）：123456onmessage = function(evt) &#123; var d = evt.data; //通过evt.data获得发送来的数据 postMessage(d); //将获取到的数据发送会主线程&#125; 通过上面的实例可以看出来，Web Workers包括两个部分： 定义主页线程 通过worker =new Worker（url）加载一个Javascript文件，创建一个worker，同时返回一个worker实例 通过worker.postMessage（data）方法向worker发送数据 通过worker.onmessage事件接受worker响应的数据 使用worker.terminate()可以终止一个worker执行 定义worker线程 通过postMessage（data）向主线程发送数据 绑定onmessage事件接受主线程发送过来的数据【示例2】本例演示如何创建Web workers，手动控制Web workers与页面进行通信的一般方法，同时设置如何处理异常，以及如何停止worker 任务处理。(1)主页文件：1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;p id=&quot;support&quot;&gt;你的浏览器不支持 HTML5 Web Workers&lt;/p&gt;&lt;button id=&quot;stopButton&quot; &gt;停止任务&lt;/button&gt;&lt;button id=&quot;helloButton&quot; &gt;发送消息&lt;/button&gt;&lt;script&gt;function stopWorker() &#123; worker.terminate(); &#125;function messageHandler(e) &#123; console.log(e.data);&#125;function errorHandler(e) &#123; console.warn(e.message, e);&#125;function loadDemo() &#123; if( typeof (Worker) !== &quot;undefined&quot;) &#123; document.getElementById(&quot;support&quot;).innerHTML = &quot;你的浏览器支持HTML5 Web Workers&quot;; worker = new Worker(&quot;worker.js&quot;); worker.addEventListener(&quot;message&quot;, messageHandler, true); worker.addEventListener(&quot;error&quot;, errorHandler, true); document.getElementById(&quot;helloButton&quot;).onclick = function() &#123; worker.postMessage(&quot;ok&quot;); &#125; document.getElementById(&quot;stopButton&quot;).onclick = stopWorker; &#125;&#125;window.addEventListener(&quot;load&quot;, loadDemo, true);&lt;/script&gt; (2)后台线程文件（worker.js）：1234function messageHandler(e) &#123; postMessage(&quot;worker says: &quot; + e.data );&#125;addEventListener(&quot;message&quot;, messageHandler, true); 【示例3】使用addEventListener方法注册后台线程的响应事件比较麻烦，我们可以把它修改为下面这种传统的写法：(1)主页文件1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;p id=&quot;support&quot;&gt;你的浏览器不支持 HTML5 Web Workers&lt;/p&gt;&lt;button id=&quot;stopButton&quot; &gt;停止任务&lt;/button&gt;&lt;button id=&quot;helloButton&quot; &gt;发送消息&lt;/button&gt;&lt;script&gt;window.onload = function() &#123; if( typeof (Worker) !== &quot;undefined&quot;) &#123; document.getElementById(&quot;support&quot;).innerHTML = &quot;你的浏览器支持HTML5 Web Workers&quot;; worker = new Worker(&quot;worker.js&quot;); worker.onmessage = function(e) &#123; console.log(e.data); &#125; worker.onerror = function(e) &#123; console.warn(e.message, e); &#125; document.getElementById(&quot;helloButton&quot;).onclick = function() &#123; worker.postMessage(&quot;ok&quot;); &#125; document.getElementById(&quot;stopButton&quot;).onclick = function() &#123; worker.terminate(); &#125;; &#125;&#125;&lt;/script&gt; (2)后台线程文件（worker.js）:123onmessage = function(e) &#123; postMessage(&quot;worker says: &quot; + e.data );&#125; 实战案例 后台运算本示例设计一个文本框，允许用户在该文本框输入数字，然后点击计算按钮，在后台计算从1到给定数值的和。虽然对于从1到给定数值的求和计算只需要一个求和公式就可以了，本示例为了展示后台线程的使用方法，采取循环计算的方法。传统方法：12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;function calculate() &#123; var num = parseInt(document.getElementById(&quot;num&quot;).value, 10); var result = 0; for (var i = 0; i &lt;= num; i++) &#123; result += i; &#125; alert(&quot;合计值为&quot; + result + &quot;。&quot;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入数值:&lt;input type=&quot;text&quot; id=&quot;num&quot;&gt;&lt;button onClick=&quot;calculate()&quot;&gt;计算&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 虽然在文本框中输入较小的值时，不会有什么延迟问题。但是当用户在该文本框中输入特别巨大的数字，浏览器运行时间明显延迟。Web Workers方法：(1):主页文件123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;// 创建执行运算的线程var worker = new Worker(&quot;SumCalculate.js&quot;);//接收从线程中传出的计算结果worker.onmessage = function(event) &#123; //消息文本放置在data属性中,可以是任何JavaScript对象. alert(&quot;合计值为&quot; + event.data + &quot;。&quot;);&#125;;function calculate() &#123; var num = parseInt(document.getElementById(&quot;num&quot;).value, 10); //将数值传给线程 worker.postMessage(num);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入数值:&lt;input type=&quot;text&quot; id=&quot;num&quot;&gt;&lt;button onclick=&quot;calculate()&quot;&gt;计算&lt;/button&gt;&lt;/body&gt; (2)后台线程文件（SumCalculate.js）123456789onmessage = function(event) &#123; var num = event.data; var result = 0; for (var i = 0; i &lt;= num; i++) result += i; //向线程创建源送回消息 postMessage(result);&#125; 数值过滤在Web应用中，建议用户将非及时性的任务处理放在后台实现，以减轻前台的压力。本示例设计在页面上随机生成一个整数的数组，然后将该整数数组传入线程，让后台帮助挑选出该数组中可以被3整除的数字，然后显示在页面表格中。(1)在前台脚本中随机生成整数数组，然后送到后台线程挑选出能够被3整除的数字，再传回前台脚本，在前台脚本中根据挑选结果动态表格中的行、列，并将挑选出来的数字显示在表格中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var intArray=new Array(200);//随机数组var intStr=&quot;&quot;;//生成200个随机数for(var i=0;i&lt;200;i++)&#123; intArray[i]=parseInt(Math.random()*200); if(i!=0) intStr+=&quot;;&quot;; //用分号作随机数组的分隔符 intStr+=intArray[i]; &#125;//向后台线程提交随机数组var worker = new Worker(&quot;script.js&quot;);worker.postMessage(intStr);//从线程中取得计算结果worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;) &#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0) &#123;//如果该行不存在，则添加行 tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123;//如果该行存在，则获取该行 tr=document.getElementById(&quot;tr&quot;+j); &#125; //添加列 td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)后台线程文件12345678910111213141516onmessage = function(event) &#123; var data = event.data; var returnStr; //将3的倍数拼接成字符串并返回 var intArray=data.split(&quot;;&quot;); //返回字符串中数字分隔符为; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++) &#123; if(parseInt(intArray[i])%3==0) //能否被3整除 &#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //返回3的倍数拼接成的字符串&#125; 并发处理利用线程可以嵌套的特性，可以在Web应用中实现多个任务并发处理，这样能够提高Web应用程序的执行效率和反应速度。同时通过线程嵌套把一个较大的后台任务切分成几个子线程，在每个子线程中各自完成一部分相对独立的任务。本示例在上一节示例基础上，把主页脚本中随机生成数组的工作放在后台线程中，然后使用另一个子线程在随机数组中挑选可以被3整除的数字。对于数组的传递以及挑选结果的传递均采用JSON对象来进行转换，以验证是否能在线程之间进行Javascript对象的传递工作。(1)在主页面中定义一个线程。设计不向该线程发送数据，在onmessage事件回调函数中进行后期数据处理，并把返回的数据显示在页面中。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var worker = new Worker(&quot;script.js&quot;);worker.postMessage(&quot;&quot;);// 从线程中取得计算结果worker.onmessage = function(event) &#123;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)在后台主线程文件script.js中，随机生成200个整数构成的数组，然后把这个数组提交到子线程，在子线程中可以把能被3整除的数字挑选出来，然后送回主线程。主线程再把挑选结果送回页面进行显示。1234567891011121314onmessage=function(event)&#123; var intArray=new Array(200); for(var i=0;i&lt;200;i++) intArray[i]=parseInt(Math.random()*200); var worker; //创建子线程 worker=new Worker(&quot;worker2.js&quot;); //把随机数组提交给子线程进行挑选工作 worker.postMessage(JSON.stringify(intArray)); worker.onmessage = function(event) &#123; //把挑选结果返回主页面 postMessage(event.data); &#125;&#125; (3)设计子线程的任务处理代码。子线程在接收到的随机数组中挑选能够被3整除的数字，然后拼接成字符串并返回。12345678910111213141516onmessage = function(event) &#123; //还原整数数组 var intArray= JSON.parse(event.data); var returnStr; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++)&#123; if(parseInt(intArray[i])%3==0)&#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //关闭子线程 close(); &#125; 在子线程中向发送源发送回消息后，如果该子线程不再使用的话，应该使用close语句关闭子线程。(4)在页面的主线程回调函数中处理后台线程返回的数据，并将这些数据显示在页面中。12345678910111213141516171819202122worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;)&#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0)&#123; tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123; tr=document.getElementById(&quot;tr&quot;+j); &#125; td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;; 线程通信本示例继续在前面示例的基础上，将创建随机数组的工作也放到一个单独的子线程中，在该线程中创建随机数组，然后将随机数组传递到另一个子线程中进行能够被3整除的数字挑选工作，最后把挑选结果传递回主页面进行显示。设计思路：当主线程嵌套多个子线程时，子线程之间可以通过下面几个步骤进行通信。 先创建发送数据的子线程 执行子线程中的任务，然后把要传递的数据发送给主线程 在主线程接收到子线程传回来的消息时，创建接收数据的子线程，然后把发送数据的子线程中返回的消息传递给接收数据的子线程 执行接收数据子线程中的代码操作步骤：(1)完成主页面的设计。包括HTML结构和CSS样式。在主页脚本中创建一个主线程，定义请求数据为空，在主线程响应事件onmessage回调函数中处理后台返回的处理数据，并把它们显示在页面中。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var worker = new Worker(&quot;script.js&quot;);worker.postMessage(&quot;&quot;);// 从线程中取得计算结果worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;)&#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0)&#123; tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123; tr=document.getElementById(&quot;tr&quot;+j); &#125; //添加列 td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)修改主线程中的代码。在主线程中定义一个子线程（发送数据），让其随机生成200个数字，并返回这个随机数组。在该子线程的回调函数中再定义一个子线程（接受数据），把接受到的随机数组传递给它，并接收该线程过滤后的数组。1234567891011121314151617181920onmessage=function(event)&#123; var worker; //创建发送数据的子线程 worker=new Worker(&quot;worker1.js&quot;); worker.postMessage(&quot;&quot;); worker.onmessage = function(event) &#123; //接收子线程中数据:创建好的随机数组 var data=event.data; //创建接收数据子线程 worker=new Worker(&quot;worker2.js&quot;); //把从发送数据子线程中发回消息传递给接收数据的子线程 worker.postMessage(data); worker.onmessage = function(event) &#123; //获取接收数据子线程中传回数据，本示例中为挑选结果 var data=event.data; //把挑选结果发送回主页面 postMessage(data); &#125; &#125;&#125; (3)在发送数据的子线程中创建一个200个整数构成的随机数组。然后把它转换为字符串并返回，最后关闭该子线程。1234567onmessage = function(event) &#123; var intArray=new Array(200); for(var i=0;i&lt;200;i++) intArray[i]=parseInt(Math.random()*200); postMessage(JSON.stringify(intArray)); close();&#125; (4)在接受数据子线程中对接受到的随机数组中挑选能被3整除的数字，然后拼接成字符串并返回。12345678910111213141516onmessage = function(event) &#123; //还原整数数组 var intArray= JSON.parse(event.data); var returnStr; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++)&#123; if(parseInt(intArray[i])%3==0)&#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //关闭子线程 close(); &#125; Fibonacchi数列运算Fibonacci数列以递归的方式进行定义：F0=0；F1=1；Fn=F(n-1)+F（n-2）（n&gt;2）使用Javascript实现Fibonacci数列运算的一般方法为：123var fibonacci =function(n) &#123; return n &lt;2? n : arguments.callee(n -1) + arguments.callee(n -2);&#125;; 当计算工作量较大的时候，非常有可能造成浏览器罢工，可以使用Web Workers将数列计算过程放入一个后台线程里。(1)主页文件：123456789101112131415161718&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;web worker fibonacci&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; onload =function()&#123; var worker =new Worker(&apos;fibonacci.js&apos;); worker.addEventListener(&apos;message&apos;, function(event) &#123; console.log(event.data); &#125;, false); worker.postMessage(40); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; (2)后台线程文件（fibonacci.js）1234567var fibonacci =function(n) &#123; return n &lt;2? n : arguments.callee(n -1) + arguments.callee(n -2);&#125;;onmessage =function(event) &#123; var n = parseInt(event.data, 10); postMessage(fibonacci(n));&#125;;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F25%2F%E6%96%B0%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[“Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E; rv:11.0) like Gecko”（i1） “Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36”（）chorm “Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36 OPR/54.0.2952.60”（）opra “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2”（safari） “Mozilla/5.0 (Windows NT 6.1; WOW64; rv:59.0) Gecko/20100101 Firefox/59.0”（fifox）]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F23%2F%E6%89%93%E4%BB%96%2F</url>
    <content type="text"><![CDATA[var d1=Date(); //返回一个字符串（string），没有getDate等日期对象方法，内容为当前时间var d2=new Date(); //返回一日期对象，可以调用getDate()，内容为当前时间var d3=Date(“2000-1-1”);//返回一个字符串（string），内容仍旧为当前时间，也就是不受参数影响var d4=new Date(“2000-1-1”);//返回一日期对象，可以调用getDate()，内容为2000年元旦getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。getMonth() 从 Date 对象返回月份 (0 ~ 11)。getFullYear() 从 Date 对象以四位数字返回年份。getYear() 请使用 getFullYear() 方法代替。getHours() 返回 Date 对象的小时 (0 ~ 23)。getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。getTime() 返回 1970 年 1 月 1 日至今的毫秒数。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F23%2Fmath%2F</url>
    <content type="text"><![CDATA[Math 对象注释：Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。Math 对象属性E 返回算术常量 e，即自然对数的底数（约等于2.718）。LN2 返回 2 的自然对数（约等于0.693）。LN10 返回 10 的自然对数（约等于2.302）。LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。PI 返回圆周率（约等于3.14159）。SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）。SQRT2 返回 2 的平方根（约等于 1.414）。Math 对象方法 abs(x) 返回数的绝对值。acos(x) 返回数的反余弦值。asin(x) 返回数的反正弦值。atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。ceil(x) 对数进行上舍入。cos(x) 返回数的余弦。exp(x) 返回 e 的指数。floor(x) 对数进行下舍入。log(x) 返回数的自然对数（底为e）。max(x,y) 返回 x 和 y 中的最高值。min(x,y) 返回 x 和 y 中的最低值。pow(x,y) 返回 x 的 y 次幂。random() 返回 0 ~ 1 之间的随机数。round(x) 把数四舍五入为最接近的整数。sin(x) 返回数的正弦。sqrt(x) 返回数的平方根。tan(x) 返回角的正切。toSource() 返回该对象的源代码。valueOf() 返回 Math 对象的原始值。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F24%2F%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[const命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。123const PI=3.14;console.log(PI) //3.14PI=3 //Uncaught TypeError: Assignment to constant variable const声明的变量不得改变，这就意味着，const一旦声明变量就必须立刻初始化，不能留到以后赋值。1const PI;//Uncaught SyntaxError: Missing initializer in const declaration const的作用域和let命令相同：只在声明的块级作用域内有效。 const声明的变量也是不提升，同样存在暂时性死区，只能在声明的位置后使用。 本质const实际上保证的并不是变量的值不可改变，而是const变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F24%2F%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[标签语句]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F24%2Flet%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[1.函数参数的默认值ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。123456function log(x,y=&apos;world&apos;)&#123; console.log(x,y)&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello 参数变量是默认声明的，所以不能再次用let或者const再次声明。？？？ 箭头函数基本用法ES6 允许使用”箭头”（=&gt;）定义函数。123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。12345let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;//Uncaught SyntaxError: Unexpected token :let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);//不报错 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。12let foo = () =&gt; &#123; a: 1 &#125;;foo() // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。1let fn = () =&gt; void doesNotReturn(); https://blog.csdn.net/wendelle/article/details/51804633]]></content>
  </entry>
  <entry>
    <title><![CDATA[Javascript数据类型]]></title>
    <url>%2F2018%2F04%2F13%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Javascript是弱类型语言，对于数据类型的规范比较松散。 基本数据类型Javascript定义了六种基本数据类型。null：空值。表示不存在，当为对象的属性赋值为null，表示删除该属性。undefined：未定义。当声明变量，而没有赋值时会显示该值。number：数值。string：字符串。boolean：布尔值。object：对象。其中前面五种又被称为原始类型，最后一种被称为引用类型。原始类型在内存中占有固定大小的空间，它们的值直接存放在栈空间，我们可以按值访问。引用类型的值大小不确定，我们不能直接将它保存到栈内存中。我们可以在栈内存中存放地址，指向堆内存中的对象。当查询引用类型的值时，先从栈中读取内存地址，然后再通过地址找到堆中的值。原始类型和引用类型最大的区别就在于传值和传址。传值：1234var a=1;var b=a;b=2;console.log(a); //1 b获取的是a值的一份复制，b的改变不影响a。传址：1234var obj1=new Object();var obj2=obj1;obj2.name=&quot;Name2&quot;;console.log(obj1.name); //Name2 obj1赋值给obj2，实际上是将自己保存的地址复制了一份给obj2，然后两者都指向同一个堆内对象，当改变堆内对象时，对两者都会有影响。附：栈内存和堆内存：栈（stack）：由编译器自动分配和释放内存。堆（heap）：一般由程序员手动分配和释放，如果没有手动释放，在程序结束时由操作系统自动释放。 数据类型的检测使用typeof运算符可以检测数据的基本类型。12345678alert(typeof 1); // 返回字符串&quot;number&quot;alert(typeof &quot;1&quot;); // 返回字符串&quot;string&quot;alert(typeof true); // 返回字符串&quot;boolean&quot;alert(typeof &#123;&#125;); // 返回字符串&quot;object&quot;alert(typeof []); // 返回字符串&quot;object &quot;alert(typeof function()&#123;&#125;); // 返回字符串&quot;function&quot;alert(typeof null); // 返回字符串&quot;object&quot;alert(typeof undefined); // 返回字符串&quot;undefined&quot; typeof以字符串的形式返回上述六种基本类型。但是Javascript把null归为object数据类型，而function（）{}归为function类型。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>原始类型</tag>
        <tag>引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F12%2F%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[title： Javascript插件 – 轮播 Date： 2018-04-12 00:00:00 tag： carousel category： [Bootstrap,Bootstrap插件]轮播是灯箱广告的一种样式，也是图片展示的一种方式。轮播插件的结构比较复杂，与折叠插件一样需要多层嵌套。1.设计轮播包含框，定义carousel类样式，设计ID值。&lt;div id=&quot;box&quot; class=&quot;carousel&quot;&gt;&lt;/div&gt;.carousel {position: relative;}2.在轮播包含框内设计两个子容器，用来设计轮播标识图标框和轮播信息框。并分别添加.carousel_indicators和.carousel-inner类。1234&lt;div id=&quot;box&quot; class=&quot;carousel&quot;&gt; &lt;ol class=&quot;carousel-indicators&gt;&lt;/ol&gt; &lt;div class=&quot;carousel-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516.carousel-indicators &#123; position: absolute; bottom: 10px; left: 50%; z-index: 15; width: 60%; padding-left: 0; margin-left: -30%; text-align: center; list-style: none;&#125;.carousel-inner &#123; position: relative; width: 100%; overflow: hidden;&#125; &lt;ol class=”carousel-indicators”>&lt;/ol>包含框用来定义指示图标，显示当前图片的播放顺序，在li标签里使用data-target指定目标包含容器，使用data-slide-to定义播放顺序的下标。123456&lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#box&quot; data-slide-to=&quot;0&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#box&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#box&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt;&lt;/ol&gt;``` .carousel-indicators li { display: inline-block; width: 10px; height: 10px; margin: 1px; text-indent: -999px; cursor: pointer; background-color: #000 \9; background-color: rgba(0, 0, 0, 0); border: 1px solid #fff; border-radius: 10px;}.carousel-indicators .active { width: 12px; height: 12px; margin: 0; background-color: #fff;}12&lt;div class=&quot;carousel-inner&quot;\&gt;包含框准备放置要轮播的图片和说明文字。&lt;div class=&quot;carousel-inner&quot;&gt;包含框内包含&lt;div class=&quot;item&quot;&gt;子框。&lt;div class=&quot;item&quot;&gt;子框用来包含轮播项目，轮播项目可以包含两个部分：一部分是图片，一部分是图片描述(添加.carousel-caption类)。 标题 描述文本 1在轮播框的最后插入两个控制按钮，使用carousel-control类定义按钮样式，left和right定义按钮靠齐位置；使用data-slide定义按钮控制的行为方式，data-slide=“prev”表示向左滑动，data-slide=“next”表示向右滑动。 定义按钮形状 定义按钮形状`]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F12%2F%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[title： 事件处理–鼠标事件 date： 2018-04-11 00:00:01 tag： 鼠标事件 category： Javascript鼠标事件时Web开发中最常用的事件类型。鼠标事件类型有：click：单击鼠标左键时发生，如果右键也按下则不会发生。当用户的焦点在按钮上，并按了回车键时，同样会触发该事件。dbclick：双击鼠标左键时会发生，如果右键也按下则不会发生。mousedown：单击任意一个鼠标按钮时发生。mouseout：鼠标指针位于某个元素上，且将要移出边界时发生mouseover：鼠标移出某个元素，到另一个元素上时发生mouseup：松开一个鼠标按钮时发生mousemove：鼠标在某个元素上时持续发生 鼠标点击鼠标点击事件包括四个：click，dbclick，mousedown，mouseup。当这些处理函数的返回值为false时，会禁止绑定对象的默认行为。 鼠标移动鼠标经过鼠标来源当一个事件发生后，可以使用事件对象的target属性获取发生事件的节点元素。如果在IE事件模型中实现相同的目标，可以使用srcElement属性。1234567891011121314151617&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt;var div = document.getElementsByTagName(&quot;div&quot;)[0];div.onmouseover = function(e)&#123; var e = e || window.event; var o = e.target || e.srcElement; alert(o.tagName); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当鼠标移过页面的div元素时，会弹出提示框，提示当前元素的节点名称。在DOM事件模型中，还定义了currentTarget属性，当事件在传播过程中时（如捕获和冒泡），该属性值和target属性值不同。因此，一般在事件处理函数中，应该使用该属性而不是this关键词获取当前对象。除了在使用上面提到过的通用事件属性外，如果想获取鼠标指针来移动哪个元素，在DOM事件模型中，可以使用relatedTarget属性来获取当前事件对象的相关节点元素；而在IE事件模型中，可以使用fromElement获取mouseover事件中鼠标移到过的元素，使用toElement属性获取在mouseout事件中鼠标移到的文档元素。1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;div元素&lt;/div&gt;&lt;script&gt;var div = document.getElementsByTagName(&quot;div&quot;)[0];div.onmouseover = function(e)&#123; var e = e || window.event; var o = e.relatedTarget || e.fromElement; alert(o.tagName);&#125;div.onmouseout = function(e)&#123; var e = e || window.event; var o = e.relatedTarget || e.toElement; alert(o.tagName);&#125;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 当鼠标移到div元素上时，会弹出“BODY”字符提示信息，说明鼠标指针是从body元素过来的；而移开鼠标指针时，又弹出“BODY”字符提示信息，说明离开div元素将要移到的元素。 鼠标定位鼠标按键]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap -- 导航条]]></title>
    <url>%2F2018%2F04%2F10%2Fnavbar%2F</url>
    <content type="text"><![CDATA[导航条是在应用或者网站中作为导航页头的响应式基础组件。他们在移动设备上可以折叠，且在视口宽度增加时逐渐变为水平展开模式。 定义导航条导航条是一个长方形区块，其中可以包含导航或按钮，以方便用户执行导航操作。Bootstrap 3.0 使用 navbar 类定义导航条包含框。&lt;nav class=&quot;navbar&quot;&gt;&lt;/nav&gt;如果不是使用&lt;nav>标签包裹 navbar 类，而是使用 &lt;div> 标签的话，务必为导航条设置 role=”navigation” 属性，这样能够让辅助设备的用户明确知道这是一个导航区域。&lt;div class=&quot;navbar&quot; role=&quot;navigation&quot;&gt;&lt;/div&gt;123456.navbar&#123; position:relative; min-height:50px; margin-bottom:20px; border:1px solid transparent;&#125; 导航条的颜色Bootstrap 3.0 为导航条设置了两种背景颜色，navbar-default和navbar-inverse。navbar-default1234.navbar-default &#123; background-color: #f8f8f8; border-color: #e7e7e7;&#125; navbar-inverse1234.navbar-inverse &#123; background-color: #222; border-color: #080808;&#125; 导航条的位置Bootstrap 3.0 为导航条设置了三种位置，navbar-fixed-top、navbar-fixed-bottom 和 navbar-static-top。navbar-fixed-top 类可以让导航条固定在顶部。12345678.navbar-fixed-top&#123; position: fixed; right: 0; left: 0; z-index: 1030; top: 0; border-width: 0 0 1px;&#125; navbar-fixed-bottom 类可以让导航条固定在底部。123456789.navbar-fixed-bottom&#123; position: fixed; right: 0; left: 0; z-index: 1030; bottom: 0; margin-bottom: 0; border-width: 1px 0 0;&#125; navbar-static-top 类可以创建一个与页面等宽度的静止的导航条，它会随着页面向下滚动而消失。1234.navbar-static-top &#123; z-index: 1000; border-width: 0 0 1px;&#125; 导航条的结构1.导航条的第一个子元素应该是 .container 或者 .container-fluid,不然使用 bootlint 检测工具会报错；2.导航条的内容包括在容器内部；3.容器内部只能两个部分的内容：导航条的头部（navbar-header）、导航条折叠菜单（navbar-collapse）；4.导航条的头部包括：logo/brand和按钮5.导航条的折叠菜单包括：菜单、按钮、搜索框、链接、文本等等一个导航条的基本结构应该包含如下内容：12345678910&lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; ... &lt;/div&gt; &lt;div classs=&quot;navbar-collapse&quot;&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 导航条的内容品牌图标对于导航条左边一直显示的品牌文字或者品牌图标，你可以用&lt;a>标签包裹，并添加 navbar-brand 类。123&lt;div class=&quot;navbar-header&quot;&gt; &lt;a href=&quot;&quot; class=&quot;navbar-brand&quot;&gt;品牌文字&lt;/a&gt;&lt;/div&gt; 如果想要添加品牌图标的话可以在&lt;a>标签内添加&lt;img>标签。1234567.navbar-brand &#123; float: left; height: 50px; padding: 15px 15px; font-size: 18px; line-height: 20px;&#125; 表单如果希望在导航条中放置一个表单，需要为表单框添加 navbar-form 类样式,可以让表单有一个良好的垂直居中的效果。 按钮对于不包裹在&lt;form>中的按钮对象，应该加上navbar-btn类样式，可以确保其在导航条中垂直居中。1234.navbar-btn &#123; margin-top: 8px; margin-bottom: 8px;&#125; 注意：在navbar-nav内，navbar-btn和标准的按钮类都不应该被用在&lt;a>元素上。 文本当在导航条中放置文本时，应把文本包裹在 .navbar-text中，以便设置正确的行距和颜色，普通文本通常使用&lt;p>标签。123&lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;p class=&quot;navbar-text&quot;&gt;普通文本&lt;/p&gt;&lt;/nav&gt; 1234567891011.navbar-text &#123; margin-top: 15px; margin-bottom: 15px;&#125;@media (min-width: 768px) &#123; .navbar-text &#123; float: left; margin-right: 15px; margin-left: 15px; &#125;&#125; 链接当在导航条中放置链接时，应把链接包裹在 .navbar-link 中，以便设置正确的颜色和反色。但是注意，添加 .navbar-link 类只是设置链接文字的颜色，如果想让链接文字居中显示的话还需同时设置 .navbar-text 类。123&lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;p class=&quot;navbar-text&quot;&gt;&lt;a href=&quot;&quot; class=&quot;navbar-link&quot;&gt;&lt;/p&gt; &lt;/nav&gt; 响应式导航条响应式导航条：在PC和平板中默认显示所有的内容；但在手机中导航条默认只显示”LOGO/Brand”,以及一个”菜单折叠展开按钮”,只有在单击折叠按钮后才显示所有的菜单项。]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>navbar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 基础]]></title>
    <url>%2F2018%2F04%2F08%2Fjs%2F</url>
    <content type="text"><![CDATA[Javascript 是面向 Web 的编程语言，并获得了所有网页浏览器的支持，是目前应用最广泛的编程语言之一，也是网页设计和 Web 应用必须掌握的基本工具。 Javascipt的发展历史1995年2月Netscape公司发布]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap -- 表单]]></title>
    <url>%2F2018%2F04%2F08%2F%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[表单控件单独的表单控件会被自动赋予一些全局样式。所有设置了 .form-control 类的 &lt;input>、&lt;textarea> 和 &lt;select> 元素都将被默认设置宽度属性为 width: 100%;。 将 label 元素和前面提到的控件包裹在 .form-group 中可以获得最好的排列。(上下布局)123456&lt;form method=&quot;&quot; action=&quot;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;userName&quot;&gt;用户名：&lt;/label&gt; &lt;input class=&quot;form-control&quot; type=&quot;text&quot; id=&quot;userName&quot;/&gt; &lt;/div&gt;&lt;/form&gt; 123456789101112131415161718.form-control &#123; display: block; width: 100%; height: 34px; padding: 6px 12px; font-size: 14px; line-height: 1.42857143; color: #555; background-color: #fff; background-image: none; border: 1px solid #ccc; border-radius: 4px; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); -webkit-transition: border-color ease-in-out .15s, -webkit-box-shadow ease-in-out .15s; -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s; transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s;&#125; 123.form-group &#123; margin-bottom: 15px;&#125; 注意：不要将表单组直接和输入框组混合使用。建议将输入框组嵌套到表单组中使用。 内联表单为 &lt;form> 元素添加 .form-inline 类可以设计整个表格结构以行内显示。该规则只适用于视口（viewport）至少在 768px 宽度时（视口宽度再小的话就会使表单折叠）。12345678910&lt;form method=&quot;&quot; action=&quot;&quot; class=&quot;form-inline&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;userName&quot;&gt;用户名：&lt;/label&gt; &lt;input class=&quot;form-control&quot; type=&quot;text&quot; id=&quot;userName&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;userPsw&quot;&gt;密码：&lt;/label&gt; &lt;input class=&quot;form-control&quot; type=&quot;password&quot; id=&quot;userPsd&quot;/&gt; &lt;/div&gt;&lt;/form&gt; 水平排列的表单通过为表单添加 .form-horizontal 类，并联合使用 Bootstrap 预置的栅格类，可以将 label 标签和控件组水平并排布局。这样做将改变 .form-group 的行为，使其表现为栅格系统中的行（row），因此就无需再额外添加 .row 了。1234567891011121314&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputEmail3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;inputEmail3&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputPassword3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword3&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 被支持的控件Bootstrap支持所有的标准表单控件，同时对不同表单标签进行优化和扩展。 输入框Bootstrap支持大部分常用输入型表单控件，还支持所有 HTML5 类型的输入控件： text、password、datetime、datetime-local、date、month、time、week、number、email、url、search、tel 和 color。使用这些控件时，必须指明type属性值。 文本域支持多行文本的表单控件。可根据需要改变 rows 属性。&lt;textarea class=&quot;form-control&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt; 单选按钮和复选框单选按钮（）是一个圆形的选择框。当选中单选按钮时，圆形按钮的中心会出现一个圆点。多个单选按钮可以合并为一个单选按钮组，单选按钮组中的name值必须相同。单选按钮组同一时刻只能选择一个，其作用是“多选一”，一般包括有默认值，否则不符合逻辑。使用checked属性可以定义选中的按钮。复选框（）可以同时选择多个，每个复选框都是一个独立的对象，且必须有一个唯一的名称。它的外观是一个矩形框，当选中某项时，矩形框中会出现小对号。]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
      <tags>
        <tag>form-control</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F30%2F%E6%96%B0%E6%96%87%E6%A1%A3tem%2F</url>
    <content type="text"><![CDATA[title： Vue 2.0 学习之旅 – Templatedate： 2018-03-30tag： [Template] category：[Vue]模板会替换挂载元素，挂载元素内部的内容不会显示。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F30%2Fprop%2F</url>
    <content type="text"><![CDATA[title： Vue 2.0 学习之旅（）– 组件(二)date： 2018-03-30tag： [组件组合，Prop] category：[Vue,Vue组件]组件设计初衷就是配合使用的，最常见的就是形成父子组件的关系。在A组件之中使用组件B，两者之间就必然需要相互通信：父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告诉父组件。然而，通过一个良好定义的接口来尽可能将父子组件解耦也是很重要的。这保证了每个组件的代码可以在相互隔离的环境中书写和理解，从而提高了其可维护性和复用性。在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过事 prop 给子组件下发数据，子组件通过事件给父组件发送消息。 Prop 类型：数组或对象 props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。使用Prop传递数据组件实例的作用域是孤立的。这意味着不能在子组件的模块内直接引用父组件的数据，父组件的数据需要通过prop才能下发到子组件中。子组件要显式地用 props 选项声明它预期的数据：]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F30%2F%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[title： Vue 2.0 学习之旅–组件（一）date： 2018-03-30tag： [组件注册，全局注册，局部注册] category：[Vue,Vue组件]组件(compone)是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象（除了一些根级特有的选项）并提供相同的生命钩子。 使用组件全局注册要注册一个全局组件，可以使用：Vue.component(tagname,option)。例如：123Vue.component(&apos;myname&apos;,&#123; //选项&#125;) 注意： 对于自定义标签的命名，Vue.js 不强制遵循 W3C 规则（小写，并且包含一个短杠），尽管这被认为是最佳实践。 组件在注册之后，就可以作为自定义元素使用。注意确保在初始化根实例之前注册组件。如果未在初始化根实例之前注册组件，程序会报错。就算是全局注册，也是有范围限制的。 局部注册不必要将每个组件都注册到全局。可以通过某个 Vue 实例/组件的实例选项 components 注册仅在其作用域中可用的组件： DOM模板解析注意事项当使用 DOM 作为模板时（例如，使用 el 选项来把 Vue 实例挂载到一个已有内容的元素上），你会受到 HTML 本身的一些限制，因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容。尤其要注意，像 &lt;ul>、&lt;ol> 、&lt;table>、&lt;select> 这样的元素里允许包含的元素有限制，而另外一些像&lt;option> 这样的元素只能出现在某些特定元素的内部。在自定义组件中使用这些受限制的元素时会导致一些问题，例如：自定义组件会被当作无效的内容，因此会导致错误的渲染结果。(但是不会报错)变通的方案是使用特殊的 is 特性。(暂时不作说明）注意：如果是使用以下来源之一的字符串模板，则没有这些限制： &lt;script type=”text/x-template”> Javascript 内联模板字符串 .Vue 组件（此处内容待补充）data 必须是函数构造Vue实例时传入的各种选项大多都可以在组件使用。只有一个例外：data 必须是函数，否则程序会报错。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F30%2Fv-model%2F</url>
    <content type="text"><![CDATA[title： Vue 2.0 学习之旅–指令(六)date： 2018-03-30tag： [表单输入相关，v-model] category：[ Vue,Vue 指令]v-model 指令可以用于在 &lt;input> 和 &lt;textarea> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。注意： v-model会忽略所有表单元素的 value 、checked 、selected 特性的初始值，而总是将 Vue 实例的数据作为数据来源。应该通过 Javascript 在组件的 data 选项中声明初始值。 对于需要使用输入法（如中文、日文、韩文等）的语言，v-model 不会在输入法组合文字过程中得到更新。如果要处理这个过程，可以使用 input 事件。 v-model文本多行文本复选框单选按钮选择框]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F30%2Fv-on%2F</url>
    <content type="text"><![CDATA[title： Vue 2.0 学习之旅 – 指令date： 2018-03-30 00:00:01tag： [事件处理，v-on] category：[Vue,Vue指令]可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 Javascript 代码。1234567891011&lt;div id=&quot;example-1&quot;&gt; &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt; &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;&lt;/div&gt;var example1 = new Vue(&#123; el: &apos;#example-1&apos;, data: &#123; counter: 0 &#125;&#125;) 如果事件处理的逻辑很复杂，直接将 Javascript 代码写在 v-on 指令中是不可行的。v-on 指令还可以接收一个需要调用的方法名称。(在 methods 对象中定义方法)123456789101112131415161718&lt;div id=&quot;example-2&quot;&gt; &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;&lt;/div&gt;var example2 = new Vue(&#123; el: &apos;#example-2&apos;, data: &#123; name: &apos;Vue.js&apos; &#125;, methods: &#123; greet: function (event) &#123; alert(&apos;Hello &apos; + this.name + &apos;!&apos;) if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;) 在绑定到一个方法的时候，我们也可以直接在内联 Javascript 语句中调用方法。 v-on事件修饰符修饰符是以点开头的指令后缀来表示的。Vue.js 为 v-on 提供了事件修饰符。 .stop .prevent .capture .self .once]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F30%2Fv-bind%2F</url>
    <content type="text"><![CDATA[title： Vue 2.0 学习之旅（）–指令date： 2018-03-30tag： [Class 与 Style绑定，v:bind] category：[ Vue,Vue 指令]操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且容易出错。因此，在 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串类型之外，还可以是对象或者数组。 v-bind绑定HTML Class对象语法我们可以传给 v-bind：class 一个对象，以动态地切换class：&lt;div v-bind:class=&quot;{active:isActive}&quot;&gt;上面的语法表示 active 这个class 存在与否取决于数据属性 isActive的真假。你可以在属性中传入更多地属性来动态的切换多个class。v-bind：class 指令也可以与普通的 class 属性共存。绑定的数据对象不必定义在模板里：我们也可以在这里绑定一个返回对象的计算属性。 数组语法我们也可以传给 v-bind：class 一个数组，以应用一个 class 列表：如果你想根据条件切换列表中的class，可以用三元表达式： 用在组件上当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。 绑定内联样式对象语法数组语法自动添加前缀多重值]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F30%2Fvtexthtml%2F</url>
    <content type="text"><![CDATA[title： Vue 2.0 学习之旅（）–指令date： 2018-03-30tag： [v-text,v-html,v-pre,v-once,v-cloak] category：[ Vue,Vue 指令]v-textv-htmlv-prev-oncev-cloak]]></content>
  </entry>
  <entry>
    <title><![CDATA[github 文件管理]]></title>
    <url>%2F2018%2F03%2F30%2Fgithub%2F</url>
    <content type="text"><![CDATA[github文件管理##1.在电脑的任意位置处新建一个文件夹 2.进入文件夹，鼠标右键选择 git-bash-here 3.输入命令 git init 4.输入命令 git clone （你的仓库地址） 5.输入命令 git rm -r 6.输入命令 git rm 7.输入命令 git commit -m 8.输入命令 git push origin master]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 学习之旅 -- 指令]]></title>
    <url>%2F2018%2F03%2F29%2F%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[指令（Directives）是带有 v- 前缀的特殊属性。指令属性的值预期是单个 Javascript 表达式（v-for 是例外情况）。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM。&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 元素。 参数一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML 属性：&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。 修饰符修饰符 (Modifiers) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 缩写Vue.js 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写： v-bind 缩写12345&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt; v-on 缩写12345&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt; v-text指令v-text指令用于操作元素当中的文本，其实际作用与“Mustache”语法(双大括号)的效果是一致的。但是注意，使用v-text会替换掉元素内的所有文本内容，如果只想替换掉其中的部分文本，需要使用“Mustache”语法(双大括号)。 v-html指令v-html指令和v-text指令的区别在于，v-text将HTML的标签当做纯文本进行输出，而v-html会将HTML的标签解析后再输出。注意下面代码的输出结果的区别： v-once指令v-once指令用于执行一次性的插值，当数据改变时，插值处的内容不会更新。该指令会影响到该节点上的所有数据绑定： v-if指令v-if指令用于控制一个元素的显示与否，当表达式的值为真，则显示该元素；当表达式的值为假，则不显示该元素： v-showv-show指令和v-if指令一样，都是用来控制一个元素的显示与否，当表达式的值为真，则显示该元素；当表达式的值为假，则不显示该元素。v-if和v-show的区别在于，v-if在表达式为假的时候，将该元素节点从DOM树上删除；而v-show在表达式为假的时候，是为该元素追加display：none，的属性。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>指令</tag>
        <tag>缩写</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F29%2Fhexo%2F</url>
    <content type="text"><![CDATA[github与hexo关联1.在电脑任意位置处新建一个文件夹 2.进入文件夹，鼠标右键选择gitbash 3.输入命令hexo init]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 学习之旅--指令]]></title>
    <url>%2F2018%2F03%2F29%2Fv-for%2F</url>
    <content type="text"><![CDATA[v-for 指令主要用于迭代，迭代的目标可以是数组、对象、值和组件。 数组的 v-forv-for 指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组，item是数组元素迭代的别名。在 v-for块 中，我们拥有对父作用域属性的完全访问权限。v-for 还支持一个可选的第二个参数作为当前的索引。你可以用 of 代替 in 作为分隔符。 对象的 v-for你可以用 v-for 通过一个对象的属性来迭代。你也可以提供第二个参数为键名。你还可以提供第三个参数为索引。key、数组更新检测、对象更新检测、显示过滤/排序结果此处暂不作说明。 值的 v-forv-for 也可以是整数。v-for on a &lt;template> 暂不作说明。v-for with v-if当 v-for 和 v-if 处于同一节点的时候，v-for 的优先级比 v-if 的更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。而如果你的目的是有条件的跳过循环的执行，那么可以将 v-if 置于外层元素上。 组件的 v-for关于组件的 v-for 暂时不作说明，等学完组件之后再来更新。]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue指令</category>
      </categories>
      <tags>
        <tag>列表渲染，v-for</tag>
      </tags>
  </entry>
</search>
