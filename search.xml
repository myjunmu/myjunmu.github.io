<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue 2.0 学习之旅（一）--安装]]></title>
    <url>%2F2018%2F09%2F29%2Fvue%20%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[从今天开始学习前端框架 Vue，该系列的文章主要记录自己在 Vue 的学习过程中所了解到的一些基础知识。 兼容性Vue不支持 IE8 及以下版本。 辅助工具在使用 Vue 时推荐在浏览器上安装 Vue Devtools。它允许你在一个更友好的界面中审查和调试 Vue 应用。 Vue.js 安装教程直接下载直接下载vue.js文件，然后通过&lt;script>标签引用。&lt;script src=&quot;/地址/vue.js&quot;&gt;&lt;/script&gt; CDN 方法 BootCDN（国内） :&lt;script src=&quot;https://cdn.bootcss.com/2.5.16/vue.js&quot;&gt;&lt;/script&gt; 其它（国外）：&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https:/unpkg.com/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.16/vue.js&quot;&gt;&lt;/script&gt;改变&lt;script>标签内的数字就可以手动选择 Vue.js 的不同版本。关于 Vue.js 的版本情况你可以登录 http://www.bootcdn.cn/ 或者其他网址查看。版本说明开发版本 vue.js 包含完整的警告和调试模式（建议学习过程中使用该版本）生产版本 vue.min.js 是一个更小的构建，可以获得比开发环境下更快的速度体验。（建议在实际项目中使用该版本）下面附上一张第一次成功运行的图片：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 学习之 -- Vue 实例]]></title>
    <url>%2F2018%2F09%2F29%2Fvue%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Vue实例每个Vue应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的：123var vm=new Vue(&#123; //选项&#125;) 当创建一个 Vue 实例对象之后，你可以传入一个选项对象。一个 Vue 应用由一个通过 new Vue 创建的根 Vue 实例，以及可嵌套的、可复用的组件树构成。 数据与方法当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。当这些数据改变时，视图会重新渲染。但是只有在实例被创建时 data 中存在的属性才是响应式的。也就是说如果你添加一个新的属性，随后对b的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你可以设置一些初始值。唯一的例外是使用 object.freeze(),这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $ ,以便和用户定义的属性区分开来。]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue实例</category>
      </categories>
      <tags>
        <tag>Vue实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表格]]></title>
    <url>%2F2018%2F01%2F05%2FHTML%20%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[表格由 &lt;table> 标签来定义。每个表格均有若干行（由 &lt;tr> 标签定义），每行被分割为若干单元格（由 &lt;td> 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。【示例1】本例演示一个最简单的表格。12345678910&lt;table&gt; &lt;tr&gt; &lt;td&gt;row1,col1&lt;/td&gt; &lt;td&gt;row1,col2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,col1&lt;/td&gt; &lt;td&gt;row2,col2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格标签&lt;table>、&lt;tr>、&lt;td>&lt;table>、&lt;tr>、&lt;td>标签是表格的基础，分别用来定义表格、定义表格的行、定义表格的列。 &lt;capition>&lt;capition>标签用来定义表格的标题。caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。1234567891011&lt;table&gt; &lt;caption&gt;表格的标题&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;row1,col1&lt;/td&gt; &lt;td&gt;row1,col2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,col1&lt;/td&gt; &lt;td&gt;row2,col2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;th>&lt;th>标签定义表格表头单元格。HTML 表单中有两种类型的单元格： 表头单元格 - 包含表头信息（由 th 元素创建） 标准单元格 - 包含数据（由 td 元素创建）th 元素内部的文本通常会呈现为居中的粗体文本，而 td 元素内的文本通常是左对齐的普通文本。1234567891011&lt;table&gt; &lt;caption&gt;表格的标题&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;row1,col1&lt;/th&gt; &lt;th&gt;row1,col2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,col1&lt;/td&gt; &lt;td&gt;row2,col2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;thead>、&lt;tbody>、&lt;tfoot> &lt;thead>、&lt;tbody>、&lt;tfoot>标签分别用于定义表格的页眉、表格的主体和表格的页脚。如果您使用 thead、tfoot 以及 tbody 元素，您就必须使用全部的元素。它们的出现次序是：thead、tfoot、tbody，页面中的显示顺序为thead、tbody、tfoot。您必须在 table 元素内部使用这些标签。 、 以及 很少被使用，这是因为糟糕的浏览器支持。1234567891011121314151617181920212223242526&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt; &lt;td&gt;$180&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;February&lt;/td&gt; &lt;td&gt;$80&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &lt;col> 标签为表格中一个或多个列定义属性值。col 元素是仅包含属性的空元素。如需对全部列应用样式，&lt;col> 标签很有用，这样就不需要对各个单元和各行重复应用样式了。您只能在 table 或 colgroup 元素中使用 &lt;col> 标签。123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot;&gt; .left&#123; background-color:red; &#125; .middle&#123; background-color:yellow &#125; .right&#123; background-color:blue &#125;&lt;/style&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt; &lt;caption&gt;表格的标题&lt;/caption&gt; &lt;col class=&apos;left&apos;&gt; &lt;col class=&apos;middle&apos;&gt; &lt;col class=&apos;right&apos;&gt; &lt;tr&gt; &lt;th&gt;row1,col1&lt;/th&gt; &lt;th&gt;row1,col2&lt;/th&gt; &lt;th&gt;row1,col3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,col1&lt;/td&gt; &lt;td&gt;row2,col2&lt;/td&gt; &lt;td&gt;row2,col3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; colgroup 标签用于对表格中的列进行组合，以便对其进行格式化。通过使用 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。只能在 table 元素内使用 标签。(测试结果好像是colgroup和col是一样的) 表格属性table属性 在 HTML5 中，table标签仅支持 “border” 属性，并且只允许使用值 “” 或 “1”。 “”,表示表格单元周围没有边框 “1”,表示表格单元周围添加边框设置表格border的css样式，只会影响表格最外围的边框显示，而不会影响单元格的边框显示效果。12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot;&gt; table&#123; border:3px solid #f0f; &#125;&lt;/style&gt;&lt;body&gt;&lt;table border=&quot;1&quot;&gt; &lt;caption&gt;表格的标题&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;row1,col1&lt;/th&gt; &lt;th&gt;row1,col2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row2,col1&lt;/td&gt; &lt;td&gt;row2,col2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; HTML5之前支持的属性（现在使用依然有效果，但是建议使用css样式实现相同的效果）align：规定表格相对于周围元素的对齐方式。通常来说，HTML 表格的前后都会出现折行。通过运用 align 属性，可实现其他 HTML 元素围绕表格的效果。取值为：left、center、right。bgcolor：规定表格的背景颜色width：规定表格的宽度height：规定表格的高度summary：规定表格的摘要，但是不会产生任何视觉上的变化rules：规定内侧边框的哪些部分是可见的，不建议使用frame：规定外侧边框的哪些部分是可见的，不建议使用cellpadding:规定单元边沿与其内容之间的空白cellspacing：规定单元格之间的空白tr属性 HTML5中不支持tr的任何属性。 HTML5以前支持的tr属性align：定义表格行的内容对齐方式，取值为right、left、center、justify、charbgcolor：规定表格行的颜色char：规定根据哪个字符进行文本对齐，没有浏览器支持charoff：规定第一个对齐字符的偏移量，没有浏览器支持valign：规定表格行中内容的垂直对齐方式,取值为top、middle、bottom、baselinetd属性 HTML5中支持的属性colspan：规定此单元格可横跨的列数rowspan：规定此单元格可横跨的行数headers：规定与单元格相关的一个或多个表头单元格，没有实际上的视觉效果 HTML5以前支持的属性abbr：规定单元格中内容的缩写版本，没有实际上的视觉效果align：规定单元格内容的水平对齐方式，取值为right、left、center、justify、charaxis：用于对单元格进行分类，没有浏览器支持bgcolor：规定单元格的背景颜色char：规定根据哪个字符进行文本对齐，没有浏览器支持charoff：规定第一个对齐字符的偏移量，没有浏览器支持height：规定表格单元格的高度width：规定表格单元格的宽度nowrap：规定单元格的内容不换行scope：将表头单元与数据单元相关联，没有实际上的视觉效果valign：规定表格单元格的垂直对齐方式,取值为top、middle、bottom、baselineth属性 HTML5中支持的属性colspan：规定此单元格可横跨的列数rowspan：规定此单元格可横跨的行数headers：规定与单元格相关的一个或多个表头单元格，没有实际上的视觉效果scope：规定此表头单元格是否是行、列、行组或列组的头部，没有实际上的视觉效果 HTML5以前支持的属性和td标签支持的属性是一样的。caption属性 HTML5中没有caption支持的属性 HTML5以前支持的属性align：规定标题的对齐方式。取值：left、right、top、bottom，该属性将 caption 作为块元素向表格的左边、右边、顶部、底部进行对齐。thead、tbody、tfoot属性 HTML5中没有thead、tbody、tfoot支持的属性 HTML5以前支持的属性（align、valign、char、charoff）]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML列表]]></title>
    <url>%2F2018%2F01%2F04%2FHTML%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[HTML支持有序、无序和定义列表。 列表标签无序列表ul无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。无序列表始于 &lt;ul> 标签。每个列表项始于 &lt;li>。12345&lt;ul&gt; &lt;li&gt;熊猫&lt;/li&gt; &lt;li&gt;老虎&lt;/li&gt; &lt;li&gt;狮子&lt;/li&gt;&lt;/ul&gt; 有序列表ol有序列表也是一列项目，列表项目使用数字进行标记。有序列表始于 &lt;ol> 标签。每个列表项始于 &lt;li> 标签。12345&lt;ol&gt; &lt;li&gt;熊猫&lt;/li&gt; &lt;li&gt;老虎&lt;/li&gt; &lt;li&gt;狮子&lt;/li&gt;&lt;/ol&gt; 定义列表自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 标签开始。每个自定义列表项以 开始。每个自定义列表项的定义以 开始。123456&lt;dl&gt; &lt;dt&gt;熊猫&lt;/dt&gt; &lt;dd&gt;一种带有黑眼圈的动物&lt;/dd&gt; &lt;dt&gt;老虎&lt;/dt&gt; &lt;dd&gt;一种非常凶猛的动物&lt;/dd&gt;&lt;/dl&gt; 其它标签与表格相关的标签还有&lt;dir>和&lt;menu>,其中&lt;dir>标签HTML5不支持，&lt;menu>标签没有浏览器支持。 列表属性ul属性 HTML5不再支持ul的所有属性 HTML5以前的属性compact：规定列表的呈现效果比正常情况下小巧，没有浏览器支持type：规定列表的项目符号的类型，取值：disc(实心圆，默认)，square(实心方块)，circle(空心圆) ol属性 HTML5支持的属性：reversed：规定列表顺序为降序(如5,4,3,2,1)start：规定有序列表的起始值（该属性没有CSS的替代方案）type：规定在列表中使用的标记类型取值： 1 默认。十进制数字 (1, 2, 3, 4)。 a 字母顺序的有序列表，小写 (a, b, c, d)。 A 字母顺序的有序列表，大写 (A, B, C, D)。 i 罗马字母，小写 (i, ii, iii, iv)。 I 罗马字母，大写 (I, II, III, IV)。 HTML5以前的属性：compact：规定列表的呈现效果比正常情况下小巧，没有浏览器支持li属性type：规定使用哪种项目符号。取值：A、a、I、i、1、disc、square、circlevalue：规定列表项目的数字，取值为数字dl、dt、dd属性支持HTML的全局属性]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>ul</tag>
        <tag>ol</tag>
        <tag>dl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requestAnimationFrame]]></title>
    <url>%2F2018%2F01%2F03%2Fanimation%2F</url>
    <content type="text"><![CDATA[在HTML5+CSS3时代，设计Web动画可以有很多种选择。简单说明如下： 使用CSS3的animation+keyframes 使用CSS3的transition 通过HTML5的canvas作图来实现动画 借助jQuery动画来实现 使用Javascript原生的setTimeout()或者setTimeInterval()实现HTML5新增了一个动画实现的方案，也就是requestAnimationFrame()方法。 动画基础屏幕刷新频率屏幕刷新频率，即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般的电脑而言，这个频率大概是60Hz。即使当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。为什么你感觉不到这个变化？ 那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)， 所以会让你误以为屏幕上的图像是静止不动的。而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。动画原理根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新。而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。 那怎么样才能做到这种效果呢？刷新频率为60Hz的屏幕每16.7ms刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即1px。这样一来，屏幕每次刷出来的图像位置都比前一个要差1px，因此你会看到图像在移动；由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。setTimeout理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但我们会发现，利用seTimeout实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因： setTimeout的执行时间并不是确定的。在Javascript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致，从而引起丢帧现象。 那为什么步调不一致就会引起丢帧呢？首先要明白，setTimeout的执行只是在内存中对图像属性进行改变，这个变化必须要等到屏幕下次刷新时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像。假设屏幕每隔16.7ms刷新一次，而setTimeout每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：第0ms: 屏幕未刷新，等待中，setTimeout也未执行，等待中；第10ms: 屏幕未刷新，等待中，setTimeout开始执行并设置图像属性left=1px；第16.7ms: 屏幕开始刷新，屏幕上的图像向左移动了1px， setTimeout 未执行，继续等待中；第20ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=2px;第30ms: 屏幕未刷新，等待中，setTimeout开始执行并设置left=3px;第33.4ms:屏幕开始刷新，屏幕上的图像向左移动了3px， setTimeout未执行，继续等待中……从上面的绘制过程中可以看出，屏幕没有更新left=2px的那一帧画面，图像直接从1px的位置跳到了3px的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。requestAnimationFrameMozilla的Robert O’Callahan指出，CSS变换和动画的优势在于浏览器知道动画什么时候开始，因此会计算出正确的循环间隔，在恰当的时候刷新UI。而对于JavaScript动画，浏览器无从知晓什么时候开始。requestAnimationFrame()可以告诉浏览器某些JavaScript代码将要执行动画。这样浏览器可以在运行某些代码后进行适当的优化。requestAnimationFrame的特点与setTimeout相比，requestAnimationFrame最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是60Hz,那么回调函数就每16.7ms被执行一次，如果刷新率是75Hz，那么这个时间间隔就变成了1000/75=13.3ms，换句话说就是，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。除此之外，requestAnimationFrame还有以下两个优势： CPU节能：使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而requestAnimationFrame()则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame()也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。 函数节流：在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次时没有意义的，因为显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。requestAnimationFrame的使用requestAnimationFrame()方法接收一个参数，即在重绘屏幕前调用的一个函数。这个函数负责改变下一次重绘时的DOM样式。为了创建动画循环，可以像以前使用setTimeout()一样，把多个对requestAnimationFrame()的调用连缀起来。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&apos;status&apos; style=&quot;border: 1px solid black;width: 10px;height: 10px;background-color: black&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function updateProgress()&#123; var div=document.getElementById(&apos;status&apos;); div.style.width=(parseInt(div.style.width,10)+5)+&quot;%&quot;; //parseInt的第二个参数10表示十进制 if(div.style.width !=&apos;100%&apos;)&#123; requestAnimationFrame(updateProgress); &#125; &#125; requestAnimationFrame(updateProgress); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; （实际测试，不太需要考虑浏览器的兼容性，但是Safari貌似不支持。）基本语法：window.requestAnimationFrame(callback);参数说明：callback，一个指定函数的参数，该函数在下次重新绘制动画时调用。这个回调函数只有一个传参，该参数用来指示requestAnimationFrame() 开始触发回调函数的当前时间。返回值：一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。requestAnimationFrame（）解决了浏览器不知道Javascript动画什么时候开始，不知道最佳循环间隔时间的问题。如果想确定代码什么时候执行，可以在回调函数中传递一个参数，它是一个时间码（从1970年1月1日起至今的毫秒数），表示下一次重绘的实际时间。requestAnimationFrame（）会根据这个时间码设定将来的某个时刻进行重绘，而根据这个时间码，你也能知道那个时刻是什么时间。然后再优化动画就有了依据。1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&apos;status&apos; style=&quot;border: 1px solid black;width: 10px;height: 10px;background-color: black&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var start = null; var element = document.getElementById(&apos;status&apos;); element.style.position = &apos;absolute&apos;; function step(timestamp) &#123; if (!start) start = timestamp; //第一次传入后这个值就不再变化了 var progress = timestamp - start;//每次执行requestAnimationFrame(step)函数的时候，timestamp的值都会更新 element.style.left = Math.min(progress / 10, 200) + &apos;px&apos;; if (progress &lt; 2000) &#123; window.requestAnimationFrame(step); &#125; &#125; window.requestAnimationFrame(step); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实战案例设计进度条【示例1】本例设计一个进度条动画，初始div宽度为1px，在step()函数中将进度加1，然后更新到div宽度上，在进度达到100之前，一直重复这个过程。12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;test&quot; style=&quot;width:1px;height:17px;background:#0f0;&quot;&gt;0%&lt;/div&gt;&lt;input type=&quot;button&quot; value=&quot;Run&quot; id=&quot;run&quot;/&gt;&lt;script&gt;var start = null;var ele = document.getElementById(&quot;test&quot;);var progress = 0;function step(timestamp) &#123; progress += 1; ele.style.width = progress + &quot;%&quot;; ele.innerHTML=progress + &quot;%&quot;; if (progress &lt; 100) &#123; requestAnimationFrame(step); &#125;&#125;requestAnimationFrame(step);document.getElementById(&quot;run&quot;).addEventListener(&quot;click&quot;, function() &#123; ele.style.width = &quot;1px&quot;; progress = 0; requestAnimationFrame(step);&#125;, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设计粒子动画【示例2】本例模拟一个粒子动画。首先在页面上插入一个&lt;canvas>标签，然后设计一块画布，在画布上随机生成一个圆点，颜色、运动方向随机；接着从画布中央向四周运动，同时逐步增大半径；最后调用requestAnimationFrame()方法，传递回调函数为粒子生成函数，从而设计随机粒子数放射运动的效果。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html &gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;style&gt;body &#123; margin:0;padding:0; overflow: hidden; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id=&quot;motion&quot;&gt;当前浏览器不支持画布&lt;/canvas&gt;&lt;script&gt; var lastTime = 0; window.requestAnimationFrame = function(callback) &#123; var now = Date.now(); var nextTime = Math.max(lastTime + 16, now); return setTimeout(function() &#123; callback(lastTime = nextTime); &#125;,nextTime - now); &#125;; window.cancelAnimationFrame = clearTimeout; var getRandomColor = function()&#123; return &apos;#&apos;+(Math.random()*0xffffff&lt;&lt;0).toString(16); &#125; var canvas = document.getElementById(&quot;motion&quot;), c = canvas.getContext(&quot;2d&quot;), particles = &#123;&#125;, particleIndex = 0, particleNum = 0.2; canvas.width = window.innerWidth; canvas.height = window.innerHeight; function Particle()&#123; this.x = canvas.width/2; this.y = canvas.height/2; this.vx = Math.random() * 6 - 3; this.vy = Math.random() * 4 - 2; this.growth = ( Math.abs(this.vx) + Math.abs(this.vy) ) * 0.007; particleIndex++; particles[particleIndex] = this; this.id = particleIndex; this.size = Math.random() * 1; this.color = getRandomColor(); &#125; Particle.prototype.draw = function()&#123; this.x += this.vx; this.y += this.vy; this.size += this.growth; if(this.x &gt; canvas.width || this.y &gt; canvas.height)&#123; delete particles[this.id]; &#125; c.fillStyle = this.color; c.beginPath(); c.arc(this.x, this.y, this.size,0*Math.PI,2*Math.PI); c.fill(); &#125;; function animate()&#123; requestAnimationFrame( animate ); c.fillStyle = &quot;#000&quot;; c.fillRect(0,0,canvas.width,canvas.height); if(Math.random() &gt; particleNum)&#123; new Particle(); &#125; for(var i in particles)&#123; particles[i].draw(); &#125; &#125; requestAnimationFrame( animate );&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>requestAnimationFrame，Web 动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建HTML5结构]]></title>
    <url>%2F2018%2F01%2F02%2F%E6%9E%84%E5%BB%BAHTML5%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[HTML5 全面升级了文档结构的标识元素，确保文档结构更加清晰明确，容易阅读。 设计主体结构为了使文档的结构更加清晰明确，HTML5 新增与页眉、页脚、内容块等文档结构相关联的结构元素。内容块是指将HTML页面按逻辑进行分割后的区域单位。例如，对于正文页来说，导航菜单、文章正文、文章的评论等每一个部分都可称为内容块。 定义文章块article元素用来表示文档、页面中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客或报刊中的文章、一篇论坛帖子、一段用户评论或者独立的插件等。另外，一个article元素通常会有它自己的标题，一般放在一个header元素里面，有时它还有自己的脚注。当article元素嵌套使用的时候，内部的article元素必须和外部的article元素内容相关。【示例1】下面代码演示了如何使用article元素设计网络新闻展示。1234567891011121314151617181920&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;新闻&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;Twitter直播平台Periscope推出360度全景直播&lt;/h1&gt; &lt;time pubdate=&quot;pubdate&quot;&gt;2016年12月29日 18:12&lt;/time&gt; &lt;/header&gt; &lt;p&gt;新浪科技讯 北京时间12月29日晚间消息，Twitter今日在其直播平台Periscope上推出了360度视频直播服务。Twitter CEO杰克-多西（Jack Dorsey）称，只要将全景VR相机Insta360固定在智能手机上，就可以展示身边的全景世界了。目前，该功能只支持Insta360相机。&lt;/p&gt; &lt;footer&gt; &lt;p&gt;http://www.sina.com.cn&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 这个示例是一篇讲述科技新闻的文章，在header元素中嵌入了文章的标题部分，在这部分内容中，文章的标题被镶嵌在h1元素中，文章的发表日期被镶嵌在time元素中。在标题下面的p元素中，嵌入了一大段该博客文章的正文，在结尾处的footer元素中，嵌入了文章的著作权，作为脚注。整个示例的内容相对比较完整、独立，因此这部分内容使用了article元素。article元素可以嵌套使用，内层的内容在原则上需要与外层的内容相关联。例如，针对该新闻的相关评论就可以使用嵌套article元素的方式。【示例2】本例在上面代码的基础上演示如何实现artcile元素的嵌套使用。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;新闻&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;Twitter直播平台Periscope推出360度全景直播&lt;/h1&gt; &lt;time pubdate=&quot;pubdate&quot;&gt;2016年12月29日 18:12&lt;/time&gt; &lt;/header&gt; &lt;p&gt;新浪科技讯 北京时间12月29日晚间消息，Twitter今日在其直播平台Periscope上推出了360度视频直播服务。Twitter CEO杰克-多西（Jack Dorsey）称，只要将全景VR相机Insta360固定在智能手机上，就可以展示身边的全景世界了。目前，该功能只支持Insta360相机。&lt;/p&gt; &lt;footer&gt; &lt;p&gt;http://www.sina.com.cn&lt;/p&gt; &lt;/footer&gt; &lt;section&gt; &lt;h2&gt;评论&lt;/h2&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;天舞之城&lt;/h3&gt; &lt;p&gt; &lt;time pubdate datetime=&quot;2016-12-29 19:40-08:00&quot;&gt; 1小时前 &lt;/time&gt; &lt;/p&gt; &lt;/header&gt; &lt;p&gt;ok&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;header&gt; &lt;h3&gt;西子与子夕&lt;/h3&gt; &lt;p&gt; &lt;time pubdate datetime=&quot;2016-12-29 19:50-08:00&quot;&gt; 1小时前 &lt;/time&gt; &lt;/p&gt; &lt;/header&gt; &lt;p&gt;well&lt;/p&gt; &lt;/article&gt; &lt;/section&gt; &lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 定义内容块section元素用来对网站或者应用程序中页面上的内容进行分区。一个section通常由内容及其标题组成。div元素也可以用来对内容进行分区，但section元素并非一个普通的容器元素，当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div元素，而非section元素。div元素关注结构的独立性，而section元素关注内容的独立性，section中包含的内容可以单独存储到数据库中或输出到word文档中。【示例1】本例使用section元素把新歌排行榜的内容进行单独分隔。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;section&gt; &lt;h1&gt;经典儿歌TOP10&lt;/h1&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;铃儿响叮当&lt;/h3&gt; &lt;span&gt;小蓓蕾组合 《015、儿歌曲库..》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;拔萝卜&lt;/h3&gt; &lt;span&gt;小蓓蕾组合 《004、儿歌曲库..》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;数鸭子&lt;/h3&gt; &lt;span&gt;少儿歌曲 《童年的歌谣 CD1》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;你在他乡还好吗&lt;/h3&gt; &lt;span&gt;光头李进 《留在蓉城的微笑》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;小兔子乖乖&lt;/h3&gt; &lt;span&gt;小蓓蕾组合 《015、儿歌曲库..》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;爸爸妈妈听我说&lt;/h3&gt; &lt;span&gt;小葡萄 《彭野新儿歌精选》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;让我们荡起双桨&lt;/h3&gt; &lt;span&gt;小蓓蕾组合 《014、儿歌曲库..》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;儿歌：铃儿响叮当&lt;/h3&gt; &lt;span&gt;民族乐团 《胎教音乐（2）CD》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;采蘑菇的小姑娘&lt;/h3&gt; &lt;span&gt;小蓓蕾组合 《004、儿歌曲库..》&lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;h3&gt;蓝精灵&lt;/h3&gt; &lt;span&gt;儿歌 民族乐团 &lt;/span&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; article元素和section元素都是HTML5 新增的元素，它们的功能与div类似，都是用来区分不同的区域，使用方法也相似。但是它们之间也是有区别的。article元素代表文档、页面或者应用程序中独立完整的可以被外部引用的内容。例如：博客中的一篇文章、论坛中的一个帖子或者一段浏览者的评论等。因为article元素是一段独立的内容，所以article通常包含头部（header元素）、底部（footer元素）。section元素用于对网站或者应用程序中页面上的内容进行分块。一个section元素通常由内容以及标题组成。section元素需要包含一个&lt;hn>标题元素，一般不用包含头部或者底部。通常用section元素为那些有标题的内容进行分段。section元素的作用是对页面上的内容进行分块处理，如对文章分段等，相邻的section元素的内容，应该是相关的，而不是像article元素那样是独立的。【示例2】在本例中，读者能够观察到artcile元素与section元素的区别。事实上article元素可以看做是特殊的section元素。article更强调独立性、完整性，section更强调相关性。1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;潜行者m的个人介绍&lt;/h1&gt; &lt;/header&gt; &lt;p&gt;潜行者m是一个中国男人，是一个帅哥。。。。&lt;/p&gt; &lt;section&gt; &lt;h2&gt;评论&lt;/h2&gt; &lt;article&gt; &lt;h3&gt;评论者：潜行者n&lt;/h3&gt; &lt;p&gt;确实，m同学真的很帅&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h3&gt;评论者：潜行者a&lt;/h3&gt; &lt;p&gt;M今天吃药了没？&lt;/p&gt; &lt;/article&gt; &lt;/section&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 能否用artcile、section元素取代div来布局网页呢？答案是否定的，div的用处就是用来布局网页，划分大的区域。div就是用来布局大块，在不同的内容块中，我们按照需求添加article、section等内容块，并且显示其中的内容，这样才是合理的使用这些元素。 使用section元素时应注意的几个问题： 不要将section元素当做设置样式的容器，对于此类操作应使用div元素来实现 如果artcile元素、aside元素或nav元素更符合条件，不要使用section元素 不要为没有标题的内容块使用section元素【示例3】再看一个artcile和section混合使用的例子。123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;h1&gt;W3C&lt;/h1&gt; &lt;p&gt;万维网联盟（World Wide Web Consortium，W3C），又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。建立者是万维网的发明者蒂姆&amp;middot;伯纳斯-李。&lt;/p&gt; &lt;section&gt; &lt;h2&gt;CSS&lt;/h2&gt; &lt;p&gt;全称Cascading Style Sheet，级联样式表，通常又称为&quot;风格样式表（Style Sheet）&quot;，它是用来进行网页风格设计的。&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;HTML&lt;/h2&gt; &lt;p&gt;全称Hypertext Markup Language，超文本标记语言，用于描述网页文档的一种标记语言。&lt;/p&gt; &lt;/section&gt;&lt;/article&gt;&lt;/body&gt;&lt;/html&gt; 从上面的代码看，首先可以看到整个板块是一段独立的、完整的内容，因此使用artcile元素。该内容是一片关于W3C的介绍，文章分为3段，每一段都有一个独立的标题，因此使用了两个section元素。 定义导航块nav元素时一个可以用来做页面导航的链接组，其中的导航元素链接到其他页面或当前页面的其他部分。并不是所有的链接组都要放进nav元素，主要将主要的、基本的链接组放进nav元素中即可。例如，在页脚中通常会有一组链接，包括服务条款、首页、版权声明等，这时使用footer元素最恰当。一个页面中可以拥有多个nav元素，作为页面整体或不同部分的导航。具体来说，nav元素可以适合传统导航条、侧边导航栏、页内导航、翻页操作等。【示例1】在HTML5 中，主要是导航性质的链接，就可以很方便地将其放在nav元素中。该元素可以在文档中多次出现。1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;nav&gt; &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;book.html&quot;&gt;图书&lt;/a&gt; &lt;a href=&quot;bbs.html&quot;&gt;论坛&lt;/a&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; 【示例2】在下面的示例中，页面由几部分组成，每个部分都带有链接，但只将最主要的链接放nav元素。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;技术资料&lt;/h1&gt;&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/blog&quot;&gt;博客&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;HTML5+CSS3&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#HTML5&quot;&gt;HTML5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#CSS3&quot;&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;section id=&quot;HTML5&quot;&gt; &lt;h1&gt;HTML5&lt;/h1&gt; &lt;p&gt;HTML5特性说明&lt;/p&gt; &lt;/section&gt; &lt;section id=&quot;CSS3&quot;&gt; &lt;h1&gt;CSS3&lt;/h1&gt; &lt;p&gt;CSS3特性说明。&lt;/p&gt; &lt;/section&gt; &lt;footer&gt; &lt;p&gt; &lt;a href=&quot;?edit&quot;&gt;编辑&lt;/a&gt; | &lt;a href=&quot;?delete&quot;&gt;删除&lt;/a&gt; | &lt;a href=&quot;?add&quot;&gt;添加&lt;/a&gt; &lt;/p&gt; &lt;/footer&gt;&lt;/article&gt;&lt;footer&gt; &lt;p&gt;&lt;small&gt;版权信息&lt;/small&gt;&lt;/p&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 第一个nav元素用于页面导航，将页面跳转到其他页面上去；第二个nav元素放置在article元素中，表示在文章中内容进行导航。 定义侧边栏aside元素用来表示当前页面或文章的附属信息部分，它可以包含于当前页面或主要内容相关的引用、侧边栏、广告、导航条，以及其他类似的有别于主要内容的部分。【示例1】作为主要内容的附属信息部分，包含在article中，其中的内容可以是与当前文章有关的参考名词、名词解释等。12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;h1&gt;HTML5&lt;/h1&gt;&lt;/header&gt;&lt;article&gt; &lt;h1&gt;HTML5历史&lt;/h1&gt; &lt;p&gt;HTML5草案的前身名为Web Applications 1.0，于2004年被WHATWG提出，于2007年被W3C 接纳，并成立了新的 HTML工作团队。HTML5 的第一份正式草案已于2008年1月22日公布。2014年10月28日，W3C的HTML工作组正式发布了HTML5的官方推荐标准。&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;名词解释&lt;/h1&gt; &lt;dl&gt; &lt;dt&gt;WHATWG&lt;/dt&gt; &lt;dd&gt;Web Hypertext Application Technology Working Group,HTML工作开发组的简称，目前与W3C组织同时研发HTML5。&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;W3C&lt;/dt&gt; &lt;dd&gt;World Wide Web Consortium，万维网联盟，万维网联盟是国际著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。&lt;/dd&gt; &lt;/dl&gt; &lt;/aside&gt;&lt;/article&gt;&lt;/body&gt; 【示例2】作为页面或站点全局的附属信息部分，在artcile元素之外使用。最典型的形式是侧边栏，其中的内容可以是友情链接，博客中其他文章列表、广告单元等。123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;aside&gt; &lt;nav&gt; &lt;h2&gt;友情链接&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;网站1&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;网站2&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;网站3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/aside&gt;&lt;/body&gt;&lt;/html&gt; 友情链接在博客类网站比较常见，一般放在左右两侧的边栏中，因此可以使用aside元素来实现。但是该侧边栏又是具有导航作用的，因此嵌套了一个nav元素。 定义主要区域main元素表示网页中的主要内容。主要内容区域是指与网页标题或应用程序中本页主要功能直接相关或进行扩展的内容。该区域为每一个网页中特有的内容，不能包含整个网站的导航条、版权信息、网站logo、公共搜索表单等整个网站内容的共同内容。每个网页内部只能放置一个main元素。不能将main元素放置在任何article、aside、footer、header或nav元素内。【示例1】本例使用main元素包裹页面主要区域，这样更有利于网页内容的语义分区，同时搜索引擎也能够主动抓取主要信息，避免被辅助性文字所干扰。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;其他&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt;&lt;main&gt; &lt;h1&gt;科技新闻&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#web&quot;&gt;互联网&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#zmt&quot;&gt;自媒体&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#cycx&quot;&gt;创业创新&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;H2 id=&quot;web&quot;&gt;互联网&lt;/H2&gt; &lt;h3&gt;互联网2016：从流量为王到生产率贡献制胜&lt;/h3&gt; &lt;p&gt;白银时代，也许就是经历2015年诸神退位后，中国互联网相当长一段时间的现实。最初那些完全建立在互联网上的红利接近消耗殆尽，就像BAT在搜索、电商和社交这三大传统领域正经历的，而新的机会主要存在于互联网在各行各业的渗透，这意味着你必须同那些行业已经存在的生产者展开生产率的竞争，这将变得不再性感，挤泡沫将贯穿始终。 &lt;/p&gt; &lt;h2 id=&quot;zmt&quot;&gt;自媒体&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;高通魅族达成和解：套路的高通和魅族的套路&lt;/li&gt; &lt;li&gt;同道大叔、李叫兽先后套现上岸，2017年内容创业暗流涌动？&lt;/li&gt; &lt;li&gt;凭什么要我脱离舒适区&lt;/li&gt; &lt;/ul&gt; &lt;h2 id=&quot;cycx&quot;&gt;创业创新&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;创业者防坑手册：面对强大的投资人，你该如何正当防卫？&lt;/li&gt; &lt;li&gt;我们想要的不是微信小程序，是重新来过&lt;/li&gt; &lt;li&gt;全球首家MUJI Hotel落户深圳&lt;/li&gt; &lt;/ul&gt;&lt;/main&gt;&lt;footer&gt;Copyright © 虎嗅网 京ICP备12013432号-1&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 设计语义结构除了前面所说的几个主要的结构元素之外，HTML5内还增加了一些表示逻辑或附加信息的非主体结构元素。 定义标题栏header元素是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但也可以包含其它内容，如数据表格、搜索表单或相关的logo图片，因此整个页面的标题应该放在页面的开头。【示例1】在一个网页中可以多次使用header元素，下面显示为每个内容区块加一个header元素。12345678910111213141516&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;h1&gt;网页标题&lt;/h1&gt;&lt;/header&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;文章标题&lt;/h1&gt; &lt;/header&gt; &lt;p&gt;文章正文&lt;/p&gt;&lt;/article&gt;&lt;/body&gt; 在HTML5 中，header元素通常包含h1-h6元素，也可以包hgroup、table、form、nav等元素。只要是应该显示在头部区域的语义标签，都可以包含在header元素中。【示例2】下面是个人博客首页的头部区域代码示例，整个头部内容都放在header元素中。1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;我的博客&lt;/h1&gt; &lt;a href=&quot;#&quot;&gt;[URL]&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;[订阅]&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;[手机订阅]&lt;/a&gt; &lt;/hgroup&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;目录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;社区&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;微博我&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt;&lt;/body&gt; 定义标题组hgroup元素可以为标题或者子标题进行分组，通常它与h1-h6元素组合使用，一个内容块中的标题及其子标题可以通过hgroup元素组成一组。但是，如果文章只有一个主标题，则不需要hgroup元素。【示例1】本例显示如何使用hgroup元素把主标题、副标题和标题说明进行分组，以便让引擎更容易识别标题块。1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;主标题&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt; &lt;h3&gt;标题说明&lt;/h3&gt; &lt;/hgroup&gt; &lt;p&gt; &lt;time datetime=&quot;2017-6-20&quot;&gt;发布时间：2017年6月20日&lt;/time&gt; &lt;/p&gt; &lt;/header&gt; &lt;p&gt;新闻正文&lt;/p&gt;&lt;/article&gt;&lt;/body&gt; 定义脚注栏footer元素可以作为内容块的注脚，如在父级内容块中添加注释，或者在网页中添加版权信息等。【示例1】在HTML5 之前，要描述脚注信息，一般使用&lt;div id=’footer’&gt;标签定义包含框。123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;主标题&lt;/h1&gt; &lt;h2&gt;副标题&lt;/h2&gt; &lt;h3&gt;标题说明&lt;/h3&gt; &lt;/hgroup&gt; &lt;p&gt; &lt;time datetime=&quot;2017-03-20&quot;&gt;发布时间：2017年10月29日&lt;/time&gt; &lt;/p&gt; &lt;/header&gt; &lt;p&gt;新闻正文&lt;/p&gt;&lt;/article&gt;&lt;footer&gt; &lt;ul&gt; &lt;li&gt;关于&lt;/li&gt; &lt;li&gt;导航&lt;/li&gt; &lt;li&gt;联系&lt;/li&gt; &lt;/ul&gt;&lt;/footer&gt;&lt;/body&gt; 【示例2】与header元素一样，页面中也可以多次使用footer元素。同时可以为article或者section元素添加footer元素。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt; &lt;h1&gt;网页标题&lt;/h1&gt;&lt;/header&gt;&lt;article&gt; 文章内容 &lt;h2&gt;文章标题&lt;/h2&gt; &lt;p&gt;正文&lt;/p&gt; &lt;footer&gt;注释&lt;/footer&gt;&lt;/article&gt;&lt;section&gt; &lt;h2&gt;段落标题&lt;/h2&gt; &lt;p&gt;正文&lt;/p&gt; &lt;footer&gt;段落标记&lt;/footer&gt;&lt;/section&gt;&lt;footer&gt;网页版权信息&lt;/footer&gt;&lt;/body&gt; 定义联系信息段address元素用来在文档中定义联系信息，包括文档作者或文档编辑者名称、电子邮箱、电话号码、真实地址等。【示例1】address的用途不仅仅是用来描述电子邮箱或真实地址，还可以描述与文档相关的联系人的所有联系信息。123456789101112&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;address&gt; &lt;a href=&quot;http://www.w3.org/&quot;&gt;W3C&lt;/a&gt; &lt;a href=&quot;http://www.whatwg.org/&quot;&gt;WHATWG&lt;/a&gt; &lt;a href=&quot;http://www.mhtml5.com/&quot;&gt;HTML5研究小组&lt;/a&gt;&lt;/address&gt;&lt;/body&gt; 【示例2】也可以把footer元素、time元素与address元素结合起来使用。1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;footer&gt; &lt;section&gt; &lt;address&gt; &lt;a title=&quot;作者：MDN&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5&quot;&gt;HTML5 - Web开发者指南&lt;/a&gt; &lt;/address&gt; &lt;p&gt; 发布于： &lt;time datetime=&quot;2017-6-1&quot;&gt;2017年6月1日&lt;/time&gt; &lt;/p&gt; &lt;/section&gt;&lt;/footer&gt;&lt;/body&gt; 定义时间段HTML5 增加了一种新的元素来无歧义地、明确地对机器的时间进行编码，并且以让人易读的方式来展示它。这个元素就是time元素。【示例1】time元素代表24小时中的某个时刻或日期，表示时刻允许带时差。它可以定义很多格式的日期和时间。12345678910111213&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;time datetime=&quot;2017-11-13&quot;&gt;2017年11月13日&lt;/time&gt;&lt;time datetime=&quot;2017-11-13&quot;&gt;11月13日&lt;/time&gt;&lt;time datetime=&quot;2017-11-13&quot;&gt;我的生日&lt;/time&gt;&lt;time datetime=&quot;2017-11-13T20:00&quot;&gt;我生日的晚上8点&lt;/time&gt;&lt;time datetime=&quot;2017-11-13T20:00Z&quot;&gt;我生日的晚上8点&lt;/time&gt;&lt;time datetime=&quot;2017-11-13T20:00+09:00&quot;&gt;我生日的晚上8点的美国时间&lt;/time&gt;&lt;/body&gt; 编码时引擎读到的部分在datetime属性里，而元素的开始标记与结束标记中间的部分是显示在网页上的。datetime属性中日期与时间之间要用‘T’文字隔开。倒数第三行，时间加上Z文字表示给机器编码时使用UTC时间；倒数第二行加上了时差，表示向机器编码另一地区时间；如果是编码本地时间，则不需要添加时差。 定义发布时间pubdate属性是一个可选的布尔值属性，它可以用在article元素中的time元素上，意思是time元素代表了文章或整个网页的发布日期。123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;科技公司都变成了数据公司：但你真的了解什么是“数据工程师”吗？&lt;/h1&gt; &lt;p&gt;发布日期&lt;time datetime=&quot;2016-12-30&quot; pubdate&gt;2016-12-30 09:19&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;p&gt;在和国内外顶尖公司交流的过程中，我发现他们多数都很骄傲有一支极其专业的数据团队。这些公司花了大量的时间和精力把数据工程这件事情做到了极致，有不小规模的工程师团队，开源了大量数据技术。Linkedin 有 kafka、samza, Facebook 有 hive、presto，Airbnb有airflow、superset，我所熟悉的 Yelp 也有 mrjob…… 这些公司在数据领域的精益求精，为后来的大步前进奠定了基石。&lt;/p&gt; &lt;footer&gt; &lt;p&gt;https://www.huxiu.com/article/176524.html&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt;&lt;/body&gt; time元素不仅仅表示发布时间，还可以表示其它用途的时间，如通知、约会等。【示例2】为了避免引擎误解发布时间，使用pubdate属性可以显示地告诉引擎文章中哪个是真正的发布时间。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;科技公司都变成了数据公司：但你真的了解什么是“数据工程师”吗？&lt;/h1&gt; &lt;p&gt;发布日期&lt;time datetime=&quot;2016-12-30&quot; pubdate&gt;2016-12-30 09:19&lt;/time&gt;&lt;/p&gt; &lt;p&gt;关于&lt;time datetime=2017-1-1&gt;1月1日&lt;/time&gt;更正通知&lt;/p&gt; &lt;/header&gt; &lt;p&gt;在和国内外顶尖公司交流的过程中，我发现他们多数都很骄傲有一支极其专业的数据团队。这些公司花了大量的时间和精力把数据工程这件事情做到了极致，有不小规模的工程师团队，开源了大量数据技术。Linkedin 有 kafka、samza, Facebook 有 hive、presto，Airbnb有airflow、superset，我所熟悉的 Yelp 也有 mrjob…… 这些公司在数据领域的精益求精，为后来的大步前进奠定了基石。&lt;/p&gt; &lt;footer&gt; &lt;p&gt;https://www.huxiu.com/article/176524.html&lt;/p&gt; &lt;/footer&gt;&lt;/article&gt;&lt;/body&gt; 在这个例子中，有两个time元素，分别定义了两个日期：更正日期金和发布日期。由于都使用了time元素，所以需要使用pubdate属性表明哪个时间代表了新闻的发布时间。 实战案例设计完整的HTML5 文档结构1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;!-- 声明文档结构类型 --&gt;&lt;html lang=&apos;zh-cn&apos;&gt;&lt;!-- 规定元素内容的语言，zh-cn中文简体，en英语，fr法语&gt;&lt;head&gt;&lt;!-- 文档的头部区域 --&gt;&lt;meta charset=&apos;utf-8&apos;&gt;&lt;!-- 文档的头部区域中元数据区的字符集定义，utf-8表示国际通用的字符集编码格式 --&gt;&lt;title&gt;文档标题&lt;/title&gt;&lt;!-- 文档的头部区域的标题。title内容对于SEO来说极其重要--&gt;&lt;meta name=&apos;description&apos; content=&apos;文档描述信息&apos;&gt;&lt;!-- 文档的头部区域元数据区关于文档描述的定义 --&gt;&lt;meta name=&apos;author&apos; content=&apos;文档作者&apos;&gt;&lt;!-- 文档的头部区域元数据区关于开发人员姓名的定义 --&gt;&lt;meta name=&apos;copyright&apos; content=&apos;版权信息&apos;&gt;&lt;!-- 文档的头部区域元数据区关于版权的定义 --&gt;&lt;meta name=&apos;keywords&apos; content=&apos;&apos;&gt;&lt;!-- 文档的头部区域元数据区关于关键词的定义，有利于搜索引擎 --&gt;&lt;meta name=viewport content=width=device-width, user-scalable=no &gt;&lt;!-- 文档的头部区域对于不同接口设备的特殊声明。宽=设备宽，用户不能自行缩放 --&gt;&lt;link rel=&apos;stylesheet&apos; href=&apos;main.css&apos;&gt;&lt;!-- 文档的头部区域的样式文件引用 --&gt;&lt;script src=&apos;script.js&apos;&gt;&lt;/script&gt;&lt;!-- 文档的头部区域的JavaScript脚本文件调用 --&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt;HTML5文档的头部区域&lt;/header&gt;&lt;nav&gt;HTML5文档的导航区域&lt;/nav&gt;&lt;section&gt;HTML5文档的主要内容区域 &lt;aside&gt; HTML5文档的主要内容区域的侧边导航或菜单区 &lt;/aside&gt; &lt;article&gt; HTML5文档的主要内容区域的内容区 &lt;section&gt;以下是一个section和article的嵌套。 &lt;aside&gt; &lt;/aside&gt; &lt;article&gt; &lt;header&gt; HTML5文档的嵌套区域，可以对某个article区域进行头部和脚部的定义。这样做，可以有非常清晰和严谨的文档目录结构关系。 &lt;footer&gt; &lt;/article&gt; &lt;/section&gt; &lt;/article&gt;&lt;/section&gt;&lt;footer&gt;HTML5文档的脚部区域&lt;/footer&gt;&lt;/body&gt;&lt;/HTML&gt;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>结构化标签，语义化标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程处理 -- Web Workers]]></title>
    <url>%2F2018%2F01%2F01%2Fwebwork%2F</url>
    <content type="text"><![CDATA[使用Javascript执行大型计算时，经常会出现假死现象。这是因为Javascript是单线程的编程语言，运算能力比较弱。HTML5新增的Web Workers API能够创建一个不影响前台处理的后台线程，并且在这个后台线程中可以创建多个子线程，以帮助Javascript实现多线程运算的能力。通过Web Workers，用户可以将耗时较长的处理交给后台线程去执行，从而解决了HTML5之前因为某个处理耗时过长而不得不提前结束的尴尬。 Web Workers 基础Web workers为网页脚本提供了一种能在后台进程中运行的方法。当创建Web Worker对象后，Web Workers就可以通过postMessage()方法向任务池发送任务请求，执行完之后再通过postMessage()返回消息给创建者指定的事件处理程序，然后通过onmessage捕获返回消息，实现前后台数据的交互。 认识Web Workers在Web应用程序中，Web Workers是一项后台处理技术。在此之前使用Javascript创建的Web程序中，因为所有的处理都是在单线程内执行，所以如果脚本需要很长时间运行的话，程序界面会长时间处于停止响应状态。甚至当等待时间超出一定的限度，浏览器会提示脚本运行时间较长需要终端正在执行的处理。为了解决这个问题，HTML5新增了一个Web Worker API。使用这个Api，用户可以很容易地创建在后台运行的线程，这个线程被称为worker，如果将可能耗费较长时间的处理交给后台去执行的话，对用户在前台页面中执行的操作就没有影响了。尽管Web Worker的功能强大，但并不是万能的，有些事情它还做不到。例如，在Web Worker中执行的脚本不能访问该页面的window对象，因此WebWorker不能直接访问Web页面和DOM API，虽然Web worker不会导致浏览器UI停止响应，但是仍会消耗CPU周期，导致系统反应速度变慢。如果开发人员创建的Web 应用程序需要执行一些后台数据处理，但又不希望这些数据处理任务影响Web页面本身的交互性，那么可以通过Web Workers生成一个worker去处理数据任务，同时添加一个时间监听器进行监听，并与之进行数据交互。 Web Workers能够为我们做什么？ 加载一个Javascript文件，进行大量的复杂计算，而不挂起主进程，并通过postMessage,onMessage进行通信 可以在Worker中通过importScripts（url）方法加载JavaScript脚本文件 可以使用setTimeout()、clearTimeout()、setInterval()、clearInterval() 可以使用XMLHttpRequest()进行异步请求 可以访问navigator的部分属性 可以使用Javascript的核心对象 Web Workers的局限性： 不能跨域加载JavaScript Worker内代码不能访问DOM 各个浏览器对Worker的实现没有完全完善，不是每个浏览器都支持所有的新特性 使用Web Workers加载数据没有JSONP和Ajax加载数据高效浏览器支持在调用Web Workers API函数之前，应该确认浏览器是否支持。如果不支持，可以提供一些备用信息，提醒用户使用最新的浏览器。12345function testWorker()&#123; if (typeof Worker !== &quot;undefined&quot;)&#123; document.getElementById(&apos;support&apos;).innerHTML=&apos;您的浏览器不支持 HTML5 Web Worker&apos;； &#125;&#125; 创建Web Workers调用Worker构造函数可以创建一个worker线程。Worker在初始化的时候会接受一个URL参数，参数URl表示要执行的脚本文件地址，其中包含了供Worker执行的代码。worker=new Worker(&#39;xxx.js&#39;)如果要获取worker进程的返回值，可以使用onmessage时间进行监听。1234var myWorker=new Worker(&apos;xxx.js&apos;);myWorker.onmessage=function(event)&#123; alert(&apos;Called back by the worker&apos;)；&#125;； 在上面的代码中，第一行代码将创建和运行worker进程，第二行设置worker的onmessage属性，绑定事件处理函数，当worker的postmessge()方法被调用时，这个被绑定的事件处理函数就会被调用。对于由多个JavaScript文件组成的应用程序来说，可以通过包含script元素的方式，在页面加载的时候同步加载JavaScript文件。由于Web Workers没有访问Document对象的权限，所以在worker中只能使用importScripts()方法导入其他JavaScript文件。importScripts（）是全局函数，该函数可以将脚本或库导入到它们的作用域中，导入的JavaScript文件只会在某一个已有的Worker中加载和执行。多个脚本的导入同样也可以使用importScripts（）函数，它们会按顺序执行。importScripts（）可以接受空的参数或多个脚本URl参数。(在后台线程中使用)123importScripts（）;importScripts（&apos;foo.js&apos;）;importScripts（&apos;foo.js&apos;,&apos;bar.js&apos;） JavaScript会加载列出的每一个脚本文件，然后运行并初始化。这些脚本中的任何全局对象都可以被worker使用。importScripts（）方法下载脚本的顺序可能不一样，但执行的顺序一定是按importScripts（）方法中列出的顺序进行，而且是同步的，在所有脚本加载完并运行结束后importScripts（）才会返回。Web Worker能够嵌套使用，以创建子Worker。用户可以创建多个子worker。子worker必须寄宿于同一个父页面下，且它的URL必须与父worker的地址同源，这样可以很好的维持它们的依赖关系。Web Workers可以使用setTimeout（）和setInterval()。如果希望Web Worker进程周期性地运行而不是不停地循环下去的话，使用这两个方法非常有用。用户可以通过Worker对象的onmessage事件获取后台线程反馈的消息。使用postMessage（）方法可以给后台线程发送消息。发送的消息是文本数据，但也可以是任何Javascript对象，需要通过JSON对象的stringify（）方法将其转换成文本数据。在线程调用的Javascript脚本文件中，所有可用的变量、函数和类的说明如下：self：self关键字用来表示本线程范围内的作用域。postMessage：向创建线程的源窗口发送消息。（myWorker.postMessage()是在源窗口向后台线程发送消息）onmessage：后台线程接受源窗口消息的事件句柄（myworker.onmessage（）是源窗口接受后台线程消息的事件句柄)importScripts（URL）：在后台线程中导入其它Javascript脚本文件。navigator对象：与window.navigator对象类似，具有appName、platform、userAgent、appVersion属性。sessionStorage/localStorage:在线程中可以使用web Storage。XMLHttpRequest:在线程中可以处理ajax请求。Web Workers：在线程中可以嵌套线程。setTimeout()/setInterval():在线程中可以实现定时处理。close：结束本线程（myworker.terminate()）eval()、isNaN()、escape()等：可以使用所有Javascript核心函数object：可以创建和使用本地对象WebSockets：可以使用Web Sockets API向服务器发送和接收消息 Web Workers通信使用后台线程不能访问页面或窗口对象，但是并不代表后台线程不能与页面进行数据交互。为了实现页面与Web Workers通信，可以调用postMessage函数传入所需数据。同时将建立一个监听器，用来监听由Web Workers 发送到页面的消息。为建立页面与worker之间的通信，首先要在页面中添加对postMessage（）函数的调用:123document.getElementById(&apos;helloButton&apos;).onclick=function()&#123; worker.postMessage(&apos;你好&apos;)；&#125; 当用户单击按钮后，相应消息会发送到worker，然后将事件监听器添加到页面中，用来监听从worker发来的消息。1234worker.addEventListener(&apos;message&apos;,messageHandler,true);function messageHandler(e)&#123; //来自worker的处理信息&#125; 编写HTML5 Web Workers Javascript文件。在该文件中，需要添加时间监听器以监听发来的消息，并且通过调用postMessage函数实现与页面之间的通信。为了完成页面与Web Workers之间的通信功能。首先，添加代码调用postMessage函数。123function messageHandler(e)&#123; postMessage(&apos;worker说：&apos;+e.data+&apos; too&apos;);&#125; 接下来，在Web Workers Javascript文件中添加事件监听器。以处理从页面发来的消息。接收到信息后马上调用messageHandler函数以保证信息能够及时返回。通过postMessage函数对象传递到Workers或者从中返回对象，这些将自动转换成JSON格式。(在workers中的对象不能包含函数和循环引用，因为JSON不支持它们)123var onmessage=function(e)&#123; postMessage(e.data);&#125;; 在Web Workers脚本中如果发生未处理的错误。会引发Web Workers对象的错误事件。特别是在调式用到Web Workers脚本时，对错误事件的监听器就显得尤为重要了。下面显示的Web Workers Javascript文件中的错误处理函数，它将错误记录在控制台上。123function errorHandler（e）&#123; console.log(e.message,e);&#125; 为了处理错误，还必须在主页上添加一个事件监听器：worker.addEventListener(&#39;error&#39;,errorHandler,true);当worker运行发生错误时，它的onerror事件就会被触发。该事件不会冒泡，并且可以取消。要取消该事件可以使用proventDefault()方法。该错误事件有三个属性：message：可读的错误信息filename：发生错误的脚本文件名称lineno：发生错误的脚本所在的行数Web Workers不能自行终止，但能够被启用它们的页面所终止，通用terminate()函数可以终止后台进程。被终止的Web Workers将不再响应任何消息或者执行任何其它的计算。终止之后，Worker不能被重新启动，但可以使用相同的URL创建一个新的worker。worker.terminate() 案例：使用Web Workers注意：由于一些浏览器不支持读取本地文件，所以为了保证测试效果，建议将测试代码放在服务器上进行测试。【示例1】本例演示了如何使用Web Worker在控制台显示一条提示信息。(1)主页文件：12345678910111213141516171819&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;//WEB页主线程var worker = new Worker(&quot;worker.js&quot;);//创建一个Worker对象并向它传递将在新线程中执行的脚本的URLworker.postMessage(&quot;hello world&quot;);//向worker发送数据worker.onmessage = function(evt) &#123;//接收worker传过来的数据函数 console.log(evt.data); //输出worker发送来的数据&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; (2)后台线程文件（worker.js）：123456onmessage = function(evt) &#123; var d = evt.data; //通过evt.data获得发送来的数据 postMessage(d); //将获取到的数据发送会主线程&#125; 通过上面的实例可以看出来，Web Workers包括两个部分： 定义主页线程 通过worker =new Worker（url）加载一个Javascript文件，创建一个worker，同时返回一个worker实例 通过worker.postMessage（data）方法向worker发送数据 通过worker.onmessage事件接受worker响应的数据 使用worker.terminate()可以终止一个worker执行 定义worker线程 通过postMessage（data）向主线程发送数据 绑定onmessage事件接受主线程发送过来的数据【示例2】本例演示如何创建Web workers，手动控制Web workers与页面进行通信的一般方法，同时设置如何处理异常，以及如何停止worker 任务处理。(1)主页文件：1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;p id=&quot;support&quot;&gt;你的浏览器不支持 HTML5 Web Workers&lt;/p&gt;&lt;button id=&quot;stopButton&quot; &gt;停止任务&lt;/button&gt;&lt;button id=&quot;helloButton&quot; &gt;发送消息&lt;/button&gt;&lt;script&gt;function stopWorker() &#123; worker.terminate(); &#125;function messageHandler(e) &#123; console.log(e.data);&#125;function errorHandler(e) &#123; console.warn(e.message, e);&#125;function loadDemo() &#123; if( typeof (Worker) !== &quot;undefined&quot;) &#123; document.getElementById(&quot;support&quot;).innerHTML = &quot;你的浏览器支持HTML5 Web Workers&quot;; worker = new Worker(&quot;worker.js&quot;); worker.addEventListener(&quot;message&quot;, messageHandler, true); worker.addEventListener(&quot;error&quot;, errorHandler, true); document.getElementById(&quot;helloButton&quot;).onclick = function() &#123; worker.postMessage(&quot;ok&quot;); &#125; document.getElementById(&quot;stopButton&quot;).onclick = stopWorker; &#125;&#125;window.addEventListener(&quot;load&quot;, loadDemo, true);&lt;/script&gt; (2)后台线程文件（worker.js）：1234function messageHandler(e) &#123; postMessage(&quot;worker says: &quot; + e.data );&#125;addEventListener(&quot;message&quot;, messageHandler, true); 【示例3】使用addEventListener方法注册后台线程的响应事件比较麻烦，我们可以把它修改为下面这种传统的写法：(1)主页文件1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;p id=&quot;support&quot;&gt;你的浏览器不支持 HTML5 Web Workers&lt;/p&gt;&lt;button id=&quot;stopButton&quot; &gt;停止任务&lt;/button&gt;&lt;button id=&quot;helloButton&quot; &gt;发送消息&lt;/button&gt;&lt;script&gt;window.onload = function() &#123; if( typeof (Worker) !== &quot;undefined&quot;) &#123; document.getElementById(&quot;support&quot;).innerHTML = &quot;你的浏览器支持HTML5 Web Workers&quot;; worker = new Worker(&quot;worker.js&quot;); worker.onmessage = function(e) &#123; console.log(e.data); &#125; worker.onerror = function(e) &#123; console.warn(e.message, e); &#125; document.getElementById(&quot;helloButton&quot;).onclick = function() &#123; worker.postMessage(&quot;ok&quot;); &#125; document.getElementById(&quot;stopButton&quot;).onclick = function() &#123; worker.terminate(); &#125;; &#125;&#125;&lt;/script&gt; (2)后台线程文件（worker.js）:123onmessage = function(e) &#123; postMessage(&quot;worker says: &quot; + e.data );&#125; 实战案例后台运算本示例设计一个文本框，允许用户在该文本框输入数字，然后点击计算按钮，在后台计算从1到给定数值的和。虽然对于从1到给定数值的求和计算只需要一个求和公式就可以了，本示例为了展示后台线程的使用方法，采取循环计算的方法。传统方法：12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;function calculate() &#123; var num = parseInt(document.getElementById(&quot;num&quot;).value, 10); var result = 0; for (var i = 0; i &lt;= num; i++) &#123; result += i; &#125; alert(&quot;合计值为&quot; + result + &quot;。&quot;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入数值:&lt;input type=&quot;text&quot; id=&quot;num&quot;&gt;&lt;button onClick=&quot;calculate()&quot;&gt;计算&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 虽然在文本框中输入较小的值时，不会有什么延迟问题。但是当用户在该文本框中输入特别巨大的数字，浏览器运行时间明显延迟。Web Workers方法：(1):主页文件123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;// 创建执行运算的线程var worker = new Worker(&quot;SumCalculate.js&quot;);//接收从线程中传出的计算结果worker.onmessage = function(event) &#123; //消息文本放置在data属性中,可以是任何JavaScript对象. alert(&quot;合计值为&quot; + event.data + &quot;。&quot;);&#125;;function calculate() &#123; var num = parseInt(document.getElementById(&quot;num&quot;).value, 10); //将数值传给线程 worker.postMessage(num);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入数值:&lt;input type=&quot;text&quot; id=&quot;num&quot;&gt;&lt;button onclick=&quot;calculate()&quot;&gt;计算&lt;/button&gt;&lt;/body&gt; (2)后台线程文件（SumCalculate.js）123456789onmessage = function(event) &#123; var num = event.data; var result = 0; for (var i = 0; i &lt;= num; i++) result += i; //向线程创建源送回消息 postMessage(result);&#125; 数值过滤在Web应用中，建议用户将非及时性的任务处理放在后台实现，以减轻前台的压力。本示例设计在页面上随机生成一个整数的数组，然后将该整数数组传入线程，让后台帮助挑选出该数组中可以被3整除的数字，然后显示在页面表格中。(1)在前台脚本中随机生成整数数组，然后送到后台线程挑选出能够被3整除的数字，再传回前台脚本，在前台脚本中根据挑选结果动态表格中的行、列，并将挑选出来的数字显示在表格中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var intArray=new Array(200);//随机数组var intStr=&quot;&quot;;//生成200个随机数for(var i=0;i&lt;200;i++)&#123; intArray[i]=parseInt(Math.random()*200); if(i!=0) intStr+=&quot;;&quot;; //用分号作随机数组的分隔符 intStr+=intArray[i]; &#125;//向后台线程提交随机数组var worker = new Worker(&quot;script.js&quot;);worker.postMessage(intStr);//从线程中取得计算结果worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;) &#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0) &#123;//如果该行不存在，则添加行 tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123;//如果该行存在，则获取该行 tr=document.getElementById(&quot;tr&quot;+j); &#125; //添加列 td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)后台线程文件12345678910111213141516onmessage = function(event) &#123; var data = event.data; var returnStr; //将3的倍数拼接成字符串并返回 var intArray=data.split(&quot;;&quot;); //返回字符串中数字分隔符为; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++) &#123; if(parseInt(intArray[i])%3==0) //能否被3整除 &#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //返回3的倍数拼接成的字符串&#125; 并发处理利用线程可以嵌套的特性，可以在Web应用中实现多个任务并发处理，这样能够提高Web应用程序的执行效率和反应速度。同时通过线程嵌套把一个较大的后台任务切分成几个子线程，在每个子线程中各自完成一部分相对独立的任务。本示例在上一节示例基础上，把主页脚本中随机生成数组的工作放在后台线程中，然后使用另一个子线程在随机数组中挑选可以被3整除的数字。对于数组的传递以及挑选结果的传递均采用JSON对象来进行转换，以验证是否能在线程之间进行Javascript对象的传递工作。(1)在主页面中定义一个线程。设计不向该线程发送数据，在onmessage事件回调函数中进行后期数据处理，并把返回的数据显示在页面中。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var worker = new Worker(&quot;script.js&quot;);worker.postMessage(&quot;&quot;);// 从线程中取得计算结果worker.onmessage = function(event) &#123;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)在后台主线程文件script.js中，随机生成200个整数构成的数组，然后把这个数组提交到子线程，在子线程中可以把能被3整除的数字挑选出来，然后送回主线程。主线程再把挑选结果送回页面进行显示。1234567891011121314onmessage=function(event)&#123; var intArray=new Array(200); for(var i=0;i&lt;200;i++) intArray[i]=parseInt(Math.random()*200); var worker; //创建子线程 worker=new Worker(&quot;worker2.js&quot;); //把随机数组提交给子线程进行挑选工作 worker.postMessage(JSON.stringify(intArray)); worker.onmessage = function(event) &#123; //把挑选结果返回主页面 postMessage(event.data); &#125;&#125; (3)设计子线程的任务处理代码。子线程在接收到的随机数组中挑选能够被3整除的数字，然后拼接成字符串并返回。12345678910111213141516onmessage = function(event) &#123; //还原整数数组 var intArray= JSON.parse(event.data); var returnStr; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++)&#123; if(parseInt(intArray[i])%3==0)&#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //关闭子线程 close(); &#125; 在子线程中向发送源发送回消息后，如果该子线程不再使用的话，应该使用close语句关闭子线程。(4)在页面的主线程回调函数中处理后台线程返回的数据，并将这些数据显示在页面中。12345678910111213141516171819202122worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;)&#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0)&#123; tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123; tr=document.getElementById(&quot;tr&quot;+j); &#125; td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;; 线程通信本示例继续在前面示例的基础上，将创建随机数组的工作也放到一个单独的子线程中，在该线程中创建随机数组，然后将随机数组传递到另一个子线程中进行能够被3整除的数字挑选工作，最后把挑选结果传递回主页面进行显示。设计思路：当主线程嵌套多个子线程时，子线程之间可以通过下面几个步骤进行通信。 先创建发送数据的子线程 执行子线程中的任务，然后把要传递的数据发送给主线程 在主线程接收到子线程传回来的消息时，创建接收数据的子线程，然后把发送数据的子线程中返回的消息传递给接收数据的子线程 执行接收数据子线程中的代码操作步骤：(1)完成主页面的设计。包括HTML结构和CSS样式。在主页脚本中创建一个主线程，定义请求数据为空，在主线程响应事件onmessage回调函数中处理后台返回的处理数据，并把它们显示在页面中。1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt;body &#123; font: normal 11px auto &quot;Trebuchet MS&quot;, Verdana, Arial, Helvetica, sans-serif; color: #4f6b72; background: #E6EAE9; &#125;table &#123; width: 700px; padding: 0; margin: 0; &#125;td &#123; border-right: 1px solid #C1DAD7; border-bottom: 1px solid #C1DAD7; background: #fff; font-size:11px; padding: 6px 6px 6px 12px; color: #4f6b72; text-align:center; &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;var worker = new Worker(&quot;script.js&quot;);worker.postMessage(&quot;&quot;);// 从线程中取得计算结果worker.onmessage = function(event) &#123; if(event.data!=&quot;&quot;)&#123; var j,k,tr,td; var intArray=event.data.split(&quot;;&quot;); var table=document.getElementById(&quot;table&quot;); for(var i=0;i&lt;intArray.length;i++)&#123; j=parseInt(i/10,0); k=i%10; if(k==0)&#123; tr=document.createElement(&quot;tr&quot;); tr.id=&quot;tr&quot;+j; table.appendChild(tr); &#125; else &#123; tr=document.getElementById(&quot;tr&quot;+j); &#125; //添加列 td=document.createElement(&quot;td&quot;); tr.appendChild(td); td.innerHTML=intArray[j*10+k]; &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table id=&quot;table&quot;&gt;&lt;/table&gt;&lt;/body&gt; (2)修改主线程中的代码。在主线程中定义一个子线程（发送数据），让其随机生成200个数字，并返回这个随机数组。在该子线程的回调函数中再定义一个子线程（接受数据），把接受到的随机数组传递给它，并接收该线程过滤后的数组。1234567891011121314151617181920onmessage=function(event)&#123; var worker; //创建发送数据的子线程 worker=new Worker(&quot;worker1.js&quot;); worker.postMessage(&quot;&quot;); worker.onmessage = function(event) &#123; //接收子线程中数据:创建好的随机数组 var data=event.data; //创建接收数据子线程 worker=new Worker(&quot;worker2.js&quot;); //把从发送数据子线程中发回消息传递给接收数据的子线程 worker.postMessage(data); worker.onmessage = function(event) &#123; //获取接收数据子线程中传回数据，本示例中为挑选结果 var data=event.data; //把挑选结果发送回主页面 postMessage(data); &#125; &#125;&#125; (3)在发送数据的子线程中创建一个200个整数构成的随机数组。然后把它转换为字符串并返回，最后关闭该子线程。1234567onmessage = function(event) &#123; var intArray=new Array(200); for(var i=0;i&lt;200;i++) intArray[i]=parseInt(Math.random()*200); postMessage(JSON.stringify(intArray)); close();&#125; (4)在接受数据子线程中对接受到的随机数组中挑选能被3整除的数字，然后拼接成字符串并返回。12345678910111213141516onmessage = function(event) &#123; //还原整数数组 var intArray= JSON.parse(event.data); var returnStr; returnStr=&quot;&quot;; for(var i=0;i&lt;intArray.length;i++)&#123; if(parseInt(intArray[i])%3==0)&#123; if(returnStr!=&quot;&quot;) returnStr+=&quot;;&quot;; returnStr+=intArray[i]; &#125; &#125; postMessage(returnStr); //关闭子线程 close(); &#125; Fibonacchi数列运算Fibonacci数列以递归的方式进行定义：F0=0；F1=1；Fn=F(n-1)+F（n-2）（n&gt;2）使用Javascript实现Fibonacci数列运算的一般方法为：123var fibonacci =function(n) &#123; return n &lt;2? n : arguments.callee(n -1) + arguments.callee(n -2);&#125;; 当计算工作量较大的时候，非常有可能造成浏览器罢工，可以使用Web Workers将数列计算过程放入一个后台线程里。(1)主页文件：123456789101112131415161718&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;web worker fibonacci&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; onload =function()&#123; var worker =new Worker(&apos;fibonacci.js&apos;); worker.addEventListener(&apos;message&apos;, function(event) &#123; console.log(event.data); &#125;, false); worker.postMessage(40); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; (2)后台线程文件（fibonacci.js）1234567var fibonacci =function(n) &#123; return n &lt;2? n : arguments.callee(n -1) + arguments.callee(n -2);&#125;;onmessage =function(event) &#123; var n = parseInt(event.data, 10); postMessage(fibonacci(n));&#125;;]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>Web Workers</tag>
      </tags>
  </entry>
</search>
